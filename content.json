[{"title":"JS异步编程","date":"2020-06-29T02:57:54.000Z","path":"2020/06/29/JS异步编程/","text":"","comments":true,"tags":[]},{"title":"JS正则表达式二","date":"2020-06-29T01:11:29.000Z","path":"2020/06/29/JS正则表达式二/","text":"正则表达式断言匹配正则表达式的条件语句，断言不是一个独立存在的，它是服务于正则表达式的，条件不是值，匹配出来的内容还是正则表达式的内容。先行后行指的是正则的位置。 1，零宽先行断言，先行断言判断的条件是后面 后边是谁(？=)，断言也是用括号括起来的，但是断言不算原子组。 1234567891011//此例中为后盾人后面跟着教程的这个后盾人加上链接。&lt;body&gt; &lt;main&gt; 后盾人不断分享视频教程，学习后盾人教程提升编程能力。 &lt;/main&gt;&lt;/body&gt;&lt;script&gt; let main = document.querySelector('main') let reg = /后盾人(?=教程)/ // main.innerHTML = main.innerHTML.replace(reg, `&lt;a href=\"https://baidu.com\"&gt;$&amp;&lt;/a&gt;`)&lt;/script&gt; 12345678910111213141516//为价格加上两位小数，00，在回调函数做判断 let lessons = ` js,200元,300次 php,300.00元,100次 node.js,180元,260次 ` let reg = /(\\d+)(.00)?(?=元)/ig //匹配出所有价格，包括已经有了00的 lessons = lessons.replace(reg, (v, ...args) =&gt; &#123; //console.log(args) //没有原原子组（.00）的args[1]是吨undefined args[1] = args[1] || '.00' //有就直接取自己，没有就赋值为00，短路返回原值的特性 return args.splice(0, 2).join('') //返回想要替换的格式 &#125;) console.log(lessons) // js, 200.00元, 300次 // php, 300.00元, 100次 // node.js, 180.00元, 260次 2，零宽后行断言，后行断言判断的条件是前面。前面是谁，多了个向前的箭头，位置也在前(?&lt;=) 1234let hd=\"123后盾人后盾人456\" let reg=/(?&lt;=\\d+)后盾人/ //匹配出前面是数字的那个后盾人 console.log(hd.match(reg)) console.log(hd.replace(reg,'被替换'))//123被替换后盾人456;前面是是数字的那个后盾人被替换了 混合使用 12345678910111213141516&lt;body&gt; &lt;main&gt; &lt;a href=\"https://baidu.com\"&gt;百度&lt;/a&gt; &lt;a href=\"https://yahoo.com\"&gt;雅虎&lt;/a&gt; &lt;/main&gt;&lt;/body&gt;&lt;script&gt; //将所有网址替换为bilibili.com let main = document.querySelector('main') let reg = /(?&lt;=href=(['\"])).+(?=\\1)/ig //.+就是网址,前面括号前断言，后面括号后端有。第一个括号内括号是原子组表示单双引号 console.log(main.innerHTML.match(reg))//[\"https://baidu.com\", \"https://yahoo.com\"] main.innerHTML = main.innerHTML.replace(reg, \"https:/bilibili.com\") console.log(main.innerHTML) // &lt;a href=\"https:/bilibili.com\"&gt;百度&lt;/a&gt; // &lt;a href=\"https:/bilibili.com\"&gt;雅虎&lt;/a&gt;&lt;/script&gt; 3，零宽负向先行断言 后面不是谁，(?!) 12345let hd = \"houdunren2010hdcms\"; let reg1 = /[a-z]+(?!\\d+)/g //后面不是数字的多个字符（有两个满足的） let reg2 = /[a-z]+$(?!\\d+)/g;//且以字母结尾 console.log(hd.match(reg1));//[\"houdunre\", \"hdcms\"],因为n后面是数字所有n怎样也拿不到 console.log(hd.match(reg2));//hdcms 4，零宽负向后行断言 前面不是谁，(?&lt;!) 12345678//获取前面不是数字的字符串。hcms let hd = \"hdcms99houdunren\"; let reg=/(?&lt;!\\d)[a-z]+/ //不能用\\w,因为\\w包括字母数字下划线 console.log(hd.match(reg))//\"hdcms\" //用\\w是无法区分 let reg2=/(?&lt;!\\d)\\w+/ console.log(hd.match(reg2))//\"hdcms99houdunren\"","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://zhoubb96.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"断言匹配","slug":"断言匹配","permalink":"https://zhoubb96.github.io/tags/%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D/"}]},{"title":"数据结构与算法-排序二","date":"2020-06-28T12:03:57.000Z","path":"2020/06/28/数据结构与算法-排序二/","text":"引言前面已经实现了冒泡排序，选择排序，插入排序等简单排序（o(n^2)）；也实现了希尔排序（o(n^1.5)），快速排序（o(nlogn)）等高级排序。接下来介绍例外几种高级排序。归并排序（合并排序）​ 初步理解分治策略，就是把大问题分解到小问题，再由小问题合并成大问题，有个分解的过程，这里面的小问题可以用其他的方法解决。小问题到大问题的合成中涉及到的问题就是合并有序的数组（这里就和快速排序的指针很像）。 过程： 1，将原数组不断拆分到长度为1；可以用递归实现 2，不断将已经排序的数据合并到原数组。空间复杂度比较不理想，产生了许多小的零时数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function ArrayList() &#123; //属性 this.array = [] //插入,展示,交换 ArrayList.prototype.insert = function (item) &#123; this.array.push(item) &#125; ArrayList.prototype.toString = function () &#123; return this.array.join('-') &#125; ArrayList.prototype.swap = function (a, b) &#123; let temp = this.array[a] this.array[a] = this.array[b] this.array[b] = temp &#125; //高级排序 ArrayList.prototype.mergesort = function () &#123; return this.split(0, this.array.length) &#125; //拆分，递归实现,拆分不时间产生零时数组，只是计算好位置 ArrayList.prototype.split = function (left, right) &#123; //1，终止条件，直到数组长度为一时返回 if (right - left &lt; 2) return this let center = Math.floor((left + right) / 2) this.split(left, center)//左边 this.split(center, right)////右边 return this.merge(left, center, right)//利用计算好的位置调用合并，同层次的合并，在最后一步返回就好了 &#125; //合并 ArrayList.prototype.merge = function (left, center, right) &#123; //定义两个零时空间 let arr1 = this.array.slice(left, center)//注意是不包括结束位置的是开区间 let arr2 = this.array.slice(center, right) //追加两个正无穷，这样可以减少边界值判断的复杂程度 arr1.push(Number.MAX_SAFE_INTEGER)//用i来记录 arr2.push(Number.MAX_SAFE_INTEGER)//用j来记录 //i和j为两个零时数组的指针变量，k为被写入数组的位置变量 for (let i = 0, j = 0, k = left; k &lt; right; k++) &#123;//因为有正无穷所以免去了ij的判断 // if(arr1[i]&lt;arr2[j])&#123; // this.array[k]=arr1[i] // i++ // &#125;else&#123; // this.array[k]=arr2[j] // j++ // &#125; this.array[k] = arr1[i] &lt; arr2[j] ? arr1[i++] : arr2[j++]//合并判断赋值和变量累加 &#125; return this &#125; &#125; let list = new ArrayList() list.insert(66) list.insert(88) list.insert(12) list.insert(87) list.insert(100) list.insert(5) list.insert(566) list.insert(23) list.insert(99) console.log(list.toString())//66-88-12-87-100-5-566-23-99 console.log(list.mergesort().toString())//5-12-23-66-87-88-99-100-566","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-二分查找","date":"2020-06-28T09:36:25.000Z","path":"2020/06/28/数据结构与算法-二分查找/","text":"查找 数组可以通过下标来查找，这样最快；但是不是所有数据结构都有下标，那么就需要循环遍历查找，那么是否需要逐个排查呢？ 对于无序数据，因为没有规律，故只能逐个排查。 对于有序数据，那么规律是已知的，可以利用规律来查找，所以有序数据是我们所需要的，在查找之前我们最好用排序来保证数据的有序性。二分查找就是有序数据的一种查找方法 1000个数，如果循环遍历，需要1000次；如果是二分查找，只需要10次，2^10=1024。二叉搜索树其实就用到二分查找的思想。每次对半查找区间。 二分查找，查找时间复杂度为o(logn)，准确来说是以2为底的对数。 123456789101112131415161718192021222324252627282930313233343536function Bserach(arr, value) &#123; //初始值 let left = 0 let right = arr.length - 1 let center//声明 //开始查找 while (left &lt;= right) &#123; center = Math.floor((left + right) / 2) if (value == arr[center]) return center//第一次比较 if (value &lt; arr[center]) &#123; right = center - 1//如果值比中间值小更新右边界,不是center因为已经比过了 &#125; else &#123; left = center + 1//如果值比中间值大更新左边界 &#125; &#125; //查询完毕没有返回下标，没查到 return -1 &#125; arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] console.log(Bserach(arr, 9))//递归实现function Bsearch1(arr,value,left=0,right=arr.length-1)&#123; let center=Math.floor((left+right)/2) //终止条件 if(left&gt;right) return -1 if(value==arr[center]) return center //递归调用 if(value&lt;arr[center])&#123; return Bsearch1(arr,value,left,center-1) &#125;else&#123; return Bsearch1(arr,value,center+1,right) &#125; //简化写法 return value&lt;arr[center]?Bsearch1(arr,value,left,center-1):Bsearch1(arr,value,center+1,right) &#125; 在查找插入时可以用此方法优化。","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-递归与穷举","date":"2020-06-28T09:31:29.000Z","path":"2020/06/28/数据结构与算法-递归与穷举/","text":"","comments":true,"tags":[]},{"title":"JS正则表达式一","date":"2020-06-27T04:06:20.000Z","path":"2020/06/27/JS正则表达式一/","text":"正则表达式对字符串进行增删改查，比字符串提供的原生条件更加灵活。 正则表达式初体验 12345678910let hd = \"z19960415bb\" //方法1，filter方法 console.log([...hd].filter((value)=&gt;&#123; let value1=parseInt(value) console.log(value1) console.log(typeof value1)//NaN也是number类型，只是不是一个数字，因此用typeof无法区分 return Number.isNaN(parseInt(value))//返回不是数字哪些选项 &#125;))//[\"z\", \"b\", \"b\"]//方法2，正则表达式 console.log(hd.match(/\\d/g))//返回数字[\"1\", \"9\", \"9\", \"6\", \"0\", \"4\", \"1\", \"5\"] 创建正则表达式的方法1，字面量形式；用两个斜杠包裹正则表达式语句 12let hd = \"z19960415bb\"console.log(/a/.test(hd))//false，hd里面没有字符a 2，对象创建形式 123let hd = \"z19960415bb\" let reg=new RegExp(\"u\",\"g\") console.log(reg.test(hd))//false 练习常见规则 字符限制 \\d表示数字；\\w表示数字字符下划线；.表示除了换行符以外的所有；\\s表示空格。如果单独只要字母[a-z] 数量修饰 +表示一个或者多个[1,n]； *****表示0个或者多个[0,n]； ?表示有或者没有[0,1]； {a,b}，注意是逗号，a到b个。 数量默认是贪婪的，会尽量取大的数字；如果想取小的数字，可以在数量修饰后面加一个问好？ 例如；{2,},此时会有多少取多少；{2,}?，此时至多取2. 模式修饰 i表示不区分大小写； g表示全局匹配可以不连续满足条件； m表示多行修正； y表示全局但是必须连续满足条件； s忽略换行符。 原子组，在只有一个元素得情况下原子组会占数组长度；如果有多个元素那就不占数组长度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 let hd = \"010-9999999\" //console.log(/(010|020)\\-\\d&#123;7,8&#125;/.test(hd))//true //原子表[]，里面放正则表达式就是出现什么要什么。[-\\d:,],-数字：，都要就是全或。满足就拿出来 //[^-\\d:,]相反，除了-数组:,其他都要，也就是^在原子表里表示除了。 let date=\"2020/06-27\" console.log(date.match(/^\\d&#123;4&#125;[-\\/]\\d&#123;2&#125;[-\\/]\\d&#123;2&#125;/))//2020/06-27,时刻关注转义。 //原子组（），放外面才是原子组，放里面只是括号。 let reg1 = /(12|34)///里面是一个整体，12或者34 let price1 = 23.34 //console.log(/\\d+\\.+\\d/.test(price))//true,+表示一个或多个。\\d+,表示一个或多个数字。 //.需要转义，.默认表示除换行外任意字符。 //在对象方式里要多一个转义。还是字面量方式好。 //原子组，在只有一个元素得情况下原子组会占长度 let hd = `&lt;h1&gt;houdunren&lt;/h1&gt; &lt;h2&gt;hdcms&lt;/h2&gt; ` let reg = /&lt;(h[1-6])&gt;[\\s\\S]*&lt;\\/\\1&gt;/ig//\\1表示取第一个原子组也就是(h[1-6]) console.log(hd.match(reg)) let hd1 = ` &lt;h1&gt;houdun&lt;/h1&gt; &lt;span&gt;后盾&lt;/span&gt; &lt;h2&gt;hdcms&lt;/h2&gt; `; let reg = /&lt;(h[1-6])&gt;([\\s\\S]+)&lt;\\/\\1&gt;/gi;//用([\\s\\S])报下内部所有 // console.log(hd1.replace(reg, `&lt;p&gt;$2&lt;/p&gt;`));//$2表示第二个原子组，也就是表示$2留下了，只让外部变成了p标签。 let res = hd1.replace(reg, (p0, p1, p2) =&gt; `&lt;p&gt;$&#123;p2&#125;&lt;/p&gt;`);//p1,p2分别是原子表 console.log(res); let url = \"https://www.baidu.com\" //\\w表示字母、数字、下划线 //console.log(/https?:\\/\\/\\w+\\.\\w+\\.+\\w/.test(url))//?表示0或者多个。s是可选的，所以在s后面有个问号？表示有或者没有 // /需要转义，因为正则表达式是用/包裹的。默认情况它为分界线。 let s = \"z19960415b\" //console.log(/^\\d/.test(s))//false,^是开头限定，这里是限定数字开头。 let a = \"zbb\" //console.log(a.match(/^[a-z]&#123;3,6&#125;$/))//[\"zbb\", index: 0, input: \"zbb\", groups: undefined] //如果不加^与$,那么长度超过6位的时候也会成功，但是不想要超过六位的就必须加上$截断。 //test是检查是否含有，match是匹配并选出 // console.log(s.match(/\\d+/g))//[\"19960415\"],g表示全局匹配，加在正则表达式外面 8 //小写\\d为数字，大写\\D为除了数字。 let tele = `lisi:010-11111111` // console.log(tele.match(/\\d+\\-\\d+/))//\"010-11111111\",匹配所有数字 //console.log(tele.match(/\\D+/))//\"lisi:\",如果没有加号+，那就只会返回一个，所以一定带上数量限制。 //\\s表示空白，\\S除了空白 //\\w表示字母、数字、下划线,\\W除了字母数字下划线。 let email = \"abc00001@qq.com\" //console.log(email.match(/^\\w+@\\w+\\.\\w+$/g)) //\\d,\\w,.分别为数字，字母数字下划线，除了换行符的所有输入。 //如何匹配所有字符？使用原子表[\\s\\S]这样就是所有字符，方然[\\d\\D]也可以。 //模式修正符，i不区分大小写，g全局，m是多行修正 let name1 = \"zbbB\" // console.log(name.match(/b+/))//bb // console.log(name.match(/B/))//B // console.log(name.match(/b+/i))//bbB,不区分大小写 // console.log(name.replace(/b/,'@'))//z@bB // console.log(name.replace(/b+/,'@'))//z@B // console.log(name.replace(/b+/i,'@'))//z@,+会把他们当作一个整体替换掉了，不能实现g全局的的效果 // console.log(name.replace(/b/g,'@'))//z@@B // console.log(name.replace(/b/gi,'@'))//z@@@，g会把每个元素当作一个独立的个体 //多行匹配 let ml = ` #1 js,200元 # #2 php,300元 # #9 houdunren.com # 后盾人 #3 node.js,180元 # ` console.log(ml.match(/^\\s*#\\d+\\s+.+\\s+#$/gm))//不写m，会当作一行从而匹配为null。以空格开头以井号结尾 let kechen = ml.match(/^\\s*#\\d+\\s+.+\\s+#$/gm).map(v =&gt; &#123; v = v.replace(/\\s*#\\d+\\s*/, '').replace(/\\s*#/, '')//去掉前面的空格星号井号和数字，再去掉后面的空格和井号 console.log(v)//查看格式 let [name, price] = v.split(',')//结构赋值要先写let声明 return &#123; name, price &#125; &#125;) console.log(kechen)// 0: &#123;name: \"js\", price: \"200元\"&#125;// 1: &#123;name: \"php\", price: \"300元\"&#125;// 2: &#123;name: \"node.js\", price: \"180元\"&#125; //自定义matchAll方法 String.prototype.matchAll = function (reg) &#123; let res = this.match(reg) if (res) &#123;//递归停止条件 //递归函数体 let str = this.replace(res[0], \"^\".repeat(res[0].length))//替换第一个 let match = str.matchAll(reg) || []//递归调用，最后无结果是，边设置为空数组 return [res, ...match] &#125; &#125; let zbb2 = \"zbb1996\" console.log(zbb2.matchAll(/b/i)) // 0: [\"b\", index: 1, input: \"zbb1996\", groups: undefined] // 1: [\"b\", index: 2, input: \"z^b1996\", groups: undefined 多个正则作用在一个字符串12345678let password = \"abC211\" let reg1 = /^[a-z0-9]&#123;5,10&#125;$/i //以字母或者数字开头结尾，不区分大小写，整体长度为5到10位 let reg2 = /[A-Z]/ //必须包含大写字母 let reg3 = /\\d/ //必须包含数字 reg = [reg1, reg2, reg3]//或者直接reg=[/^[a-z0-9]&#123;5,10&#125;$/i,/[A-Z]/,/\\d] let state = reg.every((value) =&gt; value.test(password)) //一条语句尽量不要加花括号，因为加了花括号，就算只有一条语句也要加个return console.log(state) 使用正则表达式方法exec来完成全局匹配exce(返回对象数组)，test(返回真或假)，lastIndex(返回下一次开始下标)等是正则表达式的方法 match是字符串的方法str.match(teg)，exec是正则表达式的方法reg.exec(str)。 exec是步进的，每次运行会使得lastIndex属性发生变化，exec返回一个对象，如果查找失败返回null空对象。lastIndex属性是控制正则表达式开始搜索的位置，lastIndex从0开始，搜索后值加1。必须在全局模式g下使用，不然一直是0！！！匹配失败是也是归零！ 123456789101112131415161718192021let zbb = \"zbbandbrando\" let reg = /b/g console.log(reg.exec(zbb))//b，下标为1 console.log(reg.lastIndex)//2,比下标大一 console.log(reg.exec(zbb))//b，下标为2 console.log(reg.lastIndex)//3 console.log(reg.exec(zbb))//b下标为6 console.log(reg.lastIndex)//7 console.log(reg.exec(zbb))//null,找不到 console.log(reg.lastIndex)//0 function search(str, reg) &#123; let result = [] while ((res = reg.exec(str))) &#123;//把查找值付给res，在res部位空时进入 result.push(res) &#125; return result &#125; console.log(search(zbb, reg)) // 0: [\"b\", index: 1, input: \"zbbandbrando\", groups: undefined] // 1: [\"b\", index: 2, input: \"zbbandbrando\", groups: undefined] // 2: [\"b\", index: 6, input: \"zbbandbrando\", groups: search，replace，match，matchAll等是字符串方法 1234567891011121314151617//1，search返回搜索内容的索引，找不到返回-1let str = \"zbb\" console.log(str.search('b'))//1 let site = ` https://hdcms.com http://www.sina.com.cn https://www.houdunren.com`//有的是http有的是https，有的有www.有的没有，有的有多个点如新浪这个 let reg = /https?:\\/\\/(\\w+\\.)?(\\w+\\.)+(com|cn|org)/ig //2，match方法返回匹配到的内容 console.log(site.match(reg))//[\"https://hdcms.com\", \"http://www.sina.com.cn\", \"https://www.houdunren.com\"]//3，matchAll返回一个可迭代对象 for (const iterator of site.matchAll(reg)) &#123; console.log(iterator) &#125; $在替换中的使用分组思想，整体替换！！ 12345678910let tel = \"(010)99999999 (020)8888888\"; let reg=/\\((\\d&#123;3,4&#125;)\\)(\\d&#123;7,8&#125;)/g console.log(tel.match(reg))//$1是010，$2是99999999,会被自动记录下来，分组思想。保留整体 //010 - 99999,也就是用-连接，那么就原对象变成$1-$2 console.log(tel.replace(reg,\"$1-$2\"))//010-99999999 020-8888888 //$`表示组元素的左边 $'表示组元素的右边 $&amp;9就是匹配的元素加9，$&amp;才表示自己 $不可以单独使用。 let zbb=\"frontzbbafter\" //console.log(zbb.replace(/zbb/,\"$&amp;9\"))//frontzbb9after，把zbb替换成zbb9 console.log(zbb.replace(/zbb/,\"$`\"))//frontfrontafter,把zbb替换成它前面的front","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://zhoubb96.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"JS模块化","date":"2020-06-27T01:40:04.000Z","path":"2020/06/27/JS模块化/","text":"一点历史在JS提供模块管理方式之前；模块管理工具主要有。AMD的require.js，CMD的sea.js，以及服务于nodejs的common.js。 模块管理要处理模块依赖，添加模块等关系。 自定义模块分析模块管理原理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//模块管理引擎 let module = (function () &#123; //属性 const moduleList = &#123;&#125;//定义模块列表对象储存所有模块 //方法 function define(name, relymodules, action) &#123;//模块定义函数 //name为模块名，relymodules是依赖模块的字符串数组，action是模块具体要执行的动作 //1，模块的依赖处理，取出新模块要依赖的模块 relymodules.map((module, index) =&gt; &#123;//传进来的只是一个字符串数组 relymodules[index] = moduleList[module]//从模块列表根据字符串取出依赖的模块 &#125;) //2，将新模块添加到模块列表，并将依赖模块传入新添加模块供其使用 moduleList[name] = action.apply(null, relymodules)//取出依赖模块后，将依赖模块传入新添加模块 //console.log(moduleList) &#125; return &#123; define &#125;//返回一个包含定义函数的对象，这个函数供外部以对象方法的形式调用 &#125;)() //测试引擎，自定义不依赖于其他模块的一个独立的工具模块 module.define('tools', [], function () &#123;//新添加tools模块，且没有依赖 //返回一个包含方法的对象,return称为导出！让外部使用功能，以对象方法形式调用 return &#123; first(arr) &#123; return arr[0]//第一个元素 &#125;, max(arr,key) &#123; return arr.sort((a, b) =&gt; b[key] - a[key])[0]//最大值，降序的第一个 &#125; &#125; &#125;) //定义一个数据模块依赖于管理模块测试管理模块 //那么如何使用这个tools？这个lesson模块不对外提供功能，只是为了让它依赖tools模块，使用tools返回的方法。lesson依赖于tools，将tools传入lesson(action) module.define('lesson', ['tools'], function (tools) &#123;//把tools模块传入到了lesson //模块的依赖 //console.log(tools) let data = [ &#123; name: \"js\", price: 199 &#125;, &#123; name: \"mysql\", price: 78 &#125; ] console.log(tools.max(data,'price'))//lesson内部可直接使用tools了 &#125;) JS提供的模块使用1，zbb.js模块 12345678let name=\"zbb\"let age=24function show(name)&#123; console.log(name)&#125;export&#123;name,age,show&#125;//批量导出，模块是个私有空间，如果不导出接口就无法使用//默认导出只导出一个！！！//接受默认导出的时候也可以不用花括号，而且可以用任意名称接受。 2，使用zbb.js 123456&lt;script type=\"module\"&gt;//必须加上类型才能使用模块功能，因为早期script标签没那么多属性 import&#123;name,gae,show&#125; from './zbb.js'//想用什么导入什么;具名导入 //import * as api from './zbb.js'//*表示全部导入，使用时用api这个统一接口,as后面就是别名。设置了别名，就只可以通过别名导入和使用。 consolo.log(name) //consolo.log(api.name)&lt;/script&gt; 一般用一个index的js文件聚合所有导入。 模块的延迟解析与严格模式普通脚本在不做任何设置的时候不会延迟解析，从上至下。而模块会自动延迟解析(考虑到模块的依赖)，模块默认运行在严格模式下面。 模块的有自己独立的作用域。1234567891011&lt;script type=\"module\"&gt; let site = \"www.baidu.com\"&lt;/script&gt;&lt;script&gt; console.log(site)//site is not defined，普通标签无法访问&lt;/script&gt;&lt;script type=\"module\"&gt; console.log(site)//site is not defined，不同的模块也无法访问&lt;/script&gt; 模块预解析无论加载多少次，只会在第一次加载的时候执行，（只有第一次管用） 打印模块，say.js 1console.log(\"wow\") 引入模块 123456&lt;script type=\"module\"&gt; import&#123;&#125; form './say.js';//wow，只有这一次输出了 import&#123;&#125; form './say.js'; import&#123;&#125; form './say.js'; import&#123;&#125; form './say.js';&lt;/script&gt; 按需动态加载模块标签加载必须写在顶层(静态的)，但是写在顶层不能实现按需加载的要求。import函数可以动态的加载，而不是在标签里加载。！！！ 12//使用import加载函数import(\"./say.js\")","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"模块化","slug":"模块化","permalink":"https://zhoubb96.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"数据结构与算法-排序一","date":"2020-06-26T06:30:45.000Z","path":"2020/06/26/数据结构与算法-排序一/","text":"算法的效率表示。 常数级 o(1) 对数级 o(log(n)) 线性级 o(n) 线性对数级 o(nlog(n)) 平方级 o(n^2) 指数级 o(2^2) 简单排序（都以升序为例）冒泡排序，选择排序 1，冒泡排序法 两层循环 比较次数为(n-1)+(n-2)+……+2+1=n(n-1)/2，所以冒泡排序法的时间复杂度为o(n^2)。 不是每次比较都要交换，交换的概率为1/2，所以交换次数为n(n-1)/4； 2，选择排序法 两层循环 比较次数为(n-1)+(n-2)+……+2+1=n(n-1)/2，所以选择排序法的时间复杂度为o(n^2)。 经过一层循环后挑出最值才进行交换，只交换n-1次；所以交换次数减少为o(n) 3，插入排序 局部有序的思想！有序部分越来越长。 因为不需要全部比较，只需要和有序部分进行比较(向前比较)，所以可能的比较次数减少了。不过如果是以数组形式的来表示的话，插入，移动元素时可能会浪费一些资源。 比较次数减少一半为n(n-1)/4，移动次数也为n(n-1)/4；移动(复制)没有比较消耗性能！比较操作最耗费性能。插入排序的时间复杂度为o(n^2)。 不同时间复杂度的排序，首先看时间复杂度；相同时间复杂度情况下，看比较次数。 效率，插入排序&gt;选择排序&gt;冒泡排序；所有简单排序都是稳定的。 高级排序 1，希尔排序 插入排序，新插入数据总是以步长1向前寻找插入位置，如果新插入数据比较小，那么需要移动的中间数据量就比较大。希尔排序可以做到不必移动所有中间数据。 不是一次性把数据移动到正确位置；但是每次移动都会离正确位置更近！ 一开始间隔较大，最后间隔为1。常见增量序列为半数增量（每次长度缩小一倍）；奇数序列增量1，3，5，7，…。 同一gap的分组进行插入排序，gap逐渐缩减到1。所以有三层循环！gap控制一层；相同gap不同分组的插入排序两层！ 希尔的效率因为难以证明，所以简单的认为效率为o(n^1.5) 2，快速排序 适用性最广，几乎最快。 一次循环就可以找到某个元素的正确位置，那么这个枢纽的选取？ 取头中尾的中位数。 分而治之的思想，每次选的那个元素，就可以找到它正确的位置，左小右大，那么它的位置就确定了。每次选一个元素，最终递归完成，排序完成。 左右用两个指针。效率为o(nlog(n)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//先封装一个列表封装数据 function ArrayList() &#123; //属性 this.array = [] //插入,展示,交换 ArrayList.prototype.insert = function (item) &#123; this.array.push(item) &#125; ArrayList.prototype.toString = function () &#123; return this.array.join('-') &#125; ArrayList.prototype.swap = function (a, b) &#123; let temp = this.array[a] this.array[a] = this.array[b] this.array[b] = temp &#125; //排序算法，升序 //简单排序 //1，冒泡排序 ArrayList.prototype.bubblesort = function () &#123; let length = this.array.length for (let i = 0; i &lt; length - 1; i++) &#123; for (let j = i; j &lt; length; j++) &#123; if (this.array[j - 1] &gt; this.array[j]) &#123; this.swap(j - 1, j) &#125; &#125; &#125; return this//返回对象，以方便继续调用对象方法 &#125; //2，选择排序 ArrayList.prototype.selectionsort = function () &#123; let length = this.array.length for (let i = 0; i &lt; length - 1; i++) &#123; let min = i//初始最小值下标为i for (let j = i; j &lt; length; j++) &#123; if (this.array[min] &gt; this.array[j]) &#123; min = j//循环一趟造成最小值下标j &#125; &#125; this.swap(i, min)//真实最小值下标，找到才交换，所以交换次数减少 &#125; return this &#125; //3，插入排序 ArrayList.prototype.insertionsort = function () &#123; let length = this.array.length for (let i = 1; i &lt; length; i++) &#123;//从第二个位置获取数据，向前面有序部分进行插入 //内层循环，获取位置i数据，和前面的数据进行比较 let temp = this.array[i] let j = i while (this.array[j - 1] &gt; temp &amp;&amp; j &gt; 0) &#123;//不确定循环次数,向前比较，寻找插入位置。与有序部分比较减少次数。 this.array[j] = this.array[j - 1]//元素后移 j--//继续往前找 &#125; //把temp插入到正确位置 this.array[j] = temp &#125; return this &#125; //高级排序 //1，希尔排序 ArrayList.prototype.shellsort = function () &#123; let length = this.array.length //初始化增量 let gap = Math.floor(length / 2) //第一层while循环减小gap while (gap &gt;= 1) &#123; //第二层循环同一gap不同分组的创建 //i等于gap，就是从每组的第二个元素开始 for (i = gap; i &lt; length; i++) &#123;//这里是i++,因为同一gap下的不同分组的起始值是连续分布的，增量为1。 temp = this.array[i] let j = i //第三层循环同一gap同一分组的元素进行插入排序 while (this.array[j - gap] &gt; temp &amp;&amp; j &gt; 0) &#123;//同一gap的同一分组的不同元素增量是gap this.array[j] = this.array[j - gap] j -= gap &#125; this.array[j] = temp &#125; gap = Math.floor(gap / 2) &#125; return this &#125; //2,快速排序 // 选择枢纽 ArrayList.prototype.pivot = function (left, right) &#123; // 1.求出中间的位置 var center = Math.floor((left + right) / 2) // 2.判断并且进行交换 if (this.array[left] &gt; this.array[center]) &#123; this.swap(left, center)//二者大的到了中间 &#125; if (this.array[center] &gt; this.array[right]) &#123; this.swap(center, right)//最大值到了右边 &#125; if (this.array[left] &gt; this.array[center]) &#123; this.swap(left, center)//次大值到了中间，注意又是比较left与center！！！ &#125; // 3.将center移动到right - 1的位置;这样比较操作可以减少一个 this.swap(center, right - 1) // 4.返回pivot return this.array[right - 1]//后面要以这个值为基准进行比较。 &#125; ArrayList.prototype.quicksort = function () &#123; return this.quicksortRec(0, this.array.length - 1)//初始化调用递归并返回最终对象 &#125; ArrayList.prototype.quicksortRec = function (left, right) &#123; //1，递归结束条件 if (left &gt;= right) return this//返回设置好的对象 //2，递归函数体 //获取枢纽 let pivot = this.pivot(left, right) //指针记录变量，这里的记录的初始值的设定决定了递归调用区间的开闭性。 let i = left + 1//left已经比right-1枢纽小 let j = right - 2//right已经比pivot比较，而且没必要和自己比较 while (true) &#123;//i&lt;=j时，继续进入循环，找下一对可以交换的。 while (this.array[i] &lt; pivot) &#123;//在左边找到比枢纽大的值停下,这里也是要循环的，如果只有if，只变一次 i++ &#125; while (this.array[j] &gt; pivot) &#123;//在右边找到比枢纽小的值停下 j-- &#125; if (i &lt; j) &#123;//等于就没必要交换，自己和自己交换没意义 this.swap(i, j) &#125; else &#123; break//不写这句，就算不交换也不会跳出循环 &#125; &#125; //3，递归调用 //这里时i-1与i取决于i和j的初始值的设置；如果设置是j=right-1，那么右区间的就是从i+开始 this.quicksortRec(left, i-1)//左边设置完毕 return this.quicksortRec(i, right)//右边也设置完毕，返回该对象 &#125; &#125; let list = new ArrayList() list.insert(66) list.insert(88) list.insert(12) list.insert(87) list.insert(100) list.insert(5) list.insert(566) list.insert(23) list.insert(99) //所有方法均返回设置好的对象，以便于统一调用toString方法以供展示 console.log(list.toString())//66-88-12-87-100-566-23 //console.log(list.bubblesort().toString())//冒泡排序12-23-66-87-88-99-100-566 //console.log(list.selectionsort().toString())//选择排序 //console.log(list.insertionsort().toString())//插入排序 //console.log(list.shellsort().toString())//希尔排序 console.log(list.quicksort().toString())//快速排序","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS的class类以及其继承关键字","date":"2020-06-24T03:49:30.000Z","path":"2020/06/24/JS的class类以及其继承关键字/","text":"需要明确的是类的继承本质上还是原型继承，这里是分析类继承的形式1，类的属性继承形式12345678910111213141516class User&#123; constructor(name)&#123; this.name=name &#125;&#125;class Admin extends User&#123; constructor(name,age)&#123;//super会调用父类的构造函数 super(name)//这句话等同于函数声明方式中的User.prototype.constructor.call(this,name) //super不会出现this攀升出现的问题。但是super必须写在第一次使用this之前。因为super会先把this指向父类 //在super之后，this回到子类 //子类中constructor与super要么不写，要么一起写，而且this要在super下面，不然会报错。 this.age=age &#125;&#125;let ad=new Admin('zbb',24)console.log(ad.name,ad.age)//zbb,24 2，类的方法继承形式123456class User &#123; show() &#123;console.log(\"User\")&#125;&#125;class Admin extends User &#123; &#125;let ad = new Admin()console.log(ad.show())//User，直接调用 3，super关键字super还可以实现多层继承，this.__proto__.show.call(this)//因为this不会向上。这种方法在超过两层关系的时候就会出现问题，因为this是不会主动攀升的。而用super不会出现这个问题，super可以解决攀升问题！ 1234567891011121314151617class User &#123; show() &#123; console.log(\"user\"); &#125;&#125;class Admin extends User &#123; constructor(name) &#123; super() this.name = name; &#125; show() &#123; super.show()//this.__proto__.show.call(this)//因为this不会向上。 console.log(\"admin\"); &#125;&#125;let hd = new Admin(\"zbb\");hd.show();//user,admin;因为是进入自己的show，而在自己的show我们又添加了一句super.show()，这就会通过super访问到父级的show，先输出了user然后再输出admin 在类中使用访问控制器123456789101112131415161718192021class Request &#123; constructor(url) &#123; this.data = &#123; url &#125; &#125; set host(url) &#123;//伪造属性 if (!/^http?:\\/\\//i.test(url)) &#123; throw new Error(\"请以协议开头\") &#125; this.data.url = url &#125; get host()&#123; return this.data.url &#125;&#125;let baidu = new Request(\"http://www.baidu.com\")console.log(baidu)//Request &#123;data: &#123;…&#125;&#125;baidu.host = 'http://baidu?'console.log(baidu.host)//http://baidu?baidu.host='baidu?'////Uncaught Error: 请以协议开","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"访问控制器","slug":"访问控制器","permalink":"https://zhoubb96.github.io/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"super关键字","slug":"super关键字","permalink":"https://zhoubb96.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"class类的属性继承形式","slug":"class类的属性继承形式","permalink":"https://zhoubb96.github.io/tags/class%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF%E5%BD%A2%E5%BC%8F/"},{"name":"class类的方法继承形式","slug":"class类的方法继承形式","permalink":"https://zhoubb96.github.io/tags/class%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%A7%E6%89%BF%E5%BD%A2%E5%BC%8F/"}]},{"title":"JS的class类以及静态属性","date":"2020-06-24T01:50:48.000Z","path":"2020/06/24/JS的class类以及静态属性/","text":"学习完原型和继承之后，引入类的概念。类可以让面向对象变得更简单，依然采用原型机制，是一个语法糖。 1，之前的函数关键字定义 使用函数关键字function定义 往原型上加方法时要也要用函数关键字function 原型方法可以被遍历到（emumerable默认为true） 123456789101112131415161718 function User(name, age) &#123; //实例属性 this.name = name this.age = age this.get = function()&#123;//实例方法，每个函数都带一份，会重复占用空间 console.log(\"wow\") &#125; //原型方法 User.prototype.show = function () &#123; console.log(this.name, this.age) &#125; &#125; let zbb = new User('zbb', 24) zbb.show()//zbb 24for (const key in zbb) &#123; //in方法会遍历到原型。要么hasOwnProperty,要么是class关键字声明的类的对象才可以不去遍历原型 console.log(key)//不仅遍历实例的属性和方法name,age,get还遍历原型的方法show &#125; 2，使用类关键字定义 使用类关键字class定义（但本质上还是函数） 添加方法时可以省略函数关键字function，但也是放到原型里了。 原型方法不可以被遍历到（emumerable默认为false） 123456789101112131415161718192021class User &#123;//class关键字声明 constructor(name, age) &#123;//自动执行的初始化函数 this.name=name this.age=age this.get = function()&#123;//实例方法，每个函数都带一份，会重复占用空间 console.log(\"wow\") &#125; &#125; //类里面往原型加方法还可以省略function关键字，直接写 show() &#123; console.log(this.name,this.age) &#125;//类里面函数之间不用加逗号因为虽然定义的形式看起来像对象但class本质是个函数，不是个对象。 &#125; let Hd = class &#123; &#125;//看起来像对象 console.log(typeof User)//function console.log(typeof Hd)//function let zbb = new User('zbb', 24) zbb.show()//zbb 24for (const key in zbb) &#123;//in方法会遍历到原型 console.log(key)//虽然in到了原型，但只遍历到实例的属性和方法name,age,get。因为原型方法的可遍历性被自动修改了 &#125; 关于静态属性类(函数)作为一个对象时拥有的属性 User.description，User.——proto——.description，static description。三种设置方式 12345678910111213141516171819202122class User &#123;//class关键字声明 constructor(name, age) &#123;//自动执行的初始化函数，设置实例的属性与方法 this.name=name;this.age=age this.get = function()&#123; console.log(\"wow\") &#125; &#125; //原型方法 show() &#123; console.log(this.name,this.age) &#125; //静态属性，类作为对象时自身的属性与方法,可以给所有对象使用，但是设置只能通过类User自身来设置与读取。 //只保存一份，在类User当中 static decription = \"静态属性\"//当然，也可以这样设置。User.description=\"静态属性\"， //或者，User.__proto__.description=\"静态属性\"。三种方法 &#125; let zbb = new User('zbb',24) console.log(zbb)//User &#123;name: \"zbb\", age: 24, get: ƒ&#125;,没有description console.dir(User)//可以看到静态属性 console.log(User.decription)//静态属性；通过User自身来读取 静态属性批量处理对象直接使用new的话一次只能产生一个对象，可以使用静态方法，在类的内部自动帮我们批量产生对象。 1234567891011121314151617181920 const data = [ &#123; name: \"js\", price: 100 &#125;, &#123; name: \"mysql\", price: 212 &#125;, &#123; name: \"vue.js\", price: 98 &#125; ] class Lesson &#123; constructor(data) &#123; this.model = data &#125;//静态方法 static creatLessons(data) &#123; return data.map((item) =&gt; &#123; return new Lesson(item) &#125;) &#125; &#125; //obj1=new Lesson(data[0]),重复三次 let lessons = Lesson.creatLessons(data)//静态方法调用通过类自身调用，传入一次就行 console.log(lessons)//[Lesson, Lesson, Lesson]","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"静态属性","slug":"静态属性","permalink":"https://zhoubb96.github.io/tags/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7/"}]},{"title":"数据结构与算法-字典","date":"2020-06-23T11:19:00.000Z","path":"2020/06/23/数据结构与算法-字典/","text":"字典用Object类来封装一个字典。ES6已经提供原生字典类Map。 字典和集合很相似，只是集合用的是【值，值】储存方式，而字典Map依然使用【键，值】的储存方式。此外，集合是值不能重复；字典是只要求键不能重复，对值没有要求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function Dictionary()&#123; this.items=&#123;&#125; //1,set方法添加键值对 Dictionary.prototype.set=function(key,value)&#123; this.items[key]=value &#125; //2，has方法判断某个键是否存在 Dictionary.prototype.has=function(key)&#123; return this.items.hasOwnProperty(key) &#125; //3，remove方法移除 Dictionary.prototype.remove=function(key)&#123; if(this.has(key)==false)&#123; return flase &#125; delete this.items[key]//对象删除属性用关键字delete &#125; //4，get获取方法，通过key返回value Dictionary.prototype.get=function(key)&#123; return this.items[key] &#125; //5，values方法获取所有value Dictionary.prototype.values=function()&#123; return Object.values(this.items)//一个数组 &#125; //6，keys方法获取所有的key Dictionary.prototype.keys=function()&#123; return Object.keys(this.items)//一个数组 &#125; //7，size方法获取对象键值对的数量 Dictionary.prototype.size=function()&#123; return this.keys().length//return this.values().length,利用键的数量或者值的数量 &#125; //8，clear方法清空数组。 Dictionary.prototype.clear=function()&#123; this.items=&#123;&#125;//空对象覆盖 &#125;&#125;//测试 var dict = new Dictionary() // 在字典中添加元素 dict.set(\"age\", 18) dict.set(\"name\", \"zbb\") dict.set(\"height\", 1.88) dict.set(\"address\", \"广州市\") // 获取字典的信息 alert(dict.keys()) // age,name,height,address alert(dict.values()) // 18,zbb,1.88,广州市 alert(dict.size()) // 4 alert(dict.get(\"name\")) // zbb // 字典的删除方法 dict.remove(\"height\") alert(dict.keys())// age,name,address // 清空字典 dict.clear() console.log(dict)//&#123;&#125;","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-图","date":"2020-06-23T09:12:49.000Z","path":"2020/06/23/数据结构与算法-图/","text":"图结构数学上，树其实是图的一种。关键概念是Vertex顶点与Edge边。 概念： Vertex：图中的一个节点 Edge：顶点之间的连线，可以是有向的也可以是无向边。 相邻顶点：由一条边连接在一起的两个顶点 度：一个顶点相邻顶点的数量 路径：从一个顶点到另一个顶点的经过的顶点序列。如果没有重复的顶点，那就是简单路径。 回路：首尾相同。 有向图：边为有向边的图 有权图：边有权值的图 图结构的特点 有一组顶点：用V表示顶点的集合 有一组边：用E表示边的集合 图的表示顶点容易表示（数组，set都可以），关键是边的表示。 1，邻接矩阵(二维数组)来表示边 如果是对称矩阵那就是无向图，如果不是对称矩阵，那便是有向图。 稀疏图空间利用率不高。 2，邻接链表来表示边 图用顶点和其相邻的顶点列表组成（AB，AC，AD） 这个列表可以用数组、链表、哈希表等方式表示 邻接表计算出度是很简单的，如果要计算入度那么需要再构造一个逆邻接表。 图的遍历使用三种颜色记录状态 白色：该顶点还没被访问。访问，头节点入队，初始节点的的邻接节点是下一次访问的头节点。 灰色：被访问过，但是未被探索过。探索，邻接节点是否入队。没入，灰色。 黑色：被访问且被完全探索过。已入，黑色。 其实两个颜色就够了。在判断是否入队的时刻。 ​ 是不是白色，就完事了。 广度优先搜索（BFS，Breadth-First Search） 基于队列，入队列的顶点先被探索，层序遍历遍历。 深度优先搜索（DFS，Depth-First Search） 基于栈，基于栈或者递归(递归就是函数栈)，沿着路径探索的，存在新的顶点就去访问。类似于先序遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;script src=\"dict.js\"&gt;//自定义字典&lt;/script&gt; &lt;script src=\"queue.js\"&gt;//自定义队列&lt;/script&gt; &lt;script&gt; function Graph() &#123; //属性 this.vertexes = []//顶点集合 this.edges = new Dictionary()//边集合 //方法 //1，添加顶点 Graph.prototype.addVertex = function (v) &#123; this.vertexes.push(v) this.edges.set(v, []) &#125; //2，添加边,无向图 Graph.prototype.addEdge = function (v1, v2) &#123; this.edges.get(v1).push(v2) this.edges.get(v2).push(v1) &#125; //3，输出 Graph.prototype.toString = function () &#123; let resultString = \"\" for (let i = 0; i &lt; this.vertexes.length; i++) &#123; resultString += this.vertexes[i] + '-&gt;' let egdes = this.edges.get(this.vertexes[i]) for (let j = 0; j &lt; egdes.length; j++) &#123; resultString += egdes[j] + ' '//空格隔开 &#125; resultString += '\\n'//换行符号‘\\n’ &#125; return resultString &#125; //4,颜色初始化 Graph.prototype.initializeColor = function () &#123; let colors = [] for (let i = 0; i &lt; this.vertexes.length; i++) &#123; colors[this.vertexes[i]] = \"white\"//数组的键可以是字符，会把字符转换为数字！！ //color是一个稀疏数组。有点哈希表的意思。默认编码 &#125; return colors &#125; //5，广度优先遍历 Graph.prototype.bfs = function (initV, handler) &#123;//初始化顶点，处理函数 //1，初始化颜色列表 let colors = this.initializeColor() //2，新建队列 let queue = new Queue() //3，压入初始化顶点 queue.enqueue(initV) //4，循环取队列元素 while (!queue.isEmpty()) &#123;//队列不为空就进队列，队列为空表示遍历结束 //4.1取出一个顶点v let v = queue.dequeue()//不断的出队列，并获取出队类的元素，在下面根据它继续入队列 //4.2获取v的相邻顶点表（边邻接表） let Vlist = this.edges.get(v) //4.3取出后，v被访问，修改颜色为灰 colors[v] = \"gray\" //4.4将相邻顶点压入队列 //console.log(Vlist.length) for (let i = 0; i &lt; Vlist.length; i++) &#123; let e = Vlist[i] if (colors[e] == \"white\") &#123; colors[e] = \"gray\" queue.enqueue(e) &#125; &#125; //处理v handler(v) //v已被探测，即其邻接节点也全部入队，修改v颜色为黑。只改初始节点。 colors[v] = \"black\" &#125; &#125; //6，深度优先遍历 Graph.prototype.dfs = function (initV, handler) &#123; //1,初始化颜色列表 let colors = this.initializeColor() //2，定义递归函数 // function dfsVisite(v, colors, handler) &#123; // //1,设置为灰 // colors[v] = \"gray\" // //2,处理 // handler(v) // //3,获取v的邻接表，并循环调用递归 // console.log(v) // console.log(this)//Window // let Vlist = this.edges.get(v)//因为这是普通函数，所以在这里是weidow，所以一般工具函数也要设置在原型 // //然后将工具方法以对象的形式调用，不然如果出现要访问，对象属性的时候，内部调用，this容易出问题。 // console.log(Vlist) // for (let i = 0; i &lt; Vlist.length; i++) &#123; // let e = Vlist[i] // if (colors[e] == \"white\") &#123; // this.dfsVisite(e, colors, handler) // &#125; // &#125; // //4,设置为黑色 // colors[v] = \"black\" // &#125; //根据第一个节点初始化调用 this.dfsVisite(initV, colors, handler)//凡是内部看到this思考是谁调用。 &#125; Graph.prototype.dfsVisite = function (v, colors, handler) &#123;//定义成原型 //1,设置为灰 colors[v] = \"gray\" //2,处理 handler(v) //3,获取v的邻接表，并循环调用递归 let Vlist = this.edges.get(v) for (let i = 0; i &lt; Vlist.length; i++) &#123; let e = Vlist[i] if (colors[e] == \"white\") &#123;//但是在所有颜色都被标记完之后，没有能访问的时候，还是会自动返回。 this.dfsVisite(e, colors, handler)//虽然没有主动定义返回条件 &#125;//递归加循环。 &#125; //4,设置为黑色 colors[v] = \"black\" &#125; &#125; let g = new Graph() let vertexes1 = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"] //添加顶点 for (let i = 0; i &lt; vertexes1.length; i++) &#123; g.addVertex(vertexes1[i]) &#125; //添加边 g.addEdge('A', 'B'); g.addEdge('A', 'C'); g.addEdge('A', 'D'); g.addEdge('C', 'D'); g.addEdge('C', 'G'); g.addEdge('D', 'G'); g.addEdge('D', 'H'); g.addEdge('B', 'E'); g.addEdge('B', 'F'); g.addEdge('E', 'I'); console.log(g.toString()) //测试bfs var result = '' g.bfs(g.vertexes[0], function (v) &#123; result += v + ' ' &#125;) console.log(result)//A B C D E F G H I ,层次遍历。 var result1 = '' g.dfs(g.vertexes[0], function (v) &#123; result1 += v + ' ' &#125;) console.log(result1)//A B E I F C D G H &lt;/script&gt;","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS的多继承问题","date":"2020-06-22T12:24:38.000Z","path":"2020/06/22/JS的多继承问题/","text":"多继承问题因为原型链的出入度为1，不能指向多个原型，所以原型链是不支持多继承的。要获得多继承同样的效果只能靠延长原型链的长度。但是这样可能会把本来没有关系大两个原型加上关系，有的时候就需要避免这个问题。 1，使用延长原型链实现多继承的效果但是在继承的时候还要特别注意继承语句的位置，防止顶掉了之前设置的方法。 1234567891011121314151617181920212223242526272829303132function extend(sub, sup) &#123; sub.prototype = Object.create(sup.prototype); Object.defineProperty(sub.prototype, \"constructor\", &#123; value: sub, enumerable: false &#125;);&#125;function Credit()&#123;&#125;extend(Request,Credit)//继承一定要在给原型加方法之前Credit.prototype.total=function()&#123; console.log(\"积分\")&#125;function Request()&#123;&#125;Request.prototype.ajax=function()&#123; console.log(\"请求\")&#125;;function User(name,age)&#123; this.name=name this.age=age&#125;;extend(User,Request)//这句继承语句一定要放在加这个show方法前面，不然后面的就用不了show方法，因为如果继承语句在这个后面，那么User的prototype会被Request的顶掉，导致设置失效。所以设置原型链切记，先设置好继承关系，再往原型上加方法，以防止原型被顶替导致，设置失效。User.prototype.show=function()&#123; console.log(this.name,this.age)&#125;;function Admin(name,age)&#123; User.call(this,name,age)&#125;;extend(Admin,User)let zbb=new Admin(\"zbb\",24)zbb.show()//zbb 24zbb.ajax()//请求zbb.total()//积分 2，使用mixin实现多继承的效果混合功能。将对象压入原型，没有设置原型链，只是把对象添加到原型；一次性压入多个包含方法的对象到原型，达到多继承的效果；Admin.prototype=Object.assign(Admin.prototype,Credit,Address)。assign方法！ 123456789101112131415161718192021222324252627282930const Credit = &#123; total() &#123; console.log(\"积分\") &#125;&#125;const Address = &#123; getAddress() &#123; console.log(\"地址\") &#125;&#125;function User(name, age) &#123; this.name = name this.age = age&#125;;User.prototype.show = function () &#123; console.log(this.name, this.age)&#125;;function Admin(name, age) &#123; User.call(this, name, age)&#125;;//Admin.prototype.total=Credit.total//Admin.prototype.getAddress=Address.getAddress//像上面一个一个压入，太麻烦了Admin.prototype=Object.assign(Admin.prototype,Credit,Address)//直接把整个对象压入！！！！！！！！！！let zbb = new Admin(\"zbb\", 24)console.log(zbb.name,zbb.age)//zbb 24zbb.total()//积分zbb.getAddress()//地址 mixin内部继承的Super关键字。原型（是压入对象的原型），而不是被压入的那个原型。是Credit或者Address的原型，而不是Admin的原型。 1234567891011121314151617181920212223242526272829303132const Credit = &#123; total() &#123; return \"积分\" &#125;&#125;const Address = &#123; __proto__: Credit,//内部继承 getAddress() &#123; console.log(super.total()+ \"地址\")//super！=this.__proto__ //视频里能成功是因为它还是把Credit压入了原型，但是如果还是压入Credit的话，没必要搞内部继承了。 //在只压入Address的情况下，这里只能写super &#125;&#125;function User(name, age) &#123; this.name = name this.age = age&#125;;User.prototype.show = function () &#123; console.log(this.name, this.age)&#125;;function Admin(name, age) &#123; User.call(this, name, age)&#125;;//Admin.prototype.total=Credit.total//Admin.prototype.getAddress=Address.getAddress//像上面一个一个压入，太麻烦了Admin.prototype=Object.assign(Admin.prototype,Address)//只传入了Addresslet zbb = new Admin(\"zbb\", 24)console.log(zbb.name,zbb.age)//zbb 24zbb.getAddress()//积分地址，但是依然获取到了积分。这就是super的作用 应用：选项卡类的效果改变。 定义一个组件类，再定义一个效果类。选项卡类继承效果类的效果设置方法，使用call传递参数，就可以实现一个选项卡管理类。参数定制问题，可使用对象传参，取参数时用对象的键值对取。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"mixin","slug":"mixin","permalink":"https://zhoubb96.github.io/tags/mixin/"}]},{"title":"数据结构与算法-二叉平衡树之红黑树","date":"2020-06-22T09:03:09.000Z","path":"2020/06/22/数据结构与算法-二叉平衡树之红黑树/","text":"如何解决二叉搜索树高度不稳定的问题？比较好的二叉树应该是左右分布均匀。二叉搜索树插入有序数据后，分布是不均匀的，这种树称为非平衡树。对于一颗非平衡树而言（等于是一个链表），查找等效率为o(N)；而对于一棵平衡树而言，查找等效率可以提高到o(logN)。 常见的平衡树：1，AVL树是最早的一种平衡树，有一个额外数据来保持平衡。 2，红黑树是AVL树后面的一种平衡树，整体效ho率高于AVL树高。 红黑树一，规则： 1，节点是红色或者黑色，红色节点必定有数据，黑色节点不一定有数据。 2，根节点是黑色的。 3，每个叶子节点都是黑色的空节点，也就是说叶子节点不存放数据。 4，每个红色节点的父节点与子节点只能是黑色的。（从叶节点到根节点不可能出现两个连续的红节点） 5，从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 这五个规则的约束，可以保证红黑树的关键特性 关键特性：从根节点到叶子的最长可能路径不会超过最短可能路径的两倍，这就使得这个树基本是平衡的，虽然不是绝对平衡，但是在连续插入时依然是高效的。 原因： 规则4决定路径上没有两个相连的红色节点。最短的可能路径都是黑色的，最长的可能路径是红色黑色交替的。（红小于等于黑） 规则5指出路径的黑色节点数相同，所以没有多余路径可以比其他路径长两倍（因为红黑节点是交替出现的，所以红节点数量永远小于等于黑色节点数量），所以红+黑&lt;2*黑 二，平衡方法插入一个新节点时，会使得树不在平衡；需要通过一定方式进行变换来使得其保持平衡。有变色、左旋转、右旋转这三种方法。 1，变色 一般插入的节点颜色默认为红，以减少可能的操作。因为插入红色节点不会影响规则5，如果默认是黑色，那么插入路径上的黑色节点数量发生改变，那么规则5必会受影响。当然，插入任何颜色，都可能需要调整，但是插入红色的话，可以减少调整的可能。 2，左旋转 逆时针旋转红黑树的两个节点，父节点被右孩子取代，原父节点成为原右孩子的左孩子。如下图，Y取代了X的位置，X成了Y的左子节点。b向左平移，子树不会受影响。 3，右旋转 顺时针旋转红黑树的两个节点，父节点被左孩子取代，原父节点成为原左孩子的右孩子。如图所示，Y取代了X的位置，X成了Y的右孩子。c向右平移，子树不会受影响。 三，问题：上面三种方法在什么时候使用呢？先讨论插入的情况。 要插入节点为N(红)，其父节点为P，父节点的兄弟节点为U，其祖父节点为G。 情况一：没有父节点P，新插入节点N(红)位于树的根节点，没有父节点；这种情况直接插入，再将节点颜色变为黑色，因为根节点必须为黑色。 情况二：有父节点P，且父节点P是黑色节点，不考虑叔叔节点U；直接插入，然后给其加两个黑的空子节点。 情况三：有父节点P，但父节点P是红色，同时叔叔节点U也是红色节点；将P父节点和叔叔U节点以及祖父G都换色，除N以外，（PGU三个都换色）。（PU同红） 可能出现的问题：如果原祖父节点的父节点也是红色呢？换色后又出现红红相连的问题。那就需要递归的调整颜色，但是如果递归到了根节点，那就需要进行旋转了。 情况四：有父节点P，但父节点P是红色，而且叔叔节点U节点是黑色，同时新插入节点N是父节点P的左孩子；父节点P变黑节点，祖父节点G变红（PG两个变色），以祖父节点G为根进行右旋转。 情况五：有父节点P，但父节点P是红色，而且叔叔节点U节点是黑色，但是新插入节点N是父节P点的右孩子；先以父节点P为根进行左旋转，转化为情况四，接下来按照情况四处理。也就是自己N变为黑色，祖父节点G变为红色，以祖父结点G为根进行右旋转。 五种情况的逻辑顺序是。1，先看父节点存不存在（插入节点是不是根节点），不存在进入情况一；2，如果父节点存在，父节点是不是黑色，如果父节点是黑色，进入情况二；3，如果父节点是红色，看叔叔节点是不是红色，如果叔叔节点也是红色，进入情况三；4，如果叔叔节点不是红色，看插入节点是其父节点的左孩子还是右孩子，是左孩子进入情况四，是右孩子进入情况五。 判断父节点的存在性——判断父节点的颜色——判断叔叔节点的颜色——判断插入节点在左还是右。一，二，三，四五。 1class RedBlackTree extends BinaryS","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"红黑树","slug":"红黑树","permalink":"https://zhoubb96.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"}]},{"title":"JS的几种继承方式","date":"2020-06-21T06:39:42.000Z","path":"2020/06/21/JS的几种继承方式/","text":"几乎不直接设置类与类之间的关系，类与类之间通过实例来间接联系。1，原型链继承Son.prototype=new Parent()将父类的一个实例作为子类的原型;本质是重写原型对象（不使用子类的默认原型，而是将父类的一个实例作为子类的原型），原来父类中的所有属性和方法也存在于子类当中，给子类子类添加方法就是在父类方法的基础上又添加一个方法。很明显，Javascript的原型是没有多继承的！只能指一个！！只能通过延长原型链的方法获取等同于多继承的效果。 son——Son——(父类实例初始化调用1次)parent——Parent Son.prototype=new Parent() 特点：覆盖原型链 1，实例即是子类的实例又是父类的实例，因为将子类的原型指向了父类实例，通过父类实例联系上了父类原型，所以父类和子类都在实例对象的原型链上。 2，这个时候子类的constructor指针指向的是父类，因为子类的原型被重写覆盖指向了父类的实例，通过父类实例又指向了父类原型。（如果要改回来得自己写一条defineProperty语句） 3，无法多继承，原型链的出入度只为1. 4，设置了子类实例到子类的原型关系，又因为子类的原型指向了父类的实例，所以子类实例可以通过父类的实例联系到父类的原型。所以子类原型和父类原型都在子类实例的原型链上，原型链检测都为true。 12345678910111213141516171819202122function Parent() &#123; this.parentname = \"parent\" &#125;//parent的属性 Parent.prototype.getParent = function () &#123;//parent的方法 return this.parentname &#125; //子类 function Son() &#123; this.sonname = \"son\" &#125;//son的属性 Son.prototype.getSon = function () &#123;//son的方法 return this.sonname &#125; Son.prototype = new Parent()//让父类的一个实例成为子类的原型，Son继承了Parent let son = new Son() console.log(son.getParent())//parent，这一点说明son可以调用parent的方法 console.log(son instanceof Son)//true,Parent在son的原型链上 console.log(son instanceof Parent)//true，Son在son的原型链上//抽离一个继承函数实现原型链继承function extend(son,parent)&#123; //son.prototype=new parent() son.prototype=Object.create(parent.prototype)//设置原型链,和上面那句是等效的 Object.defineProperty(son.prototype,\"constructor\",&#123;value: son,enmurable: false&#125;)//改回constructor //Objec.defineProperty(对象，属性，设置)&#125; 2，借用构造函数Parent.call(this,arg1.arg2)借用父类的构造函数来设置子类实例的属性，使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数；只能继承父类的属性和方法，不能继承父类的原型。 son——Son(借用，子类实例初始化调用1次)Parent（1次） Parent.call(this,arg1.arg2)或者Parent.apply(this,[arrs]) 特点：借用构造函数 1，由于只调用了构造函数，只能继承父类实例的属性和方法（构造函数内部的属性与方法），不能继承父类的原型属性与方法 2，实例是自己的实例，因为子类的原型没有与父类原型设置上联系，所以，父类不在原型链上，istanceof为假。 12345678910111213141516function Parent(name,age)&#123;//父类 this.name=name this.age=age&#125;function Son(name,age)&#123;//子类 Parent.call(this,name,age)//借用父类构造函数，this把当前对象传过去，绑定正确的对象，不然 //构造函数默认是自己，不传的话，默认是parent的name与age&#125;Son.prototype.show=function()&#123;//子类自身方法 console.log(this.name,this.age)&#125;let son=new Son(\"zbb\",24)//可以看出借用父类构造函数设置属性成功son.show()//zbb 24console.log(son instanceof Son)//trueconsole.log(son instanceof Parent)//false 3，组合继承（1+2）是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。第一步，借用父类构造函数设置属性，实现实例属性与方法的复用；第二步，将父类实例作为子类原型，实现原型属性与方法的复用。因为用到了原型链继承，所以也都在原型链上。 son——Son(借用，子类实例初始化1次)Parent son——Son——(父类实例初始化一调用1次)parent——Parent 1，Parent.call(this,arg1.arg2)或者Parent.apply(this,[arrs]) 2，Son.prototype=new Parent() 特点：原型链+借用构造函数 1，会调用两次超类型构造函数，一次在创建子类型原型(初始化父类实例)的时候，另一次是在子类型构造函数内部（初始化子类实例）。 12345678910111213141516171819202122function Parent(name,age)&#123;//父类 this.name=name this.age=age&#125;Parent.prototype.showP=function()&#123; console.log(\"这是父类的原型方法\")&#125;function Son(name,age)&#123;//子类 Parent.call(this,name,age)//借用父类构造函数，this把当前对象传过去，绑定正确的对象，不然 //构造函数默认是自己，不传的话，默认是parent的name与age&#125;Son.prototype=new Parent()//注意先设置原型，再修改方法，不然直接覆盖，白写了Son.prototype.show=function()&#123; console.log(this.name,this.age)&#125;let son=new Son(\"zbb\",24)//可以看出借用父类构造函数设置属性成功son.show()//zbb 24son.showP()//这是父类的原型方法console.log(son instanceof Parent)//trueconsole.log(son instanceof Son)//true 4，实例继承（原型式继承）核心是为父类添加新特性，作为子类返回，实例是父类的实例，不是子类的实例。！！！也不是工具人类？原因是instanceof只看原型链。因为没有设置实例到子类的关系，实例是在函数里被Mid函数new出来的，而Mid的原型又设置到了父类上，所以只有父类在实例的原型链上。不看类名，而Object能判断类型却又无法区分Object和其他类名？在Class里会有改善么？new它的那个人没有姓名。 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一 个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 son——（寄生实例， 只是复制不调用）——parent——Parent 复制不会调用构造函数。 特点：复制一个对象，用函数来包装和添加新属性。 1，实例是父类的实例，可以不用自己创建构造函数 2，继承原父类对象的属性，并且可以添加属性。 1234567891011121314151617181920function Parent(name, age) &#123;//父类 this.name = name this.age = age &#125; function Son(parent,college) &#123; function Mid(college) &#123;//为父类增加学校属性 this.college = college &#125; Mid.prototype = parent//覆盖掉了Mid的原型，所以是parent的实例而不是Mid的。 return new Mid(college)//但是instanceof是检测不出来的 &#125; let parent = new Parent(\"zbb\", 24,)//父类对象 let son = Son(parent,\"Hust\")//传入父类对象以及要增加的属性 console.log(son)//Mid &#123;college: \"Hust\"&#125;，显示是Mid类型的 console.log(son instanceof Parent)//true console.log(son instanceof Son)//false console.log(son.name,son.age,son.college)//zbb,24,Hust;继承下了parent的属性,也有后来添加的属性 console.log(parent)//Parent &#123;name: \"zbb\", age: 24&#125; console.log(parent.college)//undefined,说明是parent是没有college属性的。没有同步给son的变化，深拷贝 console.log(son instanceof Mid)//Mid is not defined报错//工具人不配有姓名？？？ 5，寄生式继承和原型式继承差不多区别不大，同样也只是父类的实例，只设置了实例到父类的原型关系，没有设置实例到子类的原型关系也没有设置实例到中间类的原型关系。在主要考虑对象而不是自定义类型和构造函数的情况 son——((寄生实例， 只是复制不调用)壳子)——parent——Parent 特点： 1，实例依然是父类的实例 2，多了个壳子，可以在壳子里加函数。使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一 点与构造函数模式类似。 123456789101112131415161718192021222324function Parent(name, age) &#123;//父类 this.name = name this.age = age&#125;function Son(parent, college) &#123; function Mid(college) &#123;//为父类增加学校属性 this.college = college &#125; Mid.prototype = parent//设置到了parent return new Mid(college)&#125;//上面是原型式继承，再加一个壳子function Realson(parent) &#123; let realson = Son(parent, \"Hust\") realson.type = \"real?\" return realson&#125;let parent = new Parent(\"zbb\", 24)let realson = Realson(parent)console.log(parent)//Parent &#123;age: 24 name: \"zbb\"&#125;console.log(realson)//Mid &#123;college: \"Hust\" type: \"real?\"&#125;以及proto里面包着的parent属性console.log(realson instanceof Parent)//trueconsole.log(realson instanceof Realson)//false，在全局，可读，有定义，但是没在原型链上。console.log(realson instanceof Mid)//报错，真不配有姓名。即是未定义，又没在原型链。 6，寄生组合继承（在组合继承的中间加入了寄生）let mid=Mid(Parent.prototype)；Son.prototype=mid寄生继承加组合继承。寄生+（原型链+借用构造函数）。寄生是什么？（寄生就是在普通函数内返回一个对象）。寄生实例充当中间商 流程：son实例直接由Son类生成，但是Son的原型改成了寄生类实例，所以son实例原型指向了寄生类实例，而寄生类实例又指向了父类的实例原型，所以son实例也联系到了父类原型。所以Son原型和Parent原型都在son实例的原型链上。而寄生是在函数内部生成并返回对象，所以寄生自身原型和工具自身原型不在son实例的原型链上。 1，let mid=Mid(Parent.prototype)，寄生实例到父类 2，mid.constructor=Parent，修复 3，Son.prototype=mid，子类到寄生实例 上面这两句话解决了寄生方式的只是实例只是父类实例(也就是解决了只有父类在实例的原型链的问题)的问题 利用寄生方式砍掉父类的实例属性，解决了组合方式调用两次父类构造函数的问题。 son——Son（借用，初始化调用1次）Parent——（寄生，只是复制不调用）——parent——Parent 在原组合继承的中间，增加了寄生 特点： 1，即是子类的实例，又是父类的实例 2，只调用了一次超类型的构造函数。 1234567891011121314151617181920212223 function Parent(name, age) &#123;//父类 this.name = name this.age = age &#125; function Mid(obj)&#123;//寄生 function F()&#123;&#125; F.prototype=obj return new F() &#125; function Son(name,age)&#123; Parent.call(this,name,age) &#125; let mid=Mid(Parent.prototype)//寄生实例的原型继承父类实例原型 mid.constructor=Parent//修复实例构造函数，不然会丢失。 Son.prototype=mid//设置子类实例到寄生实例的原型关系 let son=new Son(\"zbb\",24) console.log(son)//Son &#123;name: \"zbb\", age: 24&#125; console.log(son instanceof Parent)//true,Parent在son的原型链上 console.log(son instanceof Son)//true，Son在son的原型上console.log(son instanceof Mid)//false console.log(son instanceof F)//报错","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS继承与多态","date":"2020-06-21T01:15:07.000Z","path":"2020/06/21/JS继承与多态/","text":"JS的继承是原型的继承函数有两个原型身份，两个身份看你以什么角度看。（其身份的双重性，prototype是作为构造函数自带的，里面有一个construct指回构造函数；——proto——是其作为对象在继承时使用的身份。） 1234function User(name)&#123; this.name=name&#125;function Admin()&#123;&#125;//继承,原型的继承。//Admin.prototype=User,不叫继承，这是直接改变了原型的指向。也就是要保留原来的原型Admin.prototype.__proto__=User 继承对实例的影响构造函数设置实例的原型链是一次性的，如果在实例创建之后再改变原构造函数的继承关系，实例的原型链不会自动变化，依然是之前的原型链；所以一般在确定了构造函数的继承关系之后再创建实例。 继承对construct指针的影响construct指向构造函数，可以借用，也可以自己设置，通过原型链寻找。原型链的设置是构造函数设置的。 JS多态实例 123456789101112131415161718192021222324252627function User() &#123; &#125;User.prototype.show = function () &#123; console.log(this.description());&#125;;function Admin() &#123; &#125;Admin.prototype = Object.create(User.prototype);//继承UserAdmin.prototype.description = function () &#123; return \"管理员\";&#125;;function Member() &#123; &#125;Member.prototype = Object.create(User.prototype);//继承UserMember.prototype.description = function () &#123; return \"会员\";&#125;;function Enterprise() &#123; &#125;Enterprise.prototype = Object.create(User.prototype);//继承UserEnterprise.prototype.description = function () &#123; return \"企业帐户\";&#125;;for (const value of [new Admin(), new Member(), new Enterprise()]) &#123; value.show()//管理员，会员，企业账户&#125; 根据调用对象的不同，this指向不同的方法，通过this指针实现多态。简化调用时的判断，（判断在设计时写好了）","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS原型","date":"2020-06-19T08:43:29.000Z","path":"2020/06/19/JS原型/","text":"原型对象一开始Js的继承是通过原型实现的。一般原型链是自动设置的。 123let obj1 = &#123;&#125; let obj2 = &#123;&#125; console.log(Object.getPrototypeOf(obj1) == Object.getPrototypeOf(obj2))//true 手动设置原型：Object.create(parent,obj)，创建出来的obj，第一个参数是其原型。如果设置为null，那么obj就没有原型。这个没父亲（原型的对象）称之为完全的数据字典对象。【只有数据，没有原型】 原型方法与对象方法的优先级对象方法优先级方法高于原型方法，先在对象里面寻找；再到原型里寻找。 1，函数有多个原型函数也是对象，作为对象时有一个隐式原型——proto——；作为函数时有一个显示原型prototype。对象的原型叫隐式原型，函数的原型叫显示原型。取决于你将其当作当作什么类型使用。函数有两个原型，显式与隐式都有；普通对象只有一个原型，只有隐式。函数的显示原型，是在函数构造实例的时候使用的。 123let arr=new Array()console.log(arr.__proto__==Array.prototype)//trueconsole.log(arr.__proto__.__pproto__==Object.prototype)//true,一般找两层就到头了。 2，设置对象的原型 Object.create(parent,son)，上面已经提到了 Object.setPrototypeOf(son,parent)， 1234let obj1=&#123;name: \"parent\"&#125;let obj2=&#123;name: \"son\"&#125;Object.setPrototypeOf(obj2,obj1)console.log(obj2)//可以看出obj1已经式obj2的原型了。 3，显式原型中的constructor引用显式prototype可以服务很多对象，隐式——proto——只服务自己。所以一般操作显示原型，但是如果只想改自己的方法，不往其他原型上加，那就使用隐式原型（ES6才支持直接操作隐式对象）。注意直接改变原型指向与给原型追加方法的区别。因为直接改变原型的指向会导致constructor引用指向的丢失。 12345function User(name)&#123;this.name=name&#125;//函数console.log(User.prototype.__proto__==Object.prototype)//trueconsole.log(User.prototype.constructor==User)//truelet zbb=new User.prototype.constructor(\"zbb\")console.log(zbb)//User &#123;name: \"zbb\"&#125; 原型链 读取对象的属性值时: 先在自身属性中查找，找到返回；如果没找到，会自动到原型链中查找，最终没找到会返回undefined 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性。 方法一般定义在原型中, 属性一般通过构造函数定义在对象自己身上 总结：读取会查找原型链，设置不会查找原型链 原型链检测1，instanceof注意是原型链检测，严格来说不算实例检测，也不是类型检测，就只是原型链检测，new它的那个人不一定值得拥有姓名，比如寄生式继承。instanceof是递归的 1234567891011121314function A()&#123;&#125;function B()&#123;&#125;let a=new A()let b=new B()A.prototype=bconsole.log(a instanceof A)//trueconsole.log(a instanceof B)//trueconsole.log(a instanceof Object)//true//自定义原型链检查方法function checkPrototype(obj,constructor)&#123; if(!obj.__proto__) return false//原型不存在 if(obj.__proto__==constructor.prototype) return true return checkPrototype(obj.__proto__,constructor)//递归调用，因为有返回值，所以前面也要有个return&#125; 2，obj.isPrototypeOf()123let a=&#123;&#125;let b=&#123;&#125;console.log(b.__proto__.isPrototypeOf(a))//true 3，使用call与apply借用原型链自身原型链上没有这个功能，但是另外一个原型链有。 123456789101112131415161718let a = &#123; data: [1, 2, 17, 3, 4, 5]&#125;//方法一，设置原型链Object.setPrototypeOf(a, &#123; max() &#123; return this.data.sort((a, b) =&gt; b - a)[0] &#125;&#125;)//借用原型链let zbb = &#123; lessons: &#123; js: 90, nodejs: 91, css: 87, c: 92 &#125;, get data() &#123; return Object.values(this.lessons)//数组 &#125;//用这个伪造zbb.data这个属性，以便于调用max函数&#125;console.log(a.max())//17console.log(a.max.apply(zbb))//92 例子：DOM节点调用Array原型方法 1234567891011121314&lt;body&gt; &lt;input type=\"text\" class=\"red\" validate rule=\"max:12,min:3\" /&gt; &lt;input type=\"text\" content=\"ko\" validate rule=\"max:3,isNumber\" /&gt;&lt;/body&gt;&lt;script&gt; let arr=[9,5,2,7] console.log(arr.filter((value)=&gt;value&gt;5))//[9,7] let btns=document.querySelectorAll('input') let btn=Array.prototype.filter.call(btns,item=&gt;&#123; console.log(item)//&lt;input type=\"text\" class=\"red\" validate rule=\"max:12,min:3\" /&gt;... return item.hasAttribute('class') &#125;) console.log(btn)//[input.red]&lt;/script&gt; 不管原型怎么变，方法中的this始终指向调用方法对象。 不要滥用原型链 原型链顶层：Object.prototype Object.prototype.hide=function(){};那么这个函数所有对象都能用到。 如果滥用的话，可能会造成函数冲突，使代码变得不稳定。所以不要在系统的原型中也就是最顶层添加方法。 prototype定义构造函数的原型。 ——proto——为单个对象更改原型。其实这不是一个严格意义的属性，是一个访问控制器setter，getter，仅在对象的时候才设置成功，所以必然进行了控制。 123456789let hd=&#123;prototype:&#123;&#125;, get __proto__()&#123; return this.prototype &#125;, set __proto__(obj)&#123; if(obj istanceof Object)&#123; this.prototype=obj &#125; &#125;&#125;//这就是原理。 如果想设置非对象类型的原型，那么只能先将其原型链断开（先让其原型为null），再进行设置。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JSON数据","date":"2020-06-19T07:39:00.000Z","path":"2020/06/19/JSON数据/","text":"JSON数据解决了什么问题？解决语言之间传递格式化数据的问题。 12345678910let zbb=&#123; name: \"zbb\", age: 24 &#125; let json =JSON.stringify(zbb) console.log(json)//&#123;\"name\":\"zbb\",\"age\":24&#125;，给属性加上引号了 console.log(typeof json)//string let obj=JSON.parse(json) console.log(obj)//&#123;name: \"zbb\", age: 24&#125; console.log(typeof obj)//object JSON化方法，JSON.stringify(obj) 对象化方法，JSON.parse(json) JSON序列化与自定义JSON.stringify()：第一个参数指定对象，第二个参数指定保留内容（null的话就是不做过滤，全部返回），第三个参数指定制表符格式 序列化 1234567891011121314151617let zbb=&#123; name: \"zbb\", age: 24, education: &#123; college: \"HUST\" &#125; &#125; let json = JSON.stringify(zbb) console.log(json)//&#123;\"name\":\"zbb\",\"age\":24&#125; let json2 = JSON.stringify(zbb, [\"education\"])//第二个参数可以指定保留属性 console.log(json2)//&#123;\"education\":&#123;&#125;&#125; let json3 = JSON.stringify(zbb, [\"education\", \"name\"], 2)//第三个参数可以设置制表位，格式化 console.log(json3) // &#123; // \"education\": &#123; &#125;, // \"name\": \"zbb\" // &#125; 自定义 12345678910111213141516let zbb = &#123; name: \"zbb\", age: 24, education: &#123; college: \"HUST\" &#125;, toJSON: function () &#123;//定制接口toJSON //指定返回内容 return &#123; name: this.name, education: this.education &#125; &#125;&#125;let json = JSON.stringify(zbb)//没有设置console.log(json)//得到了在对象中指定返回的内容，&#123;\"name\":\"zbb\",\"education\":&#123;\"college\":\"HUST\"&#125;&#125; JSON转为JS可操作类型JSON.parse(json,callbacks) 123456789101112131415let zbb = &#123; name: \"zbb\", age: 24, education: &#123; college: \"HUST\" &#125;,&#125;let json = JSON.stringify(zbb)let obj = JSON.parse(json,(key,value)=&gt;&#123;//箭头函数多行，指定返回内容 if(key==\"name\")&#123; value=\"姓名:\"+value &#125; return value//要return回去&#125;)console.log(obj)//&#123;name: \"姓名:zbb\", age: 24, education: &#123;…&#125;&#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"JSON","slug":"JSON","permalink":"https://zhoubb96.github.io/tags/JSON/"}]},{"title":"JS对象Proxy代理实现表单验证","date":"2020-06-19T07:22:54.000Z","path":"2020/06/19/JS对象Proxy代理实现表单验证/","text":"加深对Proxy的机制的理解；这里多次对数据格式进行了转换。复合了很多知识。对象方法的封装与使用。every的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;后盾人&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123;padding: 50px; background: #34495e;&#125; input &#123;border: solid 10px #ddd;height: 30px;&#125; .error &#123;border: solid 10px red;&#125;&lt;/style&gt;&lt;body&gt; &lt;input type=\"text\" validate rule=\"max:12,min:3\" /&gt; &lt;input type=\"text\" validate rule=\"max:3,isNumber\" /&gt;&lt;/body&gt;&lt;script&gt; \"use strict\"; //验证类 class Validate &#123; max(target, length) &#123;//字符串长度是否小于指定值 return target.length &lt;= length &#125; min(target, length) &#123;//字符串长度是否大于指定值 return target.length &gt;= length &#125; isNumber(value) &#123;//是否是数字 return /^\\d+$/.test(value) &#125; &#125; //代理工厂 function ProxyFactor(obj)&#123; return new Proxy(obj,&#123;//返回这个代理对象 set(obj,key,el)&#123;//这里obj是proxy，key是编号，el是input元素,input元素的value就是输入值 const rules=el.getAttribute('rule')//rules[max:12,min:3] const validate=new Validate()//通过这个validate调用验证方法 let state=rules.split(',').every((rule)=&gt;&#123;//rule max:12 const info=rule.split(':')//info [max,12] return validate[info[0]](el.value,info[1])//希望max(str,len),每个函数都运行一遍，（every）全成立才成立 &#125;) el.classList[state?'remove':'add']('error')//正确与错误的样式 return true &#125;, get(obj,key)&#123; return obj[key]//先写return，不然下面proxy的foreach无法调用 &#125; &#125;) &#125; //开启代理验证 const proxy=ProxyFactor(document.querySelectorAll('[validate]'))//传入了一个节点数组对象（这个对象有两个input元素）得到一个代理对象 //Proxy &#123;0: input, 1: input&#125; proxy.forEach((item,i)=&gt;&#123;//item就是那个nodelist item.addEventListener('keyup',function()&#123; proxy[i]=this//把input元素给proxy &#125;) &#125;)&lt;/script&gt;&lt;/html&gt;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Proxy代理","slug":"Proxy代理","permalink":"https://zhoubb96.github.io/tags/Proxy%E4%BB%A3%E7%90%86/"},{"name":"访问控制器","slug":"访问控制器","permalink":"https://zhoubb96.github.io/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"数据结构与算法-二叉搜索树","date":"2020-06-19T03:12:37.000Z","path":"2020/06/19/数据结构与算法-二叉搜索树/","text":"树：n（n&gt;=0）个节点构成的有限集合树结构综合了数组，链表和哈希表的一些优点。 优势 1，空间利用率高 2，元素可以是有序的 树的术语 树中有一个称为根Root的特殊节点 节点的度degree：节点子树的个数 节点的层次：规定根节点的层次为1，其他节点的层次为其父节点层次加1 树的度：所有节点的度中的最大值 树的深度：节点的最大层数 父节点：有子树的节点，其是其子树的根节点 子节点：父节点的孩子节点 叶节点：度为0的节点 兄弟节点：同一父节点的各节点互为兄弟节点 树的路径与路径长度：从一个节点到另一个节点的中间节点的序列为路径，所包含的边的个数为路径长度。 二叉树因为所有树本质上都可以用儿子-兄弟表示法以二叉树的形式表示出来，所以学习好二叉树至关重要。二叉树可以模拟所有树 二叉树：每个节点至多只有两个子节点的树就是二叉树。（空，仅有根，只有左子节点，只有右子节点，左右子节点都有。） 第i层，至多只有2^(i-1)个子节点 深度为k的树，至多有2^k-1个子节点，至少k个。 任何非空二叉树，度为0的叶节点个数总比度为2的节点个数多1，n0=n2+1 完全二叉树：除了最后一层，其他各层的节点数都达到最大数，且最后一层从左到右的叶节点连续存在，只缺右侧若干节点 完美二叉树（满二叉树）：除了最下层的叶节点外，每层节点都有两个子节点 1，二叉树的存储方式 使用数组 对于完全二叉树：从上至下，从左往右。 非完全二叉树：要在空的地方补号，浪费存储空间的浪费 使用链表 每个节点封装为一个node对象，里面包含三个属性，分别存储数据，左子节点的引用和右子节点的引用 2，二叉搜索树（二叉排序树，二叉查找树）BST，Binary Search Tree 特性：（左&lt;根&lt;右；运用中序遍历得到升序排列） 非空左子树的键值小于根节点的键值 非空右子树的键值大于根节点的键值 左右子树也是二叉搜索树 3，二叉搜索树的缺陷二叉搜索树可以快速的对数据进行查找删除。 前面我们已经知道了二叉搜索树的效率由其的深度决定。而二叉树搜索树的高度是依赖于你的插入顺序的，如果是（123或132或321或312）的顺序插入那么深度就为3；如果是（213或231）的顺序插入的话深度就是2。所以高度是不稳定的。 查找的效率高，因为在构建的时候就使用了二分查找的思想。构建的时候是按照一定顺序的构建的。查找时所需的最大次数等于树的深度；在元素插入的时候也是根据类似的步骤。(插入，删除，查找都要用到比较和循环)删除操作较为复杂。用递归锻炼一下，最好用循环锻炼一下。 删除方法注意点一，删除操作要定义5个变量。1，删除节点；2，删除节点的父节点；3，删除节点的后继节点；4，删除节点后继节点的父节点；5，删除节点与删除节点父节点的关系变量isLeftchild。 二，5个变量之前的不同关系是什么样的情况1，删除节点的子节点数量分三种大情况，每个大情况分这个节点是不是根节点两个小情况；1）没有子节点（根节点，叶节点）；2）只有一个子节点，左节点或者右节点（是不是根节点）；3)有两个根节点（是不是根节点）。如果删除节点是根节点，那么删除节点的父节点为null。 2，删除节点与后继节点的关系又分两种情况，后继节点是不是删除节点的直接右子节点，如果是，那么后继节点的父节点就是删除节点，而删除节点又要被摘除，那么parent.right=successor就能完成右子树的拼接；如果不是，那么还要额外进行右子树的拼接successor.right=delNode.right。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294function BinarySearchTree() &#123; function Node(data) &#123; this.data = data this.left = null this.right = null &#125; //属性 this.root = null //方法，所有递归几乎都可以转化为while循环。一般而言递归好写一些；比如遍历，利用循环的话还是要自己构造一个栈，递归也是栈。没必要 //1，对外暴露的插入发布方法 BinarySearchTree.prototype.insert = function (data) &#123; //工具方法内部调用,不要省略else，不然有时候逻辑会有漏洞 //递归方法实现插入 // insertNode = function (node, newNode) &#123; // if (newNode.data &lt; node.data) &#123;//左查找 // if (node.left == null) &#123; //1,结束条件，为空 // node.left = newNode//2，函数体 // &#125; else &#123; // this.insertNode(node.left, newNode)//3，递归调用,手动指定左递归 // &#125; // &#125; else &#123;//右查找 // if (node.right == null) &#123;//1,结束条件 // node.right = newNode//2，函数体 // &#125; else &#123; // this.insertNode(node.right, newNode)//3，递归调用,右递归 // &#125; // &#125; // &#125; let newNode = new Node(data) //判断根节点是否为空 if (this.root == null) &#123;//为空 this.root = newNode &#125; else &#123; // //有根节点，与根节点比较 ////insertNode(this.root, newNode)//调用插入递归函数 // //循环方法实现插入 let insertnode = this.root let parent = null while (insertnode) &#123; parent = insertnode if (newNode.data &lt; insertnode.data) &#123; insertnode = insertnode.left &#125; else &#123; insertnode = insertnode.right &#125; &#125;//如果不用递归，那么要用两个变量记录，一个是之前的，一个是空。递归的话一开始就指定了前面的那个位置了。循环结束的话还没确定把 //新节点放在之前节点的哪一边，要再判断一下。 //指针循环最好用两个变量，一个是原变量，一个是新建变量 insertnode = newNode//虽然把null替换成了newNode，但是这个newNode与原parent没关系 if (insertnode.data &lt; parent.data) &#123; //此时node有值了 parent.left = insertnode &#125; else &#123; parent.right = insertnode &#125; &#125; &#125; //2，前序遍历，根左右 BinarySearchTree.prototype.preOrderTraversal = function (handler) &#123; //递归函数，内部定义一个递归遍历 preOrderTraversalNode = function (node, handler) &#123; if (node == null) &#123;//1,结束条件，节点为空 return //递归栈会自动返回上一层 &#125; else &#123; //递归栈的特性能保存数据，就保证了在同层次。 //处理根节点 handler(node.data)//2,执行体 //处理左子节点 this.preOrderTraversalNode(node.left, handler)//3，递归调用 //处理右子节点 this.preOrderTraversalNode(node.right, handler)//3，递归调用 &#125; &#125; preOrderTraversalNode(this.root, handler)//初始调用 &#125; //3，中序遍历，左根右 BinarySearchTree.prototype.midOrderTraversal = function (handler) &#123; //递归函数 midOrderTraversalNode = function (node, handler) &#123; if (node == null) &#123;//1，结束条件 return &#125; else &#123; //处理左子节点 this.midOrderTraversalNode(node.left, handler) //处理根节点 handler(node.data) //处理右节点 this.midOrderTraversalNode(node.right, handler) &#125; &#125; midOrderTraversalNode(this.root, handler) &#125; //4，后续遍历，左右根 BinarySearchTree.prototype.nexOrderTraversal = function (handler) &#123; //递归函数 nexOrderTraversalNode = function (node, handler) &#123; if (node == null) &#123;//1，结束条件 return //递归栈会自动返回上一层 &#125; else &#123; //处理左子节点 this.nexOrderTraversalNode(node.left, handler) //处理右节点 this.nexOrderTraversalNode(node.right, handler) //处理根节点 handler(node.data) &#125; &#125; nexOrderTraversalNode(this.root, handler) &#125; //5,寻找最小值 BinarySearchTree.prototype.min = function () &#123; let node = this.root if (node == null) &#123; return null &#125; else &#123; while (node.left) &#123; node = node.left &#125; return node.data &#125; &#125; //6，寻找最大值 BinarySearchTree.prototype.max = function () &#123; let node = this.root if (node == null) &#123; return null &#125; else &#123; while (node.right) &#123; node = node.right &#125; return node.data &#125; &#125; //7，搜索指定值 BinarySearchTree.prototype.search = function (data) &#123; //用递归实现如果需要返回值的时候，需要在每次调用前面都加一个return才会层层返回过来 //有返回值的时候吧，用循环不容易出错 // searchNode = function (node, data) &#123; // if (node==null) &#123;//停止条件node为空 // return \"不存在\" // &#125; else &#123;//node不为空 // if (data == node.data) &#123; // return \"存在\" // &#125; else if (data &lt; node.data) &#123; // return searchNode(node.left, data)//这里要加return，不然总是undefined // &#125; else &#123; // return searchNode(node.right, data)//这里要加return，不然总是undefined // &#125; // &#125; // &#125; // return searchNode(this.root, data)//这里要加return，不然总是undefined let node = this.root while (node) &#123;//node如果不为空就执行（node！==null），！node如果为空就执行。可以尽量用容易懂得 //console.log(node.data) if (data == node.data) &#123; return \"存在\" &#125; else if (data &lt; node.data) &#123; node = node.left &#125; else &#123; node = node.right &#125; &#125; return \"不存在\" &#125; //8，删除操作 BinarySearchTree.prototype.remove = function (data) &#123; //第一步，查找删除节点 let parent = null//被删节点的父节点 let current = this.root//被删节点的其实位置 let isLeftChild = true//被删节点是不是父节点的左节点 while (data != current.data) &#123; parent = current if (data &lt; current.data) &#123; isLeftChild = true current = current.left &#125; else &#123; isLeftChild = false current = current.right &#125; //没有找到 if (current == null) return false &#125; //第二步，找到该节点，开始删除操作 //1,该节点无子节点，直接删除该节点 if (current.left == null &amp;&amp; current.right == null) &#123; //该节点是根节点,删除后树为空 if (current == this.root) &#123; this.root = null &#125; else &#123;//该节点不是根节点 if (isLeftChild) &#123; parent.left = null//直接移除左孩子 &#125; else &#123; parent.right = null//直接移除右孩子 &#125; &#125; &#125; //2,该节点有一个子节点，要考虑删除该节点后，其子节点的移动，但是由于只有一个子节点，不存在左右比较的问题 //2.1只有右子节点，只能操作current.right else if (current.left == null) &#123; //先判断是否是根节点,如果是删除根节点,那么parent为空,不能操作 if (current == this.root) &#123; this.root = current.right &#125; else if (isLeftChild) &#123;//是父节点的左孩子 parent.left = current.right &#125; else &#123;//是父节点的右孩子 parent.right = current.right &#125; &#125; //2.2只有左节点，只能操作current.left else if (current.right == null) &#123; //先判断是否是根节点,如果是删除根节点,那么parent为空,不能操作 if (current == this.root) &#123; this.root = current.left &#125; else if (isLeftChild) &#123;//是父节点的左孩子 parent.left = current.left &#125; else &#123;//是父节点的左孩子 parent.right = current.left &#125; &#125; //3，该节点有两个节点，不仅要考虑删除节点胡，其子节点的移动，还要保证移动后依然是二叉搜索树 else &#123; //获取后继节点 let successor=this.getSuccessor(current) //先判断是否是根节点,如果是删除根节点,那么parent为空,不能操作 if(current==this.root)&#123; this.root=successor &#125;else if(isLeftChild)&#123;//待删节点是parent的左孩子 parent.left=successor//摘下current &#125;else&#123;//待删节点是parent的右孩子 parent.right=successor//摘下current &#125; //将删除节点的左子树给后继节点的左边 successor.left=current.left //删除节点的右子树拼接与要和后继节点进行比较，所以在获取后继节点的函数里处理 &#125; &#125; //9，寻找后继,提升大一点点的。 BinarySearchTree.prototype.getSuccessor = function (delNode) &#123; let successorParent//定义后继的父节点 let successor=delNode//定义后继 let current=delNode.right//后继在删除节点右子树里里 while(current!=null)&#123; successorParent=successor successor=current current=current.left &#125; //此时successor为后继节点。后继节点如果有子节点，只可能有一个，且为右节点。因为后继节点是右子树中的最小值 //后继节点是删除节点右子树中左侧没有左子树的层次最大的一个节点，在待删节点右节点没有子节点时，后继节点就是待删节点的右子节点 //设置后继节点父节点与后继节点子节点的关系,摘下后继节点，如果后继节点是删除节点的右节点，直接摘下，不需要拼接 if(successor!=delNode.right)&#123; successorParent.left=successor.right//不管successor的右子节点存不存在，都可以运行 successor.right=delNode.right//拼接右子树（//如果在在等于的情况下拼接就是后继的右节点等于后继，这没必要，等于没摘下来） //在相等的情况下，右子树不需要拼接 &#125; //返回拼接好右子树的后继节点 return successor &#125;&#125;//testlet bst1 = new BinarySearchTree()bst1.insert(11); bst1.insert(7); bst1.insert(15); bst1.insert(5); bst1.insert(3); bst1.insert(6);bst1.insert(9); bst1.insert(8); bst1.insert(10); bst1.insert(13); bst1.insert(12); bst1.insert(14)bst1.insert(20); bst1.insert(18); bst1.insert(15)//测试遍历//先序let resultString1 = \"\"bst1.preOrderTraversal(function (key) &#123; resultString1 += key + \" \"&#125;)console.log(resultString1)//11 7 5 3 6 9 8 10 15 13 12 14 20 18 15 //中序let resultString2 = \"\"bst1.midOrderTraversal(function (key) &#123; resultString2 += key + \" \"&#125;)console.log(resultString2)//3 5 6 7 8 9 10 11 12 13 14 15 15 18 20//后序let resultString3 = \"\"bst1.nexOrderTraversal(function (key) &#123; resultString3 += key + \" \"&#125;)console.log(resultString3)//3 6 5 8 10 9 7 12 14 13 15 18 20 15 11 console.log(bst1.min())//3console.log(bst1.max())//20console.log(bst1.search(11))//存在console.log(bst1.search(1))//不存在bst1.remove(3)bst1.remove(18)let resultString4 = \"\"bst1.midOrderTraversal(function (key) &#123; resultString4 += key + \" \"&#125;)console.log(resultString4)//5 6 7 8 9 10 11 12 13 14 15 15 20","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-哈希表二","date":"2020-06-19T01:18:33.000Z","path":"2020/06/19/数据结构与算法-哈希表二/","text":"哈希表的扩容思想为什么要扩容？ 随着数据量的增多，填充因子=数据量长度/数组长度，填充因子变大，就会使得哈希表的效率降低。所以需要在合适的时候进行扩容。 什么时候扩容？ 常见情况是：loadFactor&gt;0.75的时候进行扩容。loadFactor&lt;0.25就缩小容量 怎样扩容？ 保证扩容后的长度也为质数，并且扩容后其他数据项同时修改。所以扩容比较消耗性能，但是是必须的。 封装哈希表(链地址法实现)，二维数组，有扩容版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155function HashTable() &#123; //数组里放桶，桶里放数据，数组也以数组描述，0放key，1放value //this.storage-bucket-data //属性 this.storage = []//数组存放数据 this.count = 0//已存数据量 this.limit = 7//当前数组长度，设置初始长度为7 //工具函数，下标获取，扩容和缩容的时候的长度的取定为质数 //1，哈希函数 HashTable.prototype.hashFunc = function (str, size) &#123; //1,定义hashcode变量 let hashcode = 0 //2，秦九韶算法计算hashcode //cats-unicodeb编码 for (let i = 0; i &lt; str.length; i++) &#123; hashcode = hashcode * 37 + str.charCodeAt(i) &#125; //3,取余操作 let index = hashcode % size return index &#125; //2，判断质数 HashTable.prototype.isPrime = function (num) &#123; for (let i = 2; i &lt;= Math.sqrt(num); i++) &#123;//小于等于这里是，可以取到sqrt if (num % i == 0) &#123;//有因数 return false &#125; &#125;//无因数 return true &#125; //3，获取质数，根据原来的容量向上查找最接近的质数作为最接近的新容量 HashTable.prototype.getPrime = function (num) &#123; while (!this.isPrime(num)) &#123; num++ &#125; return num &#125; //方法 //1，插入与修改操作;第一步：根据key获取index；第二步：根据index获取位置里的数组(链表),如果该数组不存在就创建该数组。第三步：判断是新增还是修改，如果key存在就进行修改；key不存在就进行添加。 HashTable.prototype.put = function (key, value) &#123; //获取index let index = this.hashFunc(key, this.limit) //取出bucket let bucket = this.storage[index] //判断bucket是否存在 if (!bucket) &#123;//类型之间的判断用双等号if(bucket==null),用三等号这里报错 bucket = []//创建数组 this.storage[index] = bucket//将创建的空数组放入原数组 &#125; //判断添加还是修改 for (let i = 0; i &lt; bucket.length; i++) &#123;//遍历数组里的元素进行比较，进行修改 let data = bucket[i] if (data[0] === key) &#123;//每个元素又有两个部分 data[1] = value return true &#125; &#125; //循环结束无符合条件，进行添加,修改的话数据量不变，添加数据量加1 bucket.push([key, value])//存放格式 this.count++ //count++了判断是否需要扩容 if (this.count &gt; this.limit * 0.75) &#123; //判断质数 let newLimit = this.limit * 2//初始扩容 newLimit = this.getPrime(newLimit) this.resize(newLimit) &#125; &#125; //2，获取方法 HashTable.prototype.get = function (key) &#123; let index = this.hashFunc(key, this.limit) let bucket = this.storage[index]//获取bucket if (!bucket) return null//bucket为空，值不存在 for (let i = 0; i &lt; bucket.length; i++) &#123; let data = bucket[i] if (data[0] === key) return data[1]//返回值 &#125; &#125; //3，删除操作，调用数组删除操作splice() HashTable.prototype.remove = function (key) &#123; let index = this.hashFunc(key, this.limit) let bucket = this.storage[index]//获取bucket if (!bucket) return null//bucket为空，值不存在 //判断删除 for (let i = 0; i &lt; bucket.length; i++) &#123; let data = bucket[i] if (data[0] === key) &#123; bucket.splice(i, 1)//从i开始删除1个 this.count-- //count--了，判断是否需要缩小容量 if (this.count &lt; this.limit * 0.25 &amp;&amp; this.count &gt; 7) &#123; //判断质数 let newLimit = Math.floor(this.limit / 2) newLimit = this.getPrime(newLimit) this.resize(newLimit) &#125; return data[1] &#125; &#125; //遍历结束没有找到 return null &#125; //4，判断是否为空 HashTable.prototype.isEmpty = function () &#123; return this.count === 0 &#125; //5，获取个数 HashTable.prototype.size = function () &#123; return this.count &#125; //6，哈希扩容 HashTable.prototype.resize = function (newLimit) &#123; //获取旧数据 let oldstorage = this.storage //重置数据 this.storage = [] this.count = 0 this.limit = newLimit //遍历所有oldstorage中的bucket放入新storage for (let i = 0; i &lt; oldstorage.length; i++) &#123; //取出 bucket = oldstorage[i] //判断，中间的bucket可能是空的，因为在storage里放bucket的时候不是连续的。 if (!bucket) &#123; continue &#125; //bucket有数据 for (let j = 0; j &lt; bucket.length; j++) &#123; let data = bucket[j]//获取数据 this.put(data[0], data[1])//添加数据,定义的时候就是传入两个参数 &#125; &#125; &#125; &#125; //测试 let hash1 = new HashTable() //添加 hash1.put(\"abc\", 1) hash1.put(\"cba\", 2) hash1.put(\"nba\", 3) //获取 console.log(hash1.get(\"abc\"))//1 //修改 hash1.put(\"abc\", 111) console.log(hash1.get(\"abc\"))//111 //删除 hash1.remove(\"abc\") console.log(hash1.get(\"abc\"))//undefined console.log(hash1.size())//2","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS对象Proxy代理实现双向绑定","date":"2020-06-18T12:11:27.000Z","path":"2020/06/18/JS对象Proxy代理实现双向绑定/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" v-model=\"title\" /&gt; &lt;input type=\"text\" v-model=\"title\" /&gt; &lt;h4 v-bind=\"title\"&gt;这里也会发生更新&lt;/h4&gt;&lt;/body&gt;&lt;script&gt; function View() &#123; //1，step1:代理一个匿名空对象 let proxy = new Proxy( &#123;&#125;, &#123; set(obj, key, value) &#123;//step3:代理执行 //console.log(value)//此时value已经传入 //把proxy收到的属性同步给输入框2 document.querySelectorAll(`[v-model=\"$&#123;key&#125;\"]`).forEach((item) =&gt; &#123; item.value = value &#125;) //把proxy收到的属性同步给h4 document.querySelectorAll(`[v-bind=\"$&#123;key&#125;\"]`).forEach((item) =&gt; &#123; item.innerHTML = value//就算只有一个元素也用All，因为forEach是数组方法 &#125;) &#125;, get(obj, key) &#123; &#125; &#125; );//代理了一个空对象 //2，绑定事件 this.init = function () &#123; //获取触发事件的对象 const els = document.querySelectorAll(\"[v-model]\")//属性选择器 //添加事件 els.forEach((item, index) =&gt; &#123; item.addEventListener('keyup', function () &#123; //step2:触发代理对象的的set函数 proxy[this.getAttribute('v-model')] = this.value//往空对象里压入输入框1的属性 &#125;) &#125;) &#125; &#125; new View().init()&lt;/script&gt;&lt;/html&gt; 所谓代理（proxy），就是一个表示接口的对象，对它的操作不一定作用在代理对象本身。举个例子，设置代理对象的一个属性，实际上可能会在另一个对象上调用一个函数。代理是一种非常有用的抽象机制，能够通过 API只公开部分信息，同时还能对数据源进 行全面控制。 简单来说，Proxy就像一个代理商，拦截就是在中间添加判断与操作。 上面这个例子就是，代理一个匿名空对象接受属性，触发代理对象机制时，在set函数里操纵选定、不同的dom对象。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Proxy代理","slug":"Proxy代理","permalink":"https://zhoubb96.github.io/tags/Proxy%E4%BB%A3%E7%90%86/"},{"name":"访问控制器","slug":"访问控制器","permalink":"https://zhoubb96.github.io/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"JS对象Proxy代理拦截","date":"2020-06-18T10:26:49.000Z","path":"2020/06/18/JS对象Proxy代理拦截/","text":"所谓代理（proxy），就是一个表示接口的对象，对它的操作不一定作用在代理对象本身。举个例子，设置代理对象的一个属性，实际上可能会在另一个对象上调用一个函数。代理是一种非常有用的抽象机制，能够通过 API只公开部分信息，同时还能对数据源进 行全面控制。 简单来说，Proxy就像一个代理商，拦截就是在中间添加判断与操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//对象代理拦截const obj = &#123; name: \"zbb\", age: 24 &#125;const proxy = new Proxy(obj, &#123; get(obj, property) &#123;//obj接受obj return obj[property] &#125;, set(obj, property, value) &#123; obj[property] = value return true &#125; &#125;) console.log(proxy.name) //zbb proxy.name=\"zhou\" console.log(proxy.name) //zhou//函数代理拦截function jiechen(num)&#123; if(num===0) return 1 if(num===1) return 1 return num*jiechen(--num)&#125;console.log(jiechen(4))//24let proxy = new Proxy(jiechen,&#123; apply(func,obj,args)&#123;//func接受jiechen，obj接受对象，args接受参数 console.time('run') func.apply(this,args) console.timeEnd('run') &#125;&#125;)proxy.apply(this,[4])//一个时间，其实这里obj随便传什么。//对数组代理拦截const lessons = [ &#123;title: \"媒体查询响应式布局\",category: \"css\"&#125;, &#123;title: \"FLEX模型\", category: \"css\"&#125;, &#123; title: \"MYSQL多表查询随意操作\",category: \"mysql\"&#125; ];let proxy=new Proxy(lessons,&#123; get(array,key)&#123;//array就是proxy中的，自动接收。 const title=array[key].title const len=5 return title.length&gt;5?title.substr(0,len)+'.'.repeat(3):title &#125;&#125;)console.log(proxy[0])//媒体查询响...console.log(proxy[1])//FLEX模...console.log(proxy[2])//MYSQL... 上面几个例子，第一个参数不用手动传递。也就是obj，func，array，就是接受自身代理的那个东西。后面几个参数必须手动传入。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Proxy代理","slug":"Proxy代理","permalink":"https://zhoubb96.github.io/tags/Proxy%E4%BB%A3%E7%90%86/"},{"name":"访问控制器","slug":"访问控制器","permalink":"https://zhoubb96.github.io/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"JS-Token的读写处理","date":"2020-06-18T09:21:48.000Z","path":"2020/06/18/JS-Token的读写处理/","text":"Token的访问控制器设置 12345678910111213141516//设置token令牌对象let Request=&#123; //没有在对象中，因为数据存在了本地 set token(content)&#123; localStorage.setItem('token',content)//在本地缓存设置一个token &#125;, get token()&#123; let token=localStorage.getItem('token')//获取 if(!token)&#123; alertr('请登录')//没有token &#125; return token &#125;,&#125;Request.token='123'console.log(Request.token)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS对象访问控制器","date":"2020-06-18T08:51:50.000Z","path":"2020/06/18/JS对象访问控制器/","text":"访问器属性的优先级高于普通的属性操作方式！ 使用访问控制器保护对象数据123456789101112131415const user=&#123; data:&#123;name: \"zbb\",age: 24&#125;,//对象中的对象；封装起来保护数据 set age(value)&#123; if(typeof value!='number'||value&lt;0||value&gt;100)&#123; throw new Error('年龄格式错误') &#125; this.data.age=value &#125;,//函数成员，没有键？只有通过访问器才能修改数据 get age()&#123; return this.data.age//如果是this.age就会循环找访问器属性，死循环，应该是data中的age &#125;&#125;user.age=77//调用方法保持一致console.log(user.age)//77//用set与get两个关键字修饰两个age同名了，但是不冲突，因为一个要传参数，一个不穿参数，根据参数的有无自动调用，可以用对象点方法的形式直接调用，保证了调用形式的一致性 使用访问控制器伪造对象属性1234567891011121314const lessons = &#123; lists: [ &#123; name: \"js\", price: 100 &#125;, &#123; name: \"mysql\", price: 212 &#125;, &#123; name: \"vue.js\", price: 98 &#125; ], get total()&#123; return this.lists.reduce((pre,cur)=&gt;&#123; return pre+cur.price &#125;,0) &#125;, &#125; console.log(lessons.total)//410，伪造了total这个属性 lessons.total=8388//报错，无此属性无法设置。因为我们没有定义set 构造函数与访问控制器的联合使用123456789101112131415161718192021222324252627282930function User(name, age) &#123; let data = &#123; name, age &#125; //封装数据 Object.defineProperties(this, &#123; name: &#123; get() &#123; return data.name &#125;, set(value) &#123; if (value.trim() === \"\" || value.length &gt; 20) &#123; throw new Error('用户名不合法') &#125; data.name = value &#125; &#125;, age: &#123; get() &#123; return data.age &#125;, set(value) &#123; data.age = value &#125; &#125;, &#125;) //访问控制器设置数据&#125;let user = new User(\"zbb\", 24)console.log(user)//User&#123;&#125;user.name=\"zhou\"console.log(user.name)//zhou 类与访问控制器的联合使用1234567891011121314151617181920212223242526class User &#123; constructor(name, age) &#123; this.data = [name, age] &#125; //name的访问控制器 get name() &#123; return this.data.name &#125; set name(value) &#123; if (value.trim() === \"\" || value.length &gt; 20) &#123; throw new Error('用户名不合法') &#125; this.data.name = value &#125; //age的访问控制器 get age() &#123; return this.data.age &#125; set age(value) &#123; this.data.age = value &#125;&#125;let user = new User(\"zbb\", 24)console.log(user)//User&#123;&#125;user.name=\"zhou\"console.log(user.name)//zhou","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"访问控制器","slug":"访问控制器","permalink":"https://zhoubb96.github.io/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"对象的创建方式","date":"2020-06-18T07:15:33.000Z","path":"2020/06/18/JS对象的创建方式/","text":"对象的创建方式1，字面量模式1let obj=&#123;name:\"zbb\",show:function()&#123;console.log(this.name)&#125;&#125; 2，工厂函数(没有用关键字new)1234function user(name)&#123; return &#123;name,show:function()&#123;console.log(this.name)&#125;&#125;//返回对象&#125;let obj = user(\"zbb\") 3，构造函数(使用关键字new) 123456789101112131415function User (name)&#123; this.name=name this.show=function()&#123;//键值对给个匿名函数只在对象里才行 console.log(this.name) &#125; return this//this是设置完的对象&#125;let zbb=new User(\"zbb\")let ycy=new User(\"ycy\")zbb.show()//zbblet fun=zbb.show//将方法赋值给变量后，fun变成普通函数fun()//undefined；因为此时就不再是方法调用，而是普通函数，this变成了windowconsole.log(zbb)//可以看到zbb里面有一个name属性和一个show方法console.log(ycy)//ycy里面也有一个name属性和一个show方法//这个方法可以放到原型里，而不必放到每个实例对象里，这样可以节省空间 new共经过了4几个阶段 1、创建一个空对象 2、设置原型链 3、让构造函数的this指向obj，并执行构造函数的函数体。 4、判断的构造函数返回值类型，并返回对象：（为值得话，返回对象；如果是引用就是返回引用类型对象） 注意：这种方法的创建对象，那么方法在每个对象里都有一份，有点浪费空间。 4，构造函数+原型12345678910function User(name) &#123; this.name = name return this//this是设置完的对象&#125;User.prototype.show = function () &#123;//键值对给个匿名函数只在对象里才行 console.log(this.name)&#125;let zbb=new User(\"zbb\")//User &#123;name: \"zbb\"&#125;,里面没有show方法console.log(zbb)//zbb，依然可以成功调用，调用原型zbb.show() 节省空间。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS对象","date":"2020-06-18T03:04:04.000Z","path":"2020/06/18/JS对象/","text":"属性 属性的检测 对象属性检测obj.hasOwnProperty(&quot;key&quot;),仅查看自身属性 原型链属性检测&quot;key&quot; in obj，自身与原型的属性都进行检测 属性的计算 动态计算属性名，reduce方法 1234567891011let lessons = [ &#123;title: \"媒体查询响应式布局\",click: 89,price: 12&#125;, &#123;title: \"FLEX 弹性盒模型\",click: 45,price: 120&#125;, &#123;title: \"GRID 栅格系统\",click: 19,price: 67&#125;, &#123;title: \"盒子模型详解\",click: 29, price: 300&#125; ]; obj=lessons.reduce((pre,cur,index)=&gt;&#123; pre[`$&#123;cur['title']&#125;-$&#123;index&#125;`]=cur//每次都添加新的键值对 return pre &#125;,&#123;&#125;) console.log(obj)//&#123;媒体查询响应式布局-0: &#123;…&#125;, FLEX 弹性盒模型-1: &#123;…&#125;, GRID 栅格系统-2: &#123;…&#125;, 盒子模型详解-3: &#123;…&#125;&#125; 属性的获取Object.keys(obj)，获取对象obj的所有属性名，以数组返回，或者使用for-in 属性的复制Object.assign(obj1,obj2)，将obj2的属性复制给obj1；也可以用循环与展开语法。 属性的定制 属性的可读写性等Object.defineProperty(obj,key,{key,writable:true,enumerable:true,configurable:true}) 禁止外部添加属性Object.preventExtensions(obj) 对象的封闭Object.seal(obj)不能对对象的属性进行操作 对象的冻结Object.freeze(obj)不能对对象进行修改，可以使用。 属性的保护 如果属性在内部外部都能访问，那就是公共的属性；但是有的属性我们只想内部访问，防止外部修改，有什么方法？ 使用命名规则来保护属性。_url与url，但还是可以直接用前者设置，绕开访问控制器。 12345678910111213141516171819202122class Request &#123; constructor(url) &#123; this._url &#125; set url(url) &#123;//伪造属性url,实际内部的是_url if (!/^http?:\\/\\//i.test(url)) &#123; throw new Error(\"请以协议开头\") &#125; this._url = url &#125; get url()&#123; return this._url &#125; &#125;let baidu = new Request(\"http://www.baidu.com\")console.log(baidu)//Request &#123;data: &#123;…&#125;&#125;baidu.url = 'http://baidu?'console.log(baidu.url)//http://baidu?，符合规则修改成功baidu._url=\"zhazhahui\"console.log(baidu.url)//zhazhahui,绕过控制器baidu.url = 'baidu?'console.log(baidu.url)//不符合规则报错 使用Symbol定义protected属性，因为symbol的唯一性，所以在外边不清楚host的情况下不能直接修改url，必须通过访问控制器。类似的还要Weakmap等方法。 1234567891011121314151617181920class Request &#123; const host=Symbol('主机')//到时候不暴露这个就行了。 constructor(url) &#123; this[host] = url &#125; set host(url) &#123;//伪造属性host if (!/^http?:\\/\\//i.test(url)) &#123; throw new Error(\"请以协议开头\") &#125; this[host] = url &#125; get host()&#123; return this[host] &#125;&#125;let baidu = new Request(\"http://www.baidu.com\")console.log(baidu)//Request &#123;data: &#123;…&#125;&#125;baidu.host = 'http://baidu?'console.log(baidu.host)//http://baidu?baidu.host='baidu?'////Uncaught Error: 请以协议开头 使用private操作私有属性，在属性前面加井号#，必须靠访问控制器在内部修改。不能在外部访问或修改。必须是内部返回或修改。只能在当前类，直接使用。 1234567891011121314151617class User &#123; #host = \"https://baidu.com\"; constructor(name) &#123; this.name = name; &#125; set host(url) &#123; if (!/^https?:/i.test(url)) &#123; throw new Error(\"非常网址\"); &#125; this.#host = url; &#125;&#125;let bd = new User(\"百度\");console.log(bd)bd.host = \"https://zhazhahui.com\";console.log(bd);//bd.#host=\"okk\"//Private field '#host' must be declared in an enclosing class 方法将普通函数封装为对象方法的好处在于可以避免函数冲突，而且封装过后调用简单。对象是引用变量，所以通常情况下是传地址，而且是浅拷贝。注意对象中的对象的传递。 深拷贝，一层一层的处理处理对象中的对象的赋值，判断递归 12345678910111213141516//浅拷贝，object[key]可能也为一个对象function copy(object)&#123; let res=&#123;&#125; for(const key in object)&#123; res[key]=object[key] &#125; return res&#125;//深拷贝，递归函数function deepcopy(obj)&#123; let res=obj istacneof Array?[]:&#123;&#125;//因为递归进行下去时，最里面的数据可能是数组，因此是数组的情况下应该返回数组 for(const[key,value] in Object.entries(obj))&#123;//考虑数组的情况，统一键值对，统一数组与对象的处理方法 res[key]=typeof value==='object'?deepcopy(value):value//是对象就继续递归，不是对象直接赋值 &#125; return res&#125; 面向对象三大特性：封装、继承、多态","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"深浅拷贝","slug":"深浅拷贝","permalink":"https://zhoubb96.github.io/tags/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"JS抖动与加速","date":"2020-06-18T01:23:57.000Z","path":"2020/06/18/JS抖动与加速/","text":"动画抖动与加速1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;后盾人&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; button &#123; position: absolute;/*必须加上这个style标签，不然动不了*/ &#125; &lt;/style&gt; &lt;button message=\"按钮\"&gt;按钮&lt;/button&gt; &lt;/body&gt; &lt;script&gt; let btns = document.querySelectorAll(\"button\") btns.forEach((items) =&gt; &#123; //let left=1//位置2 items.addEventlistener(\"click\", function () &#123; //let left=1//位置1 setInterval(function()&#123; items.style.left=left++ +\"px\" &#125;,100) &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; 函数的本意是点击按钮使得按钮移动 1，如果left=1放在位置1，会在第二次点击后产生动画抖动，因为每点击一次，left都会回到1，重新计算。 2，如果left=1放在位置2，那么因为因为left被修改了（this方式），外部环境没有消亡会保存left信息，因此不会抖动，但是会出现动画加速问题，因为会多个定时器叠加，解决方法是在外部先对定时器进行判断，如果无定时器才开启定时器，有的话就不开启了，就保证只有一个定时器。 12345678910111213let btns = document.querySelectorAll(\"button\") btns.forEach((items) =&gt; &#123; let left=1 let interval=false items.addEventlistener(\"click\", function () &#123; if(interval===false)&#123; interval=true setInterval(function()&#123; items.style.left=left++ +\"px\" &#125;,100) &#125; &#125;) &#125;) 注意内外部环境与定时器的累加问题 123456789101112131415//但是把变量放在外部可能污染变量let btns = document.querySelectorAll(\"button\") btns.forEach((items) =&gt; &#123; let bind=false items.addEventListener(\"click\", function () &#123; if(!bind)&#123; bind=true let left=1 setInterval(function()&#123; items.style.left=left++ +\"px\" &#125;,100) &#125; &#125;) &#125;)//原理是只产生一个定时器，即解决抖动又解决加速。空环境中没有数据。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS环境、作用域与闭包","date":"2020-06-17T06:38:27.000Z","path":"2020/06/17/JS环境、作用域与闭包/","text":"作用域定义：一块静态的代码区域，在编码时确定，并不会再改变 类型：全局作用域，函数作用域，块作用域（for循环括号里变量，在此之前使用立即执行函数的函数作用域模拟块作用域，）。 环境上下文对象定义：一个管理相应作用域中数据的对象；有全局上下文对象，函数上下文对象 全局上下文对象是window，不会被回收，除非关闭标签 函数上下文对象是运行时动态创立的，运行结束时回收；执行几次创建几次，每次创建数据都是新的，产生多个内存地址，每个内存地址里都有一份数据。 作用域涵盖了上下文对象，上下文对象在作用域里活动。 闭包声明：嵌套函数，内部函数引用外部函数变量（内部更新数据后返回给外部）。 原理：每次外部函数执行的时，外部函数都会创建一个新的环境，这个环境的引用地址是不同，都会重新创建一个新的地址，里面的数据也是全新的。但是如果当前外部环境中有被内部函数引用的数据，那么这个时候，外部环境不会被回收；这个数据不删除，会被保留一根指针给内部活动对象。 ​ 简单说内部改变数据并返回给外部函数，让外部函数保存这个数据，并且外部环境不被回收。(利用了垃圾回收的引用规则) 1234567891011function f1()&#123; let n=1 function sum()&#123; console.log(++n)//因为外面没有更新这个++n &#125; sum()&#125;f1()//2f1()//2f1()//2//每次调用f1，创建一个性的上下文对象数据都是新的，n总是1. 那么如何延长函数上下文的生存周期呢？ 1234567891011121314151617function f2()&#123; let n=1 return function sum()&#123;//1，这个return就把里面的数据传递了出去，更新了外部的++n，引用类型会更新数据。2，除此之外也可以用this来建立这个引用关系。this.sum=function()&#123;console.log(++n)&#125;,也行，这称为构造函数的闭包 console.log(++n) &#125; sum()//这句这里有没有都不影响&#125;f2()//无输出，因为还没到sum()调用，sum就被返回了f2()()//2f2()()//2f2()()//2//相当于每次都开了一个新环境，这种方法没有利用到闭包let a=f2()//不让外部函数每次都重新建立，这部是关键a()//2a()//3a()//4//因为a这个环境是一开始创好的不会每次都创建新的，利用到了闭包 关键就是外部环境中的变量被引用（更新），从而使得让外部环境保留 1，这个return就把里面的数据传递了出去，更新了外部的++n，引用类型会更新数据。返回了这个函数，而这个函数还在使用这个外部变量，所以外部环境不会被删除。常驻内存了。 2，除此之外也可以用this来建立这个引用关系。this.sum=function(){console.log(++n)},也行，这是构造函数的闭包 闭包的小应用 12345678910111213141516let arr=[1,3,5,7,9,10,25,56]let arr2=arr.filter((value)=&gt;&#123; return value&gt;3&amp;&amp;value&lt;56//那我们每次如果要修改区间还要改这个数字，抽离函数封装起来&#125;)console.log(arr2)//[5, 7, 9, 10, 25]//封装函数function between(a,b)&#123; return function(v)&#123; return v&gt;a&amp;&amp;v&lt;b &#125; //return (v)=&gt; v&gt;a&amp;&amp;v&lt;b这是简写，不方便理解闭包 &#125;//filter调用，filter会自动把value传给参数vlet arr3=arr.filter(between(3,25))console.log(arr3)////[5, 7, 9, 10, 25] 123456789101112131415let lessons = [ &#123;title: \"媒体查询响应式布局\",click: 89,price: 12&#125;, &#123;title: \"FLEX 弹性盒模型\",click: 45,price: 120&#125;, &#123;title: \"GRID 栅格系统\",click: 19,price: 67&#125;, &#123;title: \"盒子模型详解\",click: 29, price: 300&#125; ]; function order(field)&#123; return function(a,b)&#123; return a[field]&gt;b[field]?1:-1 &#125; &#125; console.table(lessons.sort(order(\"click\")))//属性名是字符串。 console.table(lessons.sort(order(\"price\")))//自定义函数抽离与sort，filter等函数联合使用。//抽离，然后sort调用 函数利用到其他函数的数据。 闭包的问题：内存泄露，优化手段就是定义新的变量来只保留想要信息，获取完后及时去掉不需要的变量内存。在闭包里要非常关注this的指向，因为闭包可以向上获取信息，但是一般this是不会向上寻找的。所以闭包里最好用箭头函数。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS递归与循环","date":"2020-06-17T04:03:48.000Z","path":"2020/06/17/JS递归与循环/","text":"递归重复做一件事，在合适的时候返回即可。递归的关键在于终止条件的判断 123456789101112131415161718192021//递归实现阶乘，形式和判断很简单但是运行效率慢function jiechen1(num)&#123; if(num===0) return 1 if(num===1) return 1 //return num*jiechen(num--)//此处num--会导致报错，因为num--的话取得还是num，没有进入下一步 return num*jiechen1(num-1)//必须是n-1，或者--n&#125;//循环实现阶乘,形式和判断要复杂些但是运行效率快function jiechen2(num)&#123; if(num===0) return 1 if(num===1) return 1 let result=1 for(let i=2;i&lt;=num;i++)&#123; result=result*i &#125; return result&#125;console.log(jiechen1(4))//24console.log(jiechen2(5))//120 递归函数内顺序 1，停止条件 2，执行体代码 3，递归调用 12345678910//以打印倒三角为例子function star(num)&#123; //1，停止条件 if(num===0) return \" \" //2，执行体代码 document.write(\"*\".repeat(num)+\"&lt;br/&gt;\")//html换行标签&lt;br/&gt; //3，递归调用 star(--num) &#125;star(5)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"数据结构与算法-哈希表一","date":"2020-06-16T12:06:12.000Z","path":"2020/06/16/数据结构与算法-哈希表一/","text":"哈希表搞懂哈希表到底如何实现的。理论知识较多，实现并不难。哈希表是基于数组实现的，但是相对与数组有以下优势 优势 可以提供快速的插入，删除，查找操作。 无论数据量为多少，插入与删除的时间复杂度都接近o(1) 速度比树还要快，可以很快的查找。 编码难度比树简单 不足之处 由于内部是无序数据，所以无法以一种固定方式遍历元素。 哈希表的key值不允许重复 空间利用率不高 哈希函数哈希表对下标值会做一种变换，这个变换规则称之为哈希函数，通过哈希函数获取到哈希码，HashCode，一一对应。 第一次看hash表的时候没有深入了解这个东西。 目标：1，将字符串转为大的数字hashcode；2，将大的数字hashcode压缩到数组范围内index 直接相加，不能保证数字的唯一性。 幂的连乘，基本可以保证数字的唯一性，但是产生的下标会过大，导致数组过大，元素分布不均匀。 优秀的哈希函数应当由以下优点 计算简单（尽量避免乘除法，提高计算速度） 输出均匀（减小探测步长与次数） 多项式计算，再利用秦九韶算法。使用质数当作底数， 哈希化：是把任意长度的输入通过散列算法（哈希函数）变换成固定长度的输出，该输出就是散列值（哈希值）。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 哈希化后的下标依然可能重复，所以要处理冲突。 实现一个hash函数 123456789101112131415//哈希函数1，将字符串转为较大的数字；2，将大的数字压缩到数组范围内 function hashFunc(str,size)&#123; //1,定义hashcode变量 let hashcode=0 //2，秦九韶算法计算hashcode //cats-unicodeb编码 for(let i=0;i&lt;str.length;i++)&#123; hashcode=hashcode*37+str.charCodeAt(i) &#125; //3,取余操作 let index=hashcode%size return index &#125; console.log(hashFunc('abc',7))//4 冲突的处理方法 1，链地址法 在数组的下标位置放一个链表，每个数组单元不再放单个数据，而是一个链条（或者数组）。先通过下标取到位置，再通过位置遍历链表。 2，开放地址法 寻找空白的单元格添加重复数据，寻找方法又有线性探测、二次探测法和再哈希法。如何确定探测步长。 线性探测法步长为1，线性探测法存在的问题是在表里还没有任何数据的时候，插入连续的元素会造成聚集，这会影响性能。 二次探测法可以解决聚集的问题，优化探测步长，一次性探测较长的步长就避开了聚集问题。 再哈希法，产生依赖于关键字的探测方法，多次使用哈希函数，第二次的哈希数作为步长。第二次哈希函数不能与第一次哈希函数相同，且输出结果不能为零。stepsize=const-(key%const),const是一个小于数组容量的质数。 哈希化的效率1，没有冲突的时候，效率是最高的 2，如果发生冲突，那么与效率依赖于探测长度 3，探测长度和平均存储事件又取决于填充因子。 填充因子的概念：已有数据量/哈希表长度 开发地址法的填充因子最大为1；而链地址法的填充因子可以远超过1。 填充因子越大、空间利用率越高、查询效率越低。 链地址法的时间复杂度与填充因子是线性的，而开放地址法的时间复杂度与填充因子是指数关系的。所以使用链地址法多一些。 封装哈希表(链地址法实现)，二维数组，无扩容版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function HashTable()&#123; //数组里放桶，桶里放数据，数组也以数组描述，0放key，1放value //this.storage-bucket-data //1,属性 this.storage=[]//数组存放数据 this.count=0//已存数据量 this.limit=7//当前数组长度，设置初始长度为7 //2，哈希函数 HashTable.prototype.hashFunc=function (str,size)&#123; //1,定义hashcode变量 let hashcode=0 //2，秦九韶算法计算hashcode //cats-unicodeb编码 for(let i=0;i&lt;str.length;i++)&#123; hashcode=hashcode*37+str.charCodeAt(i) &#125; //3,取余操作 let index=hashcode%size return index &#125; //方法 //1，插入与修改操作;第一步：根据key获取index；第二步：根据index获取位置里的数组(链表),如果该数组不存在就创建该数组。第三步：判断是新增还是修改，如果key存在就进行修改；key不存在就进行添加。 HashTable.prototype.put=function(key,value)&#123; //获取index let index = this.hashFunc(key,this.limit) //取出bucket let bucket=this.storage[index] //判断bucket是否存在 if(!bucket)&#123;//类型之间的判断用双等号if(bucket==null),用三等号这里报错 bucket=[]//创建数组 this.storage[index]=bucket//将创建的空数组放入原数组 &#125; //判断添加还是修改 for(let i=0;i&lt;bucket.length;i++)&#123;//遍历数组里的元素进行比较，进行修改 let data=bucket[i] if(data[0]===key)&#123;//每个元素又有两个部分 data[1]=value return true &#125; &#125; //循环结束无符合条件，进行添加,修改的话数据量不变，添加数据量加1 bucket.push([key,value])//存放格式 this.count++ &#125; //2，获取方法 HashTable.prototype.get=function(key)&#123; let index=this.hashFunc(key,this.limit) let bucket=this.storage[index]//获取bucket if(!bucket) return null//bucket为空，值不存在 for(let i=0;i&lt;bucket.length;i++)&#123; let data=bucket[i] if(data[0]===key) return data[1]//返回值 &#125; &#125; //3，删除操作，调用数组删除操作splice() HashTable.prototype.remove=function(key)&#123; let index=this.hashFunc(key,this.limit) let bucket=this.storage[index]//获取bucket if(!bucket) return null//bucket为空，值不存在 //判断删除 for(let i=0;i&lt;bucket.length;i++)&#123; let data=bucket[i] if(data[0]===key) &#123; bucket.splice(i,1)//从i开始删除1个 this.count-- return data[1] &#125; &#125; //遍历结束没有找到 return null &#125; //4，判断是否为空 HashTable.prototype.isEmpty=function()&#123; return this.count===0 &#125; //5,获取个数 HashTable.prototype.size=function()&#123; return this.count &#125;&#125;//测试let hash1=new HashTable()//添加hash1.put(\"abc\",1)hash1.put(\"cba\",2)hash1.put(\"nba\",3)//获取console.log(hash1.get(\"abc\"))//1//修改hash1.put(\"abc\",111)console.log(hash1.get(\"abc\"))//111//删除hash1.remove(\"abc\")console.log(hash1.get(\"abc\"))//undefinedconsole.log(hash1.size())//2","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-集合","date":"2020-06-16T07:09:18.000Z","path":"2020/06/16/数据结构与算法-集合/","text":"集合Set一般常用哈希表实现，但是这里先自己使用object类封装一个集合类。Set类在ES6中已经原生支持了。 集合Set的元素是无序的（不能用下标的方法访问），且值不能重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//集合function Set()&#123; //属性 this.items=&#123;&#125;//用对象存储封装，对象值的覆盖 //方法 //1,添加 Set.prototype.add=function(value)&#123; if(this.has(value))&#123;//如果有值返回失败，其实如果不判断，不影响唯一性。 return false &#125; this.items[value]=value//键值合一，也保证了元素的唯一性。因为一样的值会进行覆盖 return true &#125; //2，判断 Set.prototype.has=function(value)&#123; return this.items.hasOwnProperty(value)//这是对象判断属性的方法，hasOwnProperty() &#125; //3，remove Set.prototype.remove=function(value)&#123; if(!this.has(value)) return false delete this.items[value]//这是对象删除属性的方法，delete return true &#125; //4，clear Set.prototype.clear=function()&#123; this.items=&#123;&#125;//重新赋值，原对象因为失去引用而被回收 &#125; //5，size Set.prototype.size=function()&#123; return Object.keys(this.items).length//这是对象获取属性数量的语句，keys() &#125; //6，values Set.prototype.values=function()&#123; return Object.values(this.items)//或者Object.keys(this.items)，因为键值合一 &#125; &#125;let set = new Set()console.log(set.add(\"abc\"))//trueconsole.log(set.add(\"abc\"))//falseset.add(\"cba\")set.add(\"nba\")set.add(\"swk\")console.log(set.size())//4console.log(set.remove(\"nba\"))//trueconsole.log(set.remove(\"nba\"))//falseconsole.log(set.values())//(3) [\"abc\", \"cba\", \"swk\"],数组形式返回set.clear()console.log(set.values())//[]let set1 = new","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS函数与箭头函数","date":"2020-06-16T06:56:17.000Z","path":"2020/06/16/JS函数与箭头函数/","text":"1，函数声明的几种形式1,使用对象的方式来定义函数 123let func=new Function('title','console.log(title)')//func是函数名，title是参数，console.log(title)是函数体func(\"zbb\") 2,字面量方式定义函数 1234function func1(title) &#123; console.log(title)&#125;;func1(\"zbb\") 2，匿名函数与函数提升一般函数会被压入window对象中，成为全局函数，如果定义的函数与window的原有函数重名，那么就会覆盖window自带函数，污染全局。 可以将匿名函数赋值给let声明的变量（var不行，var有提升，还是会压入全局） 12345let fun=function()&#123; console.log(\"function\")&#125;fun()//调用成功window.fun()//调用失败，如果用的是var声明，那么会调用成功 建议函数不独立存放，以模块，类的方式管理函数。 直接定义的函数（全局）会有函数提升，但是赋值给变量的匿名函数不会有提升，不管这个变量是用var声明的还是let声明的。 3，立即执行函数与块作用域 立即执行函数 (function(){})(),可以解决命名冲突污染全局作用域的问题。原理是用函数作用域达到隔离的效果。立即执行函数加对象管理，并选择性暴露。这是早期方式。 let的块级作用域 块级作用域加对象管理，并选择性暴露。原理和上面类似，这里是用块级作用域隔离。 123456&#123; let a=\"zbb\" var b=\"ycy\"&#125;console.log(a)//失败，let，const有块级作用域console.log(b)//成功，var没有，可以访问到 4，关于参数1，参数列表 实参数量一般是对应形参数量的，但是实参数量可以大于形参，多的参数会被忽略。 如果实参数量小于形参数量，那么多的形参就为undefined。 可以给形参设置默认值。 2，函数参数与arguments 函数作为参数的时候就是回调函数。 在不确定参数列表长度的时候，arguments会把所有参数收集起来。arguments是有长度属性的，但是它是一个伪数组，不具备数组的方法，当然，可以把它转换为数组。[…arguments] 123function sum(...args)&#123;//在不确定参数列表长度的时候，接受所有变量 console,log(args)&#125; 5，箭头函数 可以很好的简化匿名函数的实现。而且摆脱原有this对象带来的麻烦。.箭头函数的this与其定义时所处的对象有关，与调用者无关；如果外层有函数，则其与外层函数的this对象一致，如果外无函数，直接指向window 很好的解决了闭包里this的问题 参数传递 没有参数: () =&gt; console.log(&#39;xxxx&#39;) 一个参数: i =&gt; i+2，()小括号可以省略；i就是参数 大于一个参数: (i,j) =&gt; i+j，()小括号不可以省略； 返回值 函数体只有一条语句的话，函数体不用大括号; 默认自动返回执行的结果；（自己return了） 函数体如果有多个语句, 需要用{}包围；有大括号的话，必须使用return返回想返回的结果（因为没有return的话默认返回undefined） 因为箭头函数没有函数名，所以不能解决递归函数，构造函数，事件处理的时候不方便使用。 6，This的不同的情况：除了箭头函数，this是不会向上查找的，如果不是方法，那this就是window。 1.以普通函数的形式调用时，this是window 2.以工厂函数调用，this是undefind 3.以构造函数的形式调用时，this就是新创建的对象 这个方法必须通过new调用（构造函数必须以new调用），因为构造函数也是函数，如果普通调用，this还是会指向window 4.以方法的形式调用时，this就是调用方法的对象 5.使用call和apply调用时，this是指定的那个对象 6.在全局作用域中this代表window 7.react组件中自定义方法函数的this为null 8.箭头函数的this与其定义时所处的对象有关，与调用者无关；如果外层有函数，则其与外层函数的this对象一致，如果外无函数，直接指向window 7，使用call，apply与bind改变this1，call与apply都会立即调用函数 call(obj,a,b,c) apply(obj,[a,b,c]) 如果不想改变对象，那么第一个参数传入null 不传参数时候二者是一样的，传参数时区别在于call是一个一个的传入，而apply是用数组来传入参数。 2，bind，不会立刻调用函数。 bind(obj,a,b,c) 1，参数可以在绑定时传递；2，也可以在调用时传递，一般在调用时传递；因为不立即执行，bind绑定只是为了修改this对象。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS-Map字典与Weakmap类型","date":"2020-06-16T01:15:51.000Z","path":"2020/06/16/JS-Map字典与Weakmap类型/","text":"1，Map类型Map类型就是JS原生支持的字典类型。以往的对象类型是以字符串作为键名；而Map类型的键名可以为任意类型的变量。 12345678910111213141516171819 //传统对象 let obj = &#123; name: \"name\" &#125;; let hd = &#123; [obj]: \"姓名\"//如过不加中括号，那么这个obj是个字符串该字符串就为“obj”与上面的对象类型的obj没有任何关系，加了中括号，就会把上面的对象类型的obj转化为字符串。[object Object] &#125;; console.log(hd[obj.toString()]);//中括号取值 //Map类型 let map = new Map(); map.set(\"name\", \"姓名\");//&#123;\"name\" =&gt; \"姓名\"&#125; map.set(function() &#123;&#125;, \"cms\");//&#123;function() &#123;&#125; =&gt; \"cms\"&#125; map.set(&#123;&#125;, \"houdunren\");//&#123;Object =&gt; \"houdunren\"&#125; map.set(1, \"sina.com.cn\");//&#123;1 =&gt; \"sina.com.cn\"&#125; console.log(map); let map = new Map([[\"cms\", \"开源系统\"], [\"JS, \"在线教程\"]]);//&#123;\"cms\" =&gt; \"开源系统\"&#125;&#123;\"JS\" =&gt; \"在线教程\"&#125; 增删改查，set，delete，has 1234567891011121314151617 let obj = &#123; name: \"姓名\" &#125;; let map = new Map(); map.set(obj, \"sina.com\"); console.log(map.get(obj))//sina.com console.log(map.delete(obj))//true // map.clear();清空 // console.log(map.has(\"site\"));false，查询的是键名。 // console.log(map.keys())//复数，获取所有键，以对象形式返回。 // console.log(map.values())//复数，获取所有值。以对象形式返回。 // console.log(map.entries())//复数，所有键值对，以对象形式返回。用forEach也行//Map转换为数组，这里外层的中括号表示把展开的元素放入数组里// console.log([...map.keys()])// console.log([...map.values()])// console.log([...map.entries()]) 2，WeakMap类型WeakMap类型中的键名只能为对象。 屏蔽了循环迭代，size，keys与values等方法。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Map字典类型","slug":"Map字典类型","permalink":"https://zhoubb96.github.io/tags/Map%E5%AD%97%E5%85%B8%E7%B1%BB%E5%9E%8B/"}]},{"title":"JS-Set集合与WeakSet类型","date":"2020-06-15T09:21:27.000Z","path":"2020/06/15/JS-Set集合与WeakSet类型/","text":"1，Set类型：值不能重复的容器。数组传参，没有键，只有值，或者说键与值是一样的，也就是采用【值，值】的方式 1234567891011121314let set = new Set([1, 1, 2, 3, 4, 5]);console.log(set)//Set(5)&#123;1,2,3,4,5&#125;,一个对象，自动把第二个1去掉。 let set = new Set([\"hdcms\", \"houdunren\"]); // console.log(set.clear()); // console.log(set.delete(\"hdcms.com\")); console.log(set.size); // console.log(set.delete(\"hdcms\")); // console.log(set.size); // console.log(set.values()); //add has // console.log(set.size); // console.log(set.has(\"hdcms.com\")); // let set = new Set([...\"hdcms\"]); // console.log(set); 对象中的属性名都会被转换成字符串。 常见的语法 add()，添加元素 clear()，清空容器 size()，获取元素个数 keys(),entries,values()，返回的都是容器里的各个值；因为set容器没有键，只有值，或者说键与值是一样的 has()，判断是否有元素。数组中用的是includes() 与数组类型之间的相互转换！！！ 12345678910let set = new Set([\"hdcms\", \"houdunren\"]); console.log(Array.from(set));//from方法转换数组 console.log([...set]);//三点展开式转换数组 let hd = new Set(\"123456789\"); console.log(hd);//set hd = new Set([...hd].filter(item =&gt; item &lt; 5));//转换为数组，使用数组的filter方法，并返回一个数组，并将这数组又转换为set类型 console.log(hd);//set类型 let array = [1, 2, 3, 4, 5, 2, 3, 1]; array = [...new Set(array)];//去重了 console.log(array);//去重后的数组 多多利用类型之间的转换。 常用例子！！并集，交集，差集的实现！ 核心三点展开式，以及filter过滤函数与includes函数的联合使用 123456789101112let a=new Set([1,2,3,4,5]) let b=new Set([9,5,2,7]) //并集 console.log(new Set([...a,...b]))//将a与b先装为数组合并，在将合并后的数组转为set（自动去重） //交集 console.log([...a].filter((value =&gt; &#123; return [...b].includes(value)//返回b.has(value)，[2, 5]，返回共有的。 &#125;))) //差集，过滤掉b有的元素 console.log([...a].filter((value =&gt; &#123; return ![...b].includes(value)//返回!b.has(value)，[1, 3, 4]，返回不是公有的 &#125;))) 2，WeakSet类型与Set类型一样，里面的值是不重复的；但是WeakSet容器中只能放引用类型，以数组传参！方法和Set类型一致。 WeakSet的弱引用特性是，WeakSet不会使得应用类型的次数增加。 1234567 let hd = &#123; name: \"后盾人\" &#125;;//引用次数1 let edu = hd;//引用次数2 let set = new WeakSet();//依然是2,如果是arr=[hd],会使得引用次数增加为3 set.add(hd); hd = null;//1 edu = null;//0console.log(set)//No properties Weakset无法使用for-in与for-of循环遍历方法，也没有获取数量方法keys()方法。被屏蔽掉了。 3，Set的实现虽然ES6原生支持了Set类，是Javascript原生Api的一部分，但可以基于其提供的方法来实现自己的Set类。 细节：使用对象而不是数组来保存元素，只有这样才能实现【值，值】的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//集合function Set()&#123; //属性 this.items=&#123;&#125;//用对象存储封装，对象值的覆盖 //方法 //1,添加 Set.prototype.add=function(value)&#123; if(this.has(value))&#123;//如果有值返回失败，其实如果不判断，不影响唯一性。 return false &#125; this.items[value]=value//键值合一，也保证了元素的唯一性。因为一样的值会进行覆盖 return true &#125; //2，判断 Set.prototype.has=function(value)&#123; return this.items.hasOwnProperty(value)//这是对象判断属性的方法，hasOwnProperty() &#125; //3，remove Set.prototype.remove=function(value)&#123; if(!this.has(value)) return false delete this.items[value]//这是对象删除属性的方法，delete return true &#125; //4，clear Set.prototype.clear=function()&#123; this.items=&#123;&#125;//重新赋值，原对象因为失去引用而被回收 &#125; //5，size Set.prototype.size=function()&#123; return Object.keys(this.items).length//这是对象获取属性数量的语句，keys() &#125; //6，values Set.prototype.values=function()&#123; return Object.values(this.items)//或者Object.keys(this.items)，因为键值合一 &#125; &#125;let set = new Set()console.log(set.add(\"abc\"))//trueconsole.log(set.add(\"abc\"))//falseset.add(\"cba\")set.add(\"nba\")set.add(\"swk\")console.log(set.size())//4console.log(set.remove(\"nba\"))//trueconsole.log(set.remove(\"nba\"))//falseconsole.log(set.values())//(3) [\"abc\", \"cba\", \"swk\"],数组形式返回set.clear()console.log(set.values())//[]let set1 = new","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Set类型","slug":"Set类型","permalink":"https://zhoubb96.github.io/tags/Set%E7%B1%BB%E5%9E%8B/"}]},{"title":"JS-Symbol特性","date":"2020-06-15T08:12:24.000Z","path":"2020/06/15/JS-Symbol特性/","text":"Symbol前缀标识可以唯一标识一个数据，可以理解为永不重复的字符串 两种声明方式 123456789101112131415//方式一，字面量方法，symbol不需要new关键字let a=symbol(\"woshia\")let b=symbol(\"woshib\")console.log(typeof a)//symble//方式二，for方法let c = Symbol.for(\"zbb\");//for方法，系统会记录下这个Symbollet d = Symbol.for(\"zbb\");//第二次会查之前是否已经声明过，如果声明过就直接拿过来。反复使用同一个Symbol的情况console.log(c==d)//trueconsole.log(a==b)//falseconsole.log(Symbol.keyFor(c))//zbbconsole.log(Symbol.keyFor(a))//undefined,只有for方法定义的才能使用keyFor方法console.log(a)//symbol(woshia)console.log(a.toString())//symbol(woshia),toString依然是返回symbol本身console.log(a.description)//woshia，只有description才是返回内部的描述。注意，是a.description而不是a.description，也就是说description是一个数据属性，不是方法属性 使用实例 1234567891011121314 let user1 = &#123; name: \"李四\", key: Symbol()//1 &#125;; let user2 = &#123; name: \"李四\", key: Symbol()//2,就算没有传入参数，1和2也是不相等的 &#125;; let grade = &#123; [user1.key]: &#123; js: 100, css: 89 &#125;,//由于键也是一个变量所以要用[]先取值 [user2.key]: &#123; js: 35, css: 55 &#125; &#125;;//如果不使用symbol，那么同名情况，会被最后一个覆盖 console.log(grade[user2.key]);//&#123; js: 35, css: 55 &#125; Symbol属性是私有属性，无法被for-in或者for-of遍历到S遍历所有属性的方法；for-in与for-of遍历普通属性；getOwnPropertySymbols()遍历Symbol属性；Reflect.ownKeys()遍历所有属性。 12345678910111213let hd = &#123; name: \"李四\", [symbol]: \"lisi\" &#125;; for (const key in hd) &#123; console.log(key);//只有name &#125; for (const key of Object.getOwnPropertySymbols(hd)) &#123; console.log(key);//只有symbol &#125; for (const key of Reflect.ownKeys(hd)) &#123; console.log(key);//所有属性，name与Symbol &#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Symbol类型","slug":"Symbol类型","permalink":"https://zhoubb96.github.io/tags/Symbol%E7%B1%BB%E5%9E%8B/"}]},{"title":"JS数组六","date":"2020-06-14T08:02:45.000Z","path":"2020/06/14/JS数组六/","text":"map映射数组与应用类型处理map(callbacks(value,index,arr))，return的是value。前面那些函数是返回的布尔值，这个函数直接返回值value。返回的也是一个新数组。原数组不会改变，需要定义一个变量接受新数组。引用类型因为传的是地址，如果不写return语句会直接改变原值；普通类型由于是传值的形式，不写return语句也不会改变原值 1234567let arr = [\"zbb\", \"ycy\"]let arr2 = arr.map((value, index) =&gt; &#123; value = value + \"gkd\" return value //这一句在引用类型与非引用类型会产生不同的结果&#125;)console.log(arr)// [\"zbb\", \"ycy\"]console.log(arr2)//[\"zbbgkd\", \"ycygkd\"]","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"map()","slug":"map","permalink":"https://zhoubb96.github.io/tags/map/"}]},{"title":"JS数组五","date":"2020-06-14T07:39:11.000Z","path":"2020/06/14/JS数组五/","text":"过滤函数filter()filter(callbacks(value,index,arr)) 不难发现这些方法都接受一个回调函数，回调函数返回一个布尔值（判断条件），并且，参数列表都是值value在前面。 1234567891011let arr=[\"zbb\",\"ycy\"]// 不定义过滤条件，全返回arr.filter((value,index)=&gt;&#123; console.log(index,value)//0 \"zbb\" 1 \"ycy\"&#125;)let arr1=arr.filter((value,index)=&gt;&#123; return value==\"ycy\"//条为值为ycy才取出&#125;)console.log(arr1)//只返会[\"ycy\"]，注意返回的是数组//上面两个其实只是只用到了value，所以index其实可以不用传入 1234567891011121314 //自定义filter function filter(arr, expect) &#123;//expect是一个数组，两个数组的互相比较 //定义新数组返回过滤后的结果 let newArray = [] for (const value of arr) &#123; if (expect.includes(value) === false) &#123;//如果expect不包含这个元素 newArray.push(value) &#125; &#125; return newArray//返回新数组 &#125;arr=[1,2,3,4,5] arr2=[2,3]console.log(filter(arr,arr2))//[1, 4, 5]","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"filter()","slug":"filter","permalink":"https://zhoubb96.github.io/tags/filter/"}]},{"title":"JS数组四","date":"2020-06-14T07:03:45.000Z","path":"2020/06/14/JS数组四/","text":"利用every()与some()进行数组判断every(callbacks(value,index,arr))，回调函数返回一个布尔值。全部为真才为真 123456let arr=[\"zbb\",\"ycy\"]arr.every((value,index)=&gt;&#123; console.log(index,value)//0 \"zbb\" 1 \"ycy\"，是个数组 return true//如果不return true就会只执行一次 //有一个为假就为假，可以用来进行同一判断，也就是return后面放一个表达式&#125;) some(callbacks(value,index,arr))，回调函数函数返回一个布尔值。任何一个为真就为真 1234arr.some((value,index)=&gt;&#123; console.log(index,value)//如果不加return true就会输出，0 \"zbb\" 1 \"ycy\" return true//加上return true就只执行一次，和上面反过来的&#125;) 因为不加return语句，默认返回undefined，被转化为false，所以every()第一次执行后便停止，false不再执行； 而some()遇到false不会停止。 every遇false停止 some遇到true停止 1234567891011let keywords = [\"php\", \"js\"]; let title = document.querySelector('[name=\"title\"]'); title.addEventListener(\"keyup\", function() &#123;//绑定事件 const res = keywords.some(keyword =&gt; &#123;//遍历取出keyword进行比较 return this.value.indexOf(keyword) != -1; //检查keyup事件输入的值value中是否有关键字数组keywords中的任何一个关键字keyword &#125;); document.querySelector(\"span\").innerHTML = res ? \"\" : \"必须包含\" + keywords.join(\",\") + \"关键词\"; &#125;);","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"every(),some()","slug":"every-some","permalink":"https://zhoubb96.github.io/tags/every-some/"}]},{"title":"数据结构与算法-双向链表","date":"2020-06-13T13:47:14.000Z","path":"2020/06/13/数据结构与算法-双向链表/","text":"单向链表存在一个明显的缺点：返回前一个节点是非常困难的。 引入双向链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175 function DoublyLinkedList() &#123; //链表属性 this.length = 0 this.header = null this.tail = null function Node(data) &#123; //节点属性 this.data = data this.prev = null this.next = null &#125; //1，在尾部添加元素 DoublyLinkedList.prototype.append = function (data) &#123; let node = new Node(data) //链表为空 if (this.length === 0) &#123; this.header = node//成为第一个节点 this.tail = node//同时也是最后一个节点，最后一个节点不用找 &#125; else &#123; this.tail.next = node node.prev = this.tail this.tail = node &#125; this.length++ &#125; //2,toString,从前向后 DoublyLinkedList.prototype.toString = function () &#123; //this直接调用向后方法 return this.backwardString() &#125; //3，backwardString从前向后 DoublyLinkedList.prototype.backwardString = function () &#123; let current = this.header let resultString = \"\" while (current) &#123; resultString += current.data + \" \" current = current.next &#125; return resultString &#125; //4，forwardString从后向前 DoublyLinkedList.prototype.forwardString = function () &#123; let current = this.tail let resultString = \"\" while (current) &#123; resultString += current.data + \" \" current = current.prev &#125; return resultString &#125; //5,insert在指定位置插入元素 DoublyLinkedList.prototype.insert = function (position, data) &#123; let node = new Node(data) let current = this.header if (position &lt; 0 || position &gt; this.length) &#123; return false &#125; if (this.length === 0)//先判断链表是否为空，再判断位置 &#123; this.header = node this.toString = node &#125; else &#123; if (position === 0) &#123;//头部添加 node.next = this.header this.header.prev = node this.header = node &#125; else if (position === this.length) &#123;//尾部添加 node.prev = this.tail this.tail.next = node this.tail = node &#125; else &#123;//中间添加,位置到下标，要减去一 for (let index = 1; index &lt; position; index++) &#123; current = current.next &#125; current.next.prev = node node.next = current.next node.prev = current current.next = node &#125; &#125; this.length++ &#125; //6.get，查找，可以用二分查找法改进。 DoublyLinkedList.prototype.get = function (position) &#123; if (position &lt;= 0 || position &gt; this.length) return null let current = this.header for (let index = 1; index &lt; position; index++) &#123; current = current.next &#125; return current.data &#125; //7，indexOf获取指定元素的位置 DoublyLinkedList.prototype.indexOf = function(data)&#123; current=this.header let index=1 while(current!=null&amp;&amp;current.data!=data)&#123; current=current.next index++ &#125; if(current!=null) return index return -1 &#125; //7，update方法，更新指定位置的元素 DoublyLinkedList.prototype.update = function (position,data) &#123; if (position &lt;= 0 || position &gt; this.length) return false let current = this.header for (let index = 1; index &lt; position; index++) &#123; current = current.next &#125; current.data=data &#125; //8,removeAt移除指定位置元素 DoublyLinkedList.prototype.removAt = function (position) &#123; if (position &lt;= 0 || position &gt; this.length) return null let current=this.header if(this.length===0) return false//空链表 if(this.length===1)&#123;//只有一个元素 this.header = null this.tail = null &#125; //长度大于1 if(position===1)&#123;//移除第一个 this.header.next.prev=null //this.header.next=null这句可以不写，因为上面那句会是的被删除节点失去引用被自动回收 this.header=this.header.next &#125;else if(position===this.length)&#123;//移除最后一个 current=this.tail this.tail.prev.next=null this.tail=this.tail.prev &#125;else&#123; for (let index=1;index&lt;position;index++)&#123;//移除中间的 current=current.next &#125; current.prev.next=current.next current.next.prev=current.prev &#125; this.length-- return current.data &#125; //9,remove移除定位置的元素，两个方法相互调用 DoublyLinkedList.prototype.remove = function(data)&#123; //先获取位置 let position=this.indexOf(data) //删除指定位置 this.removAt(position) &#125; &#125; //测试 let list = new DoublyLinkedList() list.append(\"abc\") list.append(\"cba\") list.append(\"nba\") list.append(\"swk\") list.insert(0, \"开头\") list.insert(5, \"结尾\") list.insert(3, \"中间\") console.log(list)//DoublyLinkedList &#123;length: 7, header: Node, tail: Node&#125; console.log(list.toString())//开头 abc cba 中间 nba swk 结尾 console.log(list.forwardString())//结尾 swk nba 中间 cba abc 开头 console.log(list.get(1)) //开头 console.log(list.get(7)) //结尾 list.update(1,\"这是开头\") list.update(7,\"这是结尾\") console.log(list.removAt(7))//这是结尾 console.log(list.toString())//这是开头 abc cba 中间 nba swk console.log(list)//DoublyLinkedList &#123;length: 6, header: Node, tail: Node&#125; console.log(list.indexOf(\"这是开头\"))//1 list.remove(\"中间\") console.log(list.toString())//这是开头 abc cba nba swk//用position表示读取位置从1到this.length//用position表示插入位置从0到this.length","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS数组三","date":"2020-06-13T09:43:17.000Z","path":"2020/06/13/JS数组三/","text":"关于sort()方法 接受的是一个函数，返回排序后的数组 123456let arr=[9,5,2,7]let result = arr.sort(function (a,b) &#123;//return a-b//返回负数从小到大，[2, 5, 7, 9]//return b-a//返回正数从大到小，[9, 7, 5, 2]&#125;)console.log(result) 1234567891011121314151617181920let arr=[9,5,2,7]//定义sort，冒泡实现，动态的（反复调用callback）function sort(arr,callback) &#123; for (const n in arr) &#123; for (const m in arr) &#123; //一个很奇怪的排序，单纯看返回值，每次都会调用 if (callback(arr[n], arr[m]) &lt; 0) &#123;//接受实参，返回一个数（正或者负）,这个callback会被反复调用，每次都判断 let temp = arr[n] arr[n] = arr[m] arr[m] = temp &#125; &#125; &#125; return arr&#125;//调用sortlet result = sort(arr,function (a,b) &#123;//两个形参要在调用时接受实参 return b-a &#125;)console.log(result) 关于reduce()方法reduce(callbacks(pre,cur,index,arr),init)，它会存储上一次运行的结果作为下一次运行的第一个参数。pre一开始是第一个值，后面就是上次函数运行的结果，cur从第二个值开始。最终返回所有元素运行后的结果。可用作统计用途（统计器，累加器，最大值等等，利用其保存上一次运行结果的特点） 12345678910111213141516171819202122232425262728293031 let arr = [1, 2, 3, 4, 5, 6] let res = arr.reduce((pre, cur) =&gt; &#123; console.log(pre)//1,3,6,10,15,21 console.log(cur)//2,3,4,5,6 return pre + cur &#125;) console.log(res)//21 let res2=arr.reduce((pre, cur) =&gt; &#123; console.log(pre)//0,1,3,6,10,15,21，pre有初始值后，pre和cur的位置都会前移 console.log(cur)//1,2,3,4,5,6 return pre + cur &#125;,0)//0是prev的初始值，如果这里是1，那么最后结果会变成22 console.log(res2)//21 //获取价格超过1万元商品的名称，当然filter更加方便。let cart = [ &#123; name: \"iphone\", price: 12000 &#125;, &#123; name: \"imac\", price: 25000 &#125;, &#123; name: \"ipad\", price: 3600 &#125; ]; function getNameByPrice(goods, price) &#123; return goods .reduce(function(arr, cur) &#123; if (cur.price &gt; price) arr.push(cur); return arr; &#125;, [])//令arr的初值为一个数组，初值的类型可以有很多种。 .map(function(item) &#123; return item.name; &#125;);//链式调用 &#125; console.table(getNameByPrice(cart, 10000)); reduce非常好用，要多用!!!!!!!!!!! includes与reduce联合使用在去重的时候很常用。 经典问题，如果没有要求自己写排序，那么直接调用内部提供的排序生成一个100W的数组，随机打乱，再排序 1234567891011121314151617181920212223242526272829303132 function solution() &#123; let arr = shengcen(100) arr = daruan(arr) //用自带的sort排序 arr = arr.sort((a, b) =&gt; a - b) console.log(arr) &#125; solution()//调用 //数组生成 function shengcen(num) &#123; let arr = [] for (let i = 0; i &lt; num * 10000; i++) &#123; arr[i] = i + 1 &#125; return arr &#125; //数组打乱 function daruan(arr) &#123; let max = arr.length for (let i = 0; i &lt; max - 1; i++) &#123;//减去1是因为random是闭区间的。因为只需要交换n-1次。n个数交换n-1次。 let j = i + Math.floor(Math.random() * (max - i));//j是随机数 [arr[i], arr[j]] = [arr[j], arr[i]]//随机互换 &#125; return arr &#125;//打乱还有一个利用随机排序的打乱function daruan2(arr)&#123; return arr.sort(()=&gt;Math.random()-0.5)//不要传递参数&#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"sort(),reduce()","slug":"sort-reduce","permalink":"https://zhoubb96.github.io/tags/sort-reduce/"}]},{"title":"JS数组二","date":"2020-06-13T09:00:45.000Z","path":"2020/06/13/JS数组二/","text":"旧的查找方法indexOf()，lastIndexof()，includes()，这几个方法数组和字符串都有查找操作且接口一样，但是查找的内容是要严格输入的！ 1234let arr=[1,2,3,4,5,\"6\"]console.log(arr.indexOf(2))//1console.log(arr.indexOf(6))//-1，没有数字6，查找失败console.log(arr.indexOf(\"6\"))//5，字符串\"6”的下标为5 新的查找方法find()与findIndex() find(callback(value)),find()内部参数是个回调函数，需要你自定义，而且返回的是值，解决引用类型查找，因为引用类型查找的是地址。 findIndex(callback(value)),findIndex()同样也是接受一个函数，和find()一致，不同的是它返回的是位置 1234567arr.find(function (item) &#123;//console.log(item)//所有值全1 2 3 4 5 6//return true//1返回第一个// return item==2//返回值2// return item==200//undefined，没有200这个值 &#125;) 123456789101112131415//自己实现一个find，接受一个数组和一个回调函数function find(array,callback)&#123; for(let value of array)&#123; if(callback(value))&#123;//接受实参，回调函数返回true，查找成功 return value &#125; &#125; return undefined&#125;//调用result=find(arr,function(item)&#123;return item===2&#125;)//打印console.log(result)//2","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"find(),findIndex()","slug":"find-findIndex","permalink":"https://zhoubb96.github.io/tags/find-findIndex/"}]},{"title":"移动端适配四","date":"2020-06-13T02:30:13.000Z","path":"2020/06/13/移动端适配四/","text":"位置获取 clientX：当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等），鼠标相对于浏览器（这里说的是浏览器的可视区域）x轴的位置； screenX：当鼠标事件发生时，鼠标相对于显示器屏幕x轴的位置； offsetX：当鼠标事件发生时，鼠标相对于事件源x轴的位置，注意判断正负 高度获取 clientHeight：只包括padding高度。 offsetHeight：包括padding、border、水平滚动条的高度、但不包括margin的元素的高度。 scrollHeight：当本元素的子元素比本元素高且overflow=scroll时，本元素会scroll，这时：scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。 关于移动端的定位 移动端要少用固定定位，因为固定定位是相对于是扣的，而移动端有三个视口，较为复杂。使用绝对定位模拟固定定位。 1，禁止系统滚动条s 2，让应用的滚动条出现在顶层元素，顶层不会影响初始滑块的位置 C:\\Users\\zhoub\\AppData\\Roaming\\npm\\lessc $FileParentDir(less)$\\less$FileDirPathFromParent(less)$$FileName$ C:\\Atguigu\\尚硅谷无视频版本\\8.前端学科–项目实战\\尚硅谷前端项目【谷粒音乐】教程\\code\\QQ音乐\\css\\lesss","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"数据结构与算法-单向链表","date":"2020-06-12T12:37:31.000Z","path":"2020/06/12/数据结构与算法-单向链表/","text":"链表1，数组的缺点： 必须申请连续的储存空间 在开头以及中间插入数据要进行大量的元素移动 链表可以很好的解决这两个问题。链表可以充分利用计算机储存空间，并且在插入和删除数据的时候要方便一些，不用移动元素（寻找插入位置时要费劲些，但是比移动元素开销少）时间复杂度可以达到o(1) 2，链表也有它的缺点: 访问查询时总得从头开始访问 无法通过下标直接访问元素，要遍历判断循环找。 链表有带头结点与不带头指针两种。今后自己统以用带头指针的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function LinkedList() &#123; function Node(data) &#123; this.data = data this.next = null &#125; //属性：头指针，当前指针，长度 this.header = null this.length = 0//注意实时更新 //1,append追加方法，在尾部添加元素 LinkedList.prototype.append = function (data) &#123; let newNode = new Node(data) //是第一个元素，直接修改头指针 if (this.length===0) &#123;//if (this.header===null) this.header = newNode &#125; else &#123; let current = this.header //不是第一个元素，循环找到最后一个节点 while (current.next)&#123;//直到他的next为空，就是最后一个 current = current.next &#125; current.next = newNode &#125; //更新长度 this.length++ &#125; //2,insert在指定位置添加元素 LinkedList.prototype.insert = function(position,data)&#123; //边界判断 if(position&lt;0||position&gt;this.length)&#123;//可以等于 return false &#125; let newNode = new Node(data) let current = this.header //在头部添加 if(position===0)&#123; newNode.next=this.header this.header=newNode &#125;else &#123; //不是在头部,所以i从1开始 for (let i=1;i&lt;position;i++)&#123; current = current.next &#125; newNode.next = current.next current.next = newNode &#125; this.length++//更新长度 return true &#125; //3，将链表转换为字符串返回 LinkedList.prototype.toString = function()&#123; let current = this.header let listString = \"\" //循环获取节点 while (current)&#123; listString+=current.data+\" \" current=current.next &#125; return listString &#125; //4，获取指定下标的元素 LinkedList.prototype.get = function(index)&#123; if(index&lt;0||index&gt;=this.length)&#123; return null &#125; let current = this.header for(let i=0;i&lt;index;i++)&#123; current=current.next &#125; return current.data &#125; //5，获取元素的索引 LinkedList.prototype.indexOf = function(data)&#123; let current = this.header for(let index=0;index&lt;this.length;index++)&#123; if(current.data===data)&#123; return index &#125; current=current.next &#125; return -1 &#125; //6，删除指定位置的元素 LinkedList.prototype.removeAt = function(position)&#123; //越界判断多次会用到，可以抽离出来成一个函数 if(position&lt;0||position&gt;=this.length)&#123; return false &#125; let current = this.header let previous = null if(position===0)&#123; this.header=current.next &#125;else&#123; for(let i=0;i&lt;position;i++)&#123; previous = current current=current.next &#125; previous.next=current.next &#125; this.length-- return current.data &#125; &#125; //测试let list=new LinkedList()list.append('abc')list.append('cba')list.append('nba')list.insert(3,'swk')console.log(list)console.log(list.toString())//abc cba nba swkconsole.log(list.get(3))//swkconsole.log(list.indexOf('swk'))//3list.removeAt(2)console.log(list.toString())//abc cba swk","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS日期相关","date":"2020-06-12T09:08:14.000Z","path":"2020/06/12/JS日期相关/","text":"1，时间与时间戳获取1234567891011121314151617let date = new Date()//可传参，不传参就是当前时间 console.log(date);//date为对象 console.log(date.getFullYearh()) console.log(date.getMonth()+1) console.log(date.getDate()) console.log(date.getHours()) console.log(date.getMinutes()) console.log(date.getSeconds()) console.log(date*1)//返回时间戳，可以用来计算运行时间//可以封装一个函数使用模板字符串输出格式化的日期let date2 = Date() console.log(date2);//date2为字符串 console.log(date2*1)//返回NaN//标签配合使用console.time(\"for\")console.timeEnd(\"for\") 2，时间与时间戳的相互转换123456789//时间-&gt;时间戳console.log(date.valueOf())console.log(date*1)console.log(Number(date))console.log(date.getTime())timestamp = date*1//时间戳-&gt;时间date3 = new Date(timestamp)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS基本类型的类型转换","date":"2020-06-12T08:16:23.000Z","path":"2020/06/12/JS基本类型的类型转换/","text":"1，数值类型基本转换 NaN指不是一个数字，NaN不能互相比较（NaN==NaN无结果） 使用Number.isNaN()判断 使用Object.is(2/&quot;1&quot;, NaN)判断 toString() Number()，一般从键盘获取的都是字符串要先转换。或者用parseInteresting() 2，布尔值隐式转换 数值类型除了0，都为真 字符串类型除了空串，都为真 引用类型永远为真（不管对象或者数组是不是空） 3, 数学方法Math.max/min/ceil/floor/round/random 最大，最小，向上取整，取整，四舍五入，随机数区间为（0，1）。 初见apply数组传参的优点 123grade &#x3D; [119,64,69,138]console.log(Math.max(grade))&#x2F;&#x2F;报错，因为Math.max()只支持多参数传参，不支持数组console.log(Math.max.apply(null,grade))&#x2F;&#x2F;apply可以以数组传参数","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"数据结构与算法-优先级队列","date":"2020-06-11T13:30:37.000Z","path":"2020/06/11/数据结构与算法-优先级队列/","text":"优先级队列 普通的队列插入一个元素，该元素位于最后端，在前面的数据都处理完后才会处理后插入的数据。 优先级队列在插入时会考虑该数据的优先级（在普通队列添加一个属性存储优先级） 在处理时根据优先级决定处理顺序，也就是根据优先级调整插入数据的位置 两个问题：1，元素多了一个优先级属性，这就需要用对象封装；2，入队时要比较插入位置 优先级队列数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 //优先级队列数组实现 function PriorityQueue()&#123; function QueueElement(element,priority)&#123; this.element=element this.priority=priority &#125; //封装属性（对象数组） this.items = [] //1,入队，根据优先级入队 PriorityQueue.prototype.enqueue = function(element,priority)&#123; //获取原先队列长度 length=this.items.length //创建队列元素 var queuelement=new QueueElement(element,priority) //原队列无元素就直接插入 if(length==0)&#123; this.items.push(queuelement) &#125;else&#123; //原队列有元素，1，在原队列间插入；2，在原队列后面追加 var insert = false //这里只能获取到已有位置，如果在最后插入获取不到位置,就不能解决在尾部插入的问题 for(let i=0;i&lt;length;i++)&#123; //比较各个元素的优先级，寻找插入位置(规定数字越小优先级越高)（比较对象的属性值） if(queuelement.priority&lt;this.items[i].priority)&#123; insert = true //1，在原队列间插入 this.items.splice(i,0,queuelement)//这一条是最简做法，直接插入移动全全完成 break &#125; &#125; //2，在原队列后面追加 if(!insert)&#123; this.items.push(queuelement) &#125; &#125; &#125; //2，出队，前面出队 PriorityQueue.prototype.dequeue = function()&#123; return this.items.shift() &#125; //其他操作和栈一样了 PriorityQueue.prototype.size = function()&#123; return this.items.length &#125; PriorityQueue.prototype.front = function () &#123; return this.items[0] &#125; &#125;//验证 let pq = new PriorityQueue() pq.enqueue('abc',111) pq.enqueue('cba',200) pq.enqueue('nba',50) pq.enqueue('nba',66) console.log(pq)","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS字符串与Number-高级操作","date":"2020-06-11T10:03:52.000Z","path":"2020/06/11/JS字符串与Number-高级操作/","text":"1,截取操作substring(beg,end), 起始位置与结束位置，不支持负数 slice(beg,end),起始位置与结束位置，支持负数 substr(beg,len),起始位置与截取长度。 这三个都不会改变原字符串 12345let name = \"Zhoubinbin\" console.log(name.slice(1,3))//ho;起始与结束位置，输入负数则起始位置从后算。 console.log(name.slice(-3,-1))//bi console.log(name.substring(1,3))//ho；同上，只是不可以使用负数（输入负数当0看待） console.log(name.substr(1,3))//hou；起始位置可以用负数与截取长度 2,检索操作indexOf()，lastIndexOf() 123456let name &#x3D; &quot;Zhoubinbin&quot; console.log(name.indexOf(&quot;i&quot;))&#x2F;&#x2F;5；从头开始，返回字符“i”第一次出现的下标 console.log(name.indexOf(&quot;i&quot;,6))&#x2F;&#x2F;8；6表示从什么位置开始查找，忽略前面 console.log(name.includes(&quot;i&quot;))&#x2F;&#x2F;true；返回布尔值 console.log(name.includes(&quot;i&quot;,9))&#x2F;&#x2F;false console.log(name.lastIndexOf(&quot;i&quot;))&#x2F;&#x2F;8;从后开始查找 3,替换操作stringObject.replace(regexp/substr,replacement) 12let name = \"Zhoubinbin\" console.log(name.replace('i','o'))//Zhoubonbin只改了第一个i，如果要全部替换必须使用正则表达式 4,拆分和拼接操作","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"substring(),slice(),substr()","slug":"substring-slice-substr","permalink":"https://zhoubb96.github.io/tags/substring-slice-substr/"}]},{"title":"JS字符串与Number-基本操作.md","date":"2020-06-11T09:30:46.000Z","path":"2020/06/11/JS字符串与Number-基本操作/","text":"字符串的常见操作有 length，长度 toUpperCase(), toLowerCase(),大小写转换 trim()，去除所有空格 字符串拼串 可以直接用+号（如果不做类型转换+默认是拼串，所以要做数学运算的的话要转换类型1，乘一个1就自动转换；2，Number（str）方法） contact方法。（join是数组的方法）, 123456789 let name = \" Zhoubinbin \" console.log(name.length)//12 console.log(name.toUpperCase()) ZHOUBINBIN console.log(name.toLowerCase()) zhoubinbin console.log(name.trim().length)//10const string = \"99\" console.log(string+1)//991 console.log(string*1+1)//100 console.log(Number(string)+1)//100 字符串的拆分 split(&quot;str&quot;) 用字符串中的某个符号str拆分一个字符串，将拆分结果放入一个数组，返回这个数组。如果不传str，仅仅是split(&quot;&quot;)那就是逐个字符拆开。返回的是一个数组 123 let name = \"Zhoubinbin,yangchengyu\" console.log(name.split(\"\"))// [\"Z\", \"h\", \"o\", \"u\", \"b\", \"i\", \"n\", \"b\", \"i\", \"n\", \",\", \"y\", \"a\", \"n\", \"g\", \"c\", \"h\", \"e\", \"n\", \"g\", \"y\", \"u\"]不传参全部单个拆分console.log(name.split(\",\"))//[\"Zhoubinbin\", \"yangchengyu\"]按逗号拆分为两个 Number相关的常用操作123456789var num=1.6 console.log(parseInt(num))//1；可以解析字符串，把字符串开头的整提取出来，舍弃掉其他字符，返回一个整数 console.log(Math.floor(num))//1；返回小于等于num的最大整数，向下取整console.log(Math.round(num))//2；四舍五入console.log(Math.ceil(num))//2;向上取整 console.log(parseFloat(num))//1.6；可以解析字符串，把字符串开头的浮点数取出来，舍弃掉其他字符，返回一个浮点数 console.log(Math.fround(num))//1.600000023841858单精度浮点数console.log(Number.isInteger(num))//flaseconsole.log(num.toFixed(2))//1.60","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS-for-in与for-of的使用","date":"2020-06-11T06:58:03.000Z","path":"2020/06/11/JS-for-in与for-of的使用/","text":"1，forEach定义两个形参接受值与键，同时遍历。注意，forEach第一个参数是值（value）在前！ forEach((value,index)=&gt;{}) 2，for-in（数组与对象都能用）数组遍历的是数组下标；对象遍历的是键 for(let index in arr) for(let key in arr) 3，for-of（原生对象不能使用）for(let value of arr) for(let iterator of obj) 也就是值必须是可迭代的才能正确使用。 遍历的是值，且这个值是重新开辟出来的形参（基本类型和引用类型会有不同结果）；原生对象不能使用 123456789101112131415161718192021222324252627282930313233343536let arr = [ &#123;tittle:\"第一章\", lesson: 1&#125;, &#123;tittle:\"第二章\", lesson: 2&#125;, &#123;tittle:\"第三章\", lesson: 3&#125; ]//1，forEach arr.forEach((value,index)=&gt;&#123; console.log(index)//返回下标0，1，2 console.log(value)//返回对象 &#125;)//2，for-in与for-of //对数组使用 //arr[0],,arr[2] //for-in for(let i in arr)&#123; console.log(i)//返回结果是0,1,2 console.log(arr[i])//返回的是对象 &#125; //for-of for(let i of arr)&#123; console.log(i)//返回是对象 console.log(arr.indexOf(i))//0,1,2 &#125; // 对第一个对象arr[0]使用 //for-in for(let i in arr[0])&#123; console.log(i)//返回的是tittle和lesson，也就是键 console.log(arr[0][i])//返回的是第一章和1，也就是值 &#125; //for-of，会直接报错a[0]不可以迭代 for(let i of arr[0])&#123; console.log(i) console.log(arr[0][i]) &#125; 总结：就是数组的话for-in与for-of都可以用，对象不能使用for-of。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS控制结构","date":"2020-06-11T06:15:01.000Z","path":"2020/06/11/JS控制结构/","text":"控制结构本身很容易，难点在于灵活使用它们设计解决算法问题1.条件控制结构有1，if和else；2，三元表达式；3switch这三种。在js当中switch语句中的case后面是可以加判断语句的 2.循环控制结构1，while循环；2，dowhile循环；3，for循环 建议在不确定循环次数的时候使用while循环。 dowhile循环，见名知意do会直接先执行一次，然后才到while的判断里面。 使用循环的时候思考，1，要用几个循环以及每个循环用来干什么？；2，不同层数循环变量之间有没有关系？；3，循环的终止条件 break-continue与label标签的的使用 break会退出整个循环 continue只会跳过循环的本次执行（所以要注意continue的位置） label跳转（go to语句） 1234567891011//初始化计数器（很多时候都要使用到计数器，注意利用好计数器）let count = 0for(let i=1;i&lt;10;i++)&#123; //只取偶数 if(i%2)&#123; //只要前三个 if(count++==3) break continue &#125; console.log(i)&#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"移动端适配三","date":"2020-06-11T01:07:17.000Z","path":"2020/06/11/移动端适配三/","text":"1，三个触屏列表 changedTouches：触发当前事件的手指列表（变化的），用的最多 targetTouches：触发当前事件时元素上的手指列表 touches：触发事件时，屏幕上的手指列表 2，四个常见问题 禁止电话与邮件的默认行为，&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no email=no&quot;&gt;；如果要重新开启可以考虑加一个a标签。 链接高亮，解决方法时添加-webkit-tap-highlight-color:rgba(0,0,0,0),也就是将高亮背景变为透明色 解决按钮圆角默认为圆，解决方法设置-webkit-appearance:none font boosting，浏览器自动放大字体。解决方法是添加最大高度max-height:xxpx 3，关于querySelector与getElementBy…的性能与差异getElementBy…的性能好很多，而且返回的是动态列表的；querySelector性能差些，而且返回的是静态列表，但是querySelector用起来方便。最后推荐多用更优秀的getElementBy…养成习惯","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"数据结构与算法-队列","date":"2020-06-10T14:03:09.000Z","path":"2020/06/10/数据结构与算法-队列/","text":"1，队列的实现因为队列的特点是先进先出，在头front出队尾rear入队进行操作，所以利用数组实现队列就用shift与push，操作头部与尾部数据 12345678910111213141516171819202122232425//数组构造队列function Queue() &#123; this.items = [] //1,入队，后面入队 Queue.prototype.enqueue = function (element) &#123; this.items.push(element) &#125; //2，出队，前面出队 Queue.prototype.dequeue = function () &#123; return this.items.shift() &#125; //其他操作和栈一样了 //3，size方法 Queue.prototype.size = function () &#123; return this.items.length &#125; //4，front方法 Queue.prototype.front = function () &#123; return this.items[0] &#125; //5，是否为空 Queue.prototype.isEmpty = function () &#123; return this.items.length == 0 &#125;&#125; 编程题，利用队列（链表）解决击鼓传花，报数出列或者叫约瑟夫环问题，利用队列的话，边界判断就容易很多。（三种解法，数组（易于理解），循环链表（要构造链表），递归（形式最为简洁）） 123456789101112131415161718192021222324252627//报数变量（1到5）、标记值（5）和累加变量（1—），报数变量在到达标记值的时候重新赋值，再用累加变量对标记值取余数得到队列的下标 function passgame(nameList,tag)&#123; //1,创建队列 var queue = new Queue() //2，初始入队 for(let i=0;i&lt;nameList.length;i++)&#123; queue.enqueue(nameList[i]) &#125; //3,报数开始 while(queue.size()&gt;1)&#123;//不知道具体循环次数时用while //此时不是tag，重新加入加入队列 for (let i = 1; i &lt; tag; i++) &#123;//报数从1开始，或者用0到tag-1也行。 queue.enqueue(queue.dequeue())//将取出的元素重新入列 &#125; //此时是tag时，将其从队列删除 queue.dequeue() &#125; var endName = queue.front() alert(endName) return nameList.indeOf(endName)//上面的操作没有操作namelist而是操作的queue，最后找到剩下的元素在原先列表的位置 &#125; names=['Lily','Lucy','Tom','Lilei','Tomi'] passgame(names,3)//测试用例//数组方法，如果是数组方法，不想修改原数组的话，要再建立一个数组来进行操作（因为这个操作的数组最后只有一个元素下标必然为0，要利用它的值在原数组里找下标，如果只要返回值那么一个数组就够了）//递归方法","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-栈","date":"2020-06-10T08:20:09.000Z","path":"2020/06/10/数据结构与算法-栈/","text":"1，JS的数组结构，可以直接调用API（编程题考察的一般都是数组，所以JS基础最重要，数组的操作需要进行十分熟练） 数组的插入和删除是比较麻烦，原因是需要不断的移动数据。但是，数组通过下标查询以及修改元素的时候，效率是很高的。 除了数组，其他的结构都是自己构造出来的，一般是利用对象加指针进行实现。（比如树就是递归出来的） 2，栈结构（是要自己实现的？） 因为栈的特点是先进后出，且进出都在一个位置操作，那么基于数组实现就是只操作数组尾部数据，也就是push与pop（那么队列就是unshift与pop或者shift与push） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//基于数组实现栈，外部是栈，内部是数组&lt;script&gt; //栈的封装实现,利用数组的push和pop，始终都在数组尾部进行操作（就符合了栈的特性） function Stack()&#123; //属性 this.items = [] //操作 //1，压栈，尾部添加 Stack.prototype.push = function(element)&#123;//需要传参，下面的不用 this.items.push(element) &#125; //2，弹栈，尾部删除 Stack.prototype.pop = function()&#123; return this.items.pop() &#125; //3，查看栈顶，用下标查询最后一个元素 Stack.prototype.peak = function()&#123; return this.items[this.items.length-1] &#125; //4,判断是否为空，利用数组长度进行判断 Stack.prototype.isEmpty = function()&#123; return this.items.length==0 &#125; //5，获取栈的长度，也就是数组的长度 Stack.prototype.size = function()&#123; return this.items.length &#125; //6，转换为字符串，遍历+拼串 Stack.prototype.toString = function()&#123; var resultString = ' '//设置一个初始空字符串 for(let i =0;i&lt;this.items.length;i++)&#123; resultString += this.items[i] + ' '//拼串1 2 3 4以空格分开了 &#125; return resultString &#125; &#125; var s = new Stack() s.push(1) s.push(2) s.push(3) s.push(4) s.pop() console.log(s) console.log(s.isEmpty()) console.log(s.peak()) console.log(s.toString()) &lt;/script&gt;//基于链表实现（二级考试题中出现过的） 利用栈可以进制的转换。(依次相除将所得结果依次压栈，最后出栈后就是结果)，当然利用数组也可以，只是输出的时候要手动调整顺序 1234567891011121314151617181920212223//利用栈的进制转换函数//设置两个变量用来存储商和余数，余数压栈，商继续做除法，一直到商为0 function dec2bin(decNumber)&#123; //1，创建栈对象用以存储 var stack = new Stack //2，循环操作 while(decNumber &gt; 0)&#123; element = decNumber % 2 stack.push(element)//可以直接优化为一句stack.push(decNumber%2) //decNumber = decNumber/2 ；重新赋值,这里如果这样写会出错，因为有小数点 //必须用数学方法Math.floor和parseInt都是返回小于等于x的最大整数: decNumber = Math.floor(decNumber/2) &#125; //3，取出栈中元素并以字符传形式返回 var binaryString = ''//空字符串 while(!stack.isEmpty())&#123; binaryString += stack.pop()//1010，没有和上面一样添加空格分隔 &#125; return binaryString &#125; alert(dec2bin(10))//当然可以做到任意进制互换，这时候就需要传入多个参数","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS-Object静态方法与逻辑运算符","date":"2020-06-10T06:30:33.000Z","path":"2020/06/10/JS-Object静态方法与逻辑运算符/","text":"1，Object静态方法一般情况下，常量对象的内部值也是可以改变的。 12345const HOST = &#123; url: \"https://zhoubb96.github.io/\" port: 443&#125;HOST.port = 80//此时可以修改，类似于指针常量指针不可变但是里面的内容可变。 如果同时要禁止对内容得修改，就用到了Object的静态方法 12Object.freeze(HOST)HOST.post = 80 //这条语句不生效，但是在非严格模式不会报错。 2，传值（基本量）与传地址（较大的空间）在JS中，一般变量都是传值。而对象则是传地址，原因是对象（引用类型）所占空间比较大，重新开辟空间资源消耗太大。如果想传值就需要深拷贝。 3，关于null与undefined一个变量在声明而又没有赋值的时候，就会出现null与undefined这两个概念。 如果变量是引用类型，显示null（空对象，null有值，且值为空） 如果变量是基本类型，显示undefined（无值） 4，使用严格模式提高代码质量严格模式是向下约束（自身作用域与子作用域） 1，在没有声明变量的时候提示 2，在同一作用域重复声明的时候提示（主要是var，let等不开严格模式也会提示） 3，在占用系统关键词的时候提示 5，有特色的逻辑运算符(或和与在非布尔值运算时会返回原值)非！ 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 或|| 可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则： 见true返原值, 巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为true，则返回第一个***原值*** ​ 2.如果第一个值为false，则返回第二个***原值*** 12let a = 0||5;//a最后的值为5let b = -5||0;//b的值-5 与&amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则：见flase返原值，巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为false，则返回第一个***原值*** ​ 2.如果第一个值为true，则返回第二个***原值*** 12let a = 0&amp;&amp;5;//a最后的值为0let b = -5&amp;&amp;0;//b的值-0","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS变量回顾","date":"2020-06-10T01:30:33.000Z","path":"2020/06/10/JS变量回顾/","text":"编程语言的工作1，合适的数据结构存储数据 2，合适的算法管理数据 也就是经典的等式：程序=数据结构+算法 变量的声明与赋值1，声明开辟空间（一般会有个初始值），同一作用域一般只声明一次（var例外，会覆盖）；不同的作用域可以声明同名变量，不受影响 2，赋值放入指定内容（支持连续等号赋值） Js弱类型，变量的类型由值决定 变量提升（用let！）使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值（undefined）。所以我们可以在变量声明前使用变量（作用）。但是不使用var关键字声明的变量（成为全局变量）不会被声明提前。 1，变量提升不影响内部变量与外部变量的私有特性。 2，但是如果不写var，变量又会变成全局变量，污染全局。 3，var有函数作用域，但是没有块作用域（for循环里的i会影响到外面的i），在此之前一般都是使用立即执行函数来解决无块作用域产生的作用域污染问题；后面出现了let。 4，同一作用域下var重复声明变量不会提醒（会直接覆盖），而let会报错（只能声明一次）。 全局变量保存在window对象里（全局上下文对象） 函数提升使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数（作用），但是使用函数表达式(var fun = function(){})创建的函数没有该特性，变量提升优先级高于函数提升。 函数作用域内的变量保存对应的函数上下文对象里 尽量避免变量提升，尽量利用函数提升。 注意！！！如果在预解析阶段出错，那么整体是不会开始执行的，直接报错","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"移动端适配二","date":"2020-06-09T01:19:33.000Z","path":"2020/06/09/移动端适配二/","text":"1，一物理像素问题问题描述让1个px单位始终只占据1个物理像素。（通过尺缩比抵消像素比的放大，做到始终1比1） 实现一，整体的rem适配（适合项目比较大情况，一劳永逸）就是在rem适配（只管rem单位）下，依然保持px单位的显示效果；（主体）响应式布局rem（放大再缩小）+（px）变换缩放（缩小） 1234567891011121314151617#test&#123; width: 16rem; height: 1px; margin-top: 1rem; background: black;&#125;(function()&#123; var dpr &#x3D; window.devicePixelRatio||1; var styleNode &#x3D; document.createElement(&quot;style&quot;); var w &#x3D; document.documentElement.clientWidth*dpr&#x2F;16;&#x2F;&#x2F;rem放大dpr倍 styleNode.innerHTML&#x3D;&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;; document.head.appendChild(styleNode); var scale &#x3D; 1&#x2F;dpr;&#x2F;&#x2F;缩回dpr倍（抵消所有以rem为单位的，但是px会被缩小dpr倍，因为一开始px未参与放大） var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;&quot;+scale;&#125;)() 实现二，局部的CSS3方法（再指定的地方适配）配合伪元素123456789101112@media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125;&#125;#test:before&#123; position:absolute;//子绝父相 content:''; display:block; width:100%; height:1px;&#125; 2，移动端事件基础12var item = document.querySelectorAll(\".item\")：专门利用css选择器选择dom，返回静态列表。css也是domvar item = document.getElementByClassName(\"item\");可以用任何选择器，返回动态列表 2.1 触屏事件touchstart–&gt; mousedown touchmove –&gt;mousemove touchend–&gt; mouseup 绑定事件（有3种方法，1，直接在HTML标签里绑定；2，利用Dom绑定；3，利用事件监听器） 123item.addEventListener(\"touchstart\",function()&#123; console.log(\"touchstart\")&#125;)//利用事件监听器来绑定事件。 阻止事件默认行为（调试的时候最终看真机，模拟器和真机的可阻止性不一样） 12345item.addEventListener(\"touchstart\",function(ev)&#123; ev = ev||event console.log(ev.cancelable)//查看事件的默认行为是否可以阻止 ev.preventDefault()//加括号调用&#125;)//利用事件监听器阻止事件默认行为,这里只是阻止了item的默认行为，如果要阻止全体的那么item换成document 在指定区域阻止鼠标右键行为，其他区域不阻止 12345678910111213window.onload = function()&#123; document.oncontextmenu = function()&#123; return false &#125;//禁止了全局，全局无右键菜单 var warp = document.querySelectorAll(\"#warp\") warp.oncontextmenu = function(ev)&#123; ev = ev||event ev.stopPropagation()//ev.cancleBubble，阻止了冒泡，此处无法冒泡到全局的禁止。所以此处wrap的右键菜单依然生效 &#125; //阻止一个元素的默认行为与冒泡有关系。先全禁止，在想开放的地方阻止冒泡。&#125; 移动端模板 1，meta标签 1&lt;meta name=\"viewport\" content=\"width=device-width,inital-scale=1.0,minmum-scale=1.0,maximum-scale=1.0\" /&gt; 2，全面阻止事件默认行为 隐患：页面的所有滚动条失效 需要自定义滚动条。 3，适配方案 123456;(function(flag)&#123;var styleNode = document.creatElement(\"style\")var w = document.documentElement.clientWidth/flagstyleNode.innerHtml = \"html&#123;font-size: \"+w+\" px!important&#125;\"document.head.iappendChild(estyleNode)&#125;)(16)//每个iife之前要用;隔开 2.2 移动端事件的点透1，pc端事件可以在移动端触发 2，pc端事件没有延迟 3，移动端事件有300ms延迟 并列元素重叠，会阻挡你事件的触发（父子元素因为存在冒泡所以不影响）。如果取消阻挡层，就可以重新触发事件。但是一次操作会触发两个动作（取消阻挡层并且触发被阻挡层的默认行为）。因为事件延迟的存在。 2.3 事件的误触因为滑动操作也是要先触发点击touchstart才行，所以滑动操作会误触点击操作。解决方法是在触摸操作结束时对操作的类型进行判断，决定是否调用点击操作。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;a href=\"http://www.bing.com\"&gt;必应&lt;/a&gt;&lt;/body&gt; &lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; //阻止事件默认行为 document.addEventListener(\"touchstart\",function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(\"a\");//定义变量储存列表 for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(\"touchstart\",function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(\"touchmove\",function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(\"touchend\",function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125; &#125; &lt;/script&gt;","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端适配一","date":"2020-06-09T01:09:01.000Z","path":"2020/06/09/移动端适配一/","text":"适配的意义在不同设备上实现等比例显示 相对单位em是相对字体大小来计算的，谷歌下1fontsize一般是16像素，所以此时1em=16pxrem相对于根元素的字体大小来计算的，根元素是html，计算方法同上vw 相对于视口宽度进行计算的，100vw=一个视口宽度。 1vw=视口宽度/100Vh 相对于视口高度进行计算，计算方法同上 适配方法 rem适配—原理 改变一个元素在不同设备上的css像素的个数 ，元素所占的css像素个数是变的，每个css像素面积不变 —实现 12345#test&#123; width: 8rem; height: 1rem; background: pink;&#125; 第一步 创建style标签第二三步 将根标签的font-size置为布局视口的宽/16第四步 将style标签添加到head中 123456(function()&#123; var styleNode &#x3D; document.createElement(&quot;style&quot;);&#x2F;&#x2F;创建style标签节点 var w &#x3D; document.documentElement.clientWidth&#x2F;16;&#x2F;&#x2F;计算fontsize，这里获取了布局视口宽度 styleNode.innerHTML &#x3D; &quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;;&#x2F;&#x2F;在style里设置html中的fontsize ocument.head.appendChild(styleNode);&#x2F;&#x2F;把标签节点插入到head标签里 &#125;)() —优缺点优点：可以使用完美视口（没有改变缩放系数）缺点：px到rem的转化特别麻烦（每次都要自己算） viewport适配将所有设备布局视口宽度设置为设计图宽度,方法是调整系统缩放倍数 12345#test&#123; width: 320px; height: 100px; background: pink;&#125; 将所有设备的布局视口的宽置为设计图的宽度第一步 定义设计图的宽度第二步 确定系统缩放比例第三步 选中viewport标签，改变其content值 123456(function()&#123; var targetW &#x3D; 640; var scale &#x3D; document.documentElement.clientWidth&#x2F;targetW; var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;initial-scale&#x3D;&quot;+scale+&quot;,minimum-scale&#x3D;&quot;+scale+&quot;,maximum-scale&#x3D;&quot;+scale+&quot;,user-scalable&#x3D;no&quot;; &#125;)() –原理： 改变一个css像素与物理像素的比例。viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的，但是css像素和物理像素的比例是不一样的，也就是css的面积是变得。 –优缺点： 优点:所量即所得（只算一次） 缺点:没有使用完美视口（改变了缩放系数，不为1了）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端基础概念","date":"2020-06-08T08:32:47.000Z","path":"2020/06/08/移动端基础概念/","text":"APP的三种类型 web app，使用html5，需要向服务器请求资源，性能较慢但是现在有了提升，开发快，成本低，更新迭代快，会是将来的主流。 native app，原生应用，资源在本地，性能高。安卓使用java语言，ios使用objectC 混合app，结合性能与开发速度 关于适配的相关概念1. 屏幕 屏幕尺寸：屏幕对角线的长度，单位为英寸，1英寸=2.54厘米。 屏幕分辨率：屏幕的两个方向物理像素点数，单位px，1px=1像素点。1080*1920 屏幕密度：每英寸物理像素的个数 2. 像素 位图像素：图像的最小单位。一个位图像素对应一个物理像素就能完美清晰的展示（失真，锐化） 物理像素（设备像素）：设备呈现的最小单位，固定的。但是不同设备的一个物理像占据屏幕尺寸可能不一样，这就引出了等比的适配问题，现在屏幕分辨率高，所以物理像素多就导致了物理像素小。iphone6的物理像素为750px 设备独立像素（屏幕设备）：可以由程序员使用的虚拟像素，设备对接css像素的接口，只有css像素与设备独立像素挂钩width=device-width,（没有这句话，像素比是无效的）像素比才有其真正的作用。一般会让css像素等于这个设备独立像素。iphone6的物理像素为375px css像素：一个抽象单位，最终转换为物理像素（通过让css像素等于设备独立像素,然后利用像素比转换）。用来度量web页面的内容，web开发的最小单位 。一个css像素最终占据多少个物理像素由屏幕特性以及用户的缩放行为决定决定，在像素比为2的屏幕一个css像素占据四个物理像素， 像素比：物理像素/设备独立像素 （是设备固有的特性） iPhone6的像素比为750/375=2，像素比是单个方向的，这里是切图要注意的以一个3018的图片为例子，在像素比为1屏幕的就是30x18下，在像素比为2的屏幕就是60x36，这样就能完美显示。像素比获取命令： 1var dpr = window.devicePixelRatio||2 //如果不能自动获取，那其实我们知道为2 3. 视口（视口宽度用的都是css像素，所以逻辑上是可变的）3.1布局视口（决定网页布局）在PC端上，布局视口的宽度就等于浏览器窗口的宽度。而在移动端上，如果要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，那么布局视口需要大于移动设备的屏幕。Js获取布局视口尺寸的命令： 1document.documentElement.clientWidth | document.body.clientWidth 布局视口的出现，在极大程度上帮助了桌面网站到移动设备上的转移。iphone6的布局视口是980css像素 3.2 视觉视口（决定用户可视内容）滚动条由视觉窗口决定。Js获取视觉视口的命令： 1window.innerWidth； 一个css像素占据的物理像素的数量和视觉视口有很大关系，因为一个视觉视口包含的物理像素是固定的，但是包含的css像素个数会被缩放操作所影响，这个css像素个数就是视口宽度。视觉视口的初始值一般等于屏幕设备（设备独立像素）。iphone6的视觉视口初始值为375css像素。 3.3 理想视口（布局视口的一个状态）理想视口：布局视口的一个理想尺寸，只有当布局视口和屏幕设备一样宽（也就是和初始视觉视口一样大），才是理想视口。Js获取理想视口（屏幕宽度）的命令： 1window.screen.width 加入name为viewport的meta标签后理想视口才会出现（因为只有这个标签才能设置布局视口） 1&lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; 语句width=device-widthi（布局视口（css像素）=屏幕设备（设备独立像素））使得css像素与设备独立像素联系起来（开启像素比，因为像素比的定义和css像素没关系，加上这句话就联系上了css像素）这句话让布局视口的宽度等于了独立设备像素的宽度。不写这句话默认布局视口宽度就为980，写了变375。此时布局视口与视觉视口保持一致，布局视口成为理想视口。但是在理想视口下，如果元素过大，视觉视口会自动地尽量地包住你的内容（此时缩放比例不再为1），就会出现虽然元素超出了视觉视口但是不出现滚动条的现象，这个问题需要用完美视口解决。 3.4 完美视口（布局视口的一个状态）缩放比例为1的理想视口就成为完美视口 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"/&gt; 用来解决太大的元素超过出视觉窗口不出现滚动条的问题，width=device-width,initial-scale=1.0,如果这两者冲突的话，布局视口取两者间的较大值，只有这两个操作才能改变布局视口。注意，缩放比（系统缩放）是基于理想视口（分子）计算的var scale = document.documentElement.clientWidth/targetW;目标大那么尺缩比小于1，缩小目标；目标小那么尺缩比大于1，放大目标（所以width=device-width写在前面，先创造出理想视口，再计算）改变的是布局视口和视觉视口 4. 缩放操作（操作css像素）操作的类型 放大，放大css像素的面积，css像素占据更多的物理像素，能放下的css像素变少，视口尺寸变小 缩小，缩小css像素的面积，css像素占据更小的物理像素，能放下的css像素变多，视口尺寸变大 操作的对象 用户的操作PC端 影响布局视口移动端 影响视觉视口 系统操作（meta标签里的缩放）同时影响布局视口和视觉视口 5. 等比问题 没有加name为viewport的meta标签（一般布局视口）一个相同css像素大小的区域在不同的设备是等比例缩放的，能完整显示网页，在不同的设备上占据的实际物理大小（英寸）不一样 加name为viewport的meta标签 （理想布局视口）一个相同css像素大小的区域在不同的设备是不等比的，不能完整显示网页，在不同的设备上占据的实际物理大小（英寸）是一样的 等比是不是一个必须的需要？要求：在文字要完美清晰的展示的同时，还要做到百分百还原设计图（也是就是要等比）。 虽然不加mtae标签就已经等比了，但是这种会使得网页在移动端的字体变得很小 （做不到文字要完美清晰的展示） 要两者都做到那就得分两步。 1，展示清晰文字—-&gt; 必须加meta标签（不等比）2，恢复其他元素的等比—&gt; 适配！！！！（加上meta标签后也得等比）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"windows下在node环境利用hexo搭载个人博客","date":"2020-06-08T04:44:40.000Z","path":"2020/06/08/windows下在node环境利用hexo搭载个人博客/","text":"一，Git的下载与身份配置 安装Git，下载地址是：https://git-scm.com/ ,可以找速度快的淘宝镜像，下载后安装 使用命令 1git config --global user.name&quot;xxx&quot; 配置用户名 使用命令 1git config --global user.email &quot;xxx@xxx.com&quot; 配置邮箱 二，node的下载 安装Nodejs，下载地址是：https://nodejs.org/ 通过命令1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org 设置淘宝源，通过命令npm config get registry来检查是否配置成功 通过命令1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 安装cnpm，安装后就可以通过 cnpm install xxx来使用cnpm了。 三，hexo框架的下载与使用 全局安装hexo框架，1npm install hexo-cli –g 在任意一个位置创建一个文件夹来存放你的blog项目，在此文件夹下打开终端，输入 hexo init 初始化博客项目 创建文章，hexo n &quot;我的第一篇博客&quot; 安装部署插件，1cnpm install --save hexo-deployer-git 四，博客的预览与部署 下载主题，1git clone git:&#x2F;&#x2F;github.com&#x2F;tommy351&#x2F;hexo-theme-light.git themes&#x2F;light 下载后在_config.yml切换主题1theme: light 本地预览运行，hexo server（可用简写hexo s） 生成静态网页，hexo generate（可用简写hexo g） 新建一个仓库用来部署网页，仓库命名要求为你的昵称如：zhoubb96.github.io复制这个仓库的地址填到deploy的设置repo中修改_config.yml 1234deploy: type: &#39;git&#39; repo: https:&#x2F;&#x2F;github.com&#x2F;zhoubb96&#x2F;zhoubb96.github.io.git branch: masterd 部署到远端，hexo deploy（可用简写hexo d） 每次更新都要重新生成与上传。 许多个性化的设置需要在主题目录或者主目录下的_config.yml进行修改。","comments":true,"tags":[{"name":"博客搭载","slug":"博客搭载","permalink":"https://zhoubb96.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E8%BD%BD/"}]}]