[{"title":"数据结构与算法-双向链表","date":"2020-06-13T13:47:14.000Z","path":"2020/06/13/数据结构与算法-双向链表/","text":"单向链表存在一个明显的缺点：返回前一个节点是非常困难的。 引入双向链表","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS数组三","date":"2020-06-13T09:43:17.000Z","path":"2020/06/13/JS数组三/","text":"关于sort()方法 接受的是一个函数，返回排序后的数组 123456let arr=[9,5,2,7]let result = arr.sort(function (a,b) &#123;//return a-b//返回负数从小到大，[2, 5, 7, 9]//return b-a//返回正数从大到小，[9, 7, 5, 2]&#125;)console.log(result) 1234567891011121314151617181920let arr=[9,5,2,7]//定义sort，冒泡实现，动态的（反复调用callback）function sort(arr,callback) &#123; for (const n in arr) &#123; for (const m in arr) &#123; //一个很奇怪的排序，单纯看返回值，每次都会调用 if (callback(arr[n], arr[m]) &lt; 0) &#123;//接受实参，返回一个数（正或者负）,这个callback会被反复调用，每次都判断 let temp = arr[n] arr[n] = arr[m] arr[m] = temp &#125; &#125; &#125; return arr&#125;//调用sortlet result = sort(arr,function (a,b) &#123;//两个形参要在调用时接受实参 return b-a &#125;)console.log(result)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"sort(),reduce()","slug":"sort-reduce","permalink":"https://zhoubb96.github.io/tags/sort-reduce/"}]},{"title":"JS数组二","date":"2020-06-13T09:00:45.000Z","path":"2020/06/13/JS数组二/","text":"旧的查找方法indexOf()，lastIndexof()，includes()，这几个方法数组和字符串都有查找操作且接口一样，但是查找的内容是要严格输入的！ 1234let arr=[1,2,3,4,5,\"6\"]console.log(arr.indexOf(2))//1console.log(arr.indexOf(6))//-1，没有数字6，查找失败console.log(arr.indexOf(\"6\"))//5，字符串\"6”的下标为5 新的查找方法find()与findIndex() find()内部参数是个函数，需要你自定义，而且返回的是值，解决引用类型查找，因为引用类型查找的是地址。 findIndex()同样也是接受一个函数，和find()一致，不同的是它返回的是位置 1234567arr.find(function (item) &#123;//console.log(item)//所有值全1 2 3 4 5 6//return true//1返回第一个// return item==2//返回值2// return item==200//undefined，没有200这个值 &#125;) 123456789101112131415//自己实现一个find，接受一个数组和一个回调函数function find(array,callback)&#123; for(let value of array)&#123; if(callback(value))&#123;//接受实参，回调函数返回true，查找成功 return value &#125; &#125; return undefined&#125;//调用result=find(arr,function(item)&#123;return item===2&#125;)//打印console.log(result)//2","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"find(),findIndex()","slug":"find-findIndex","permalink":"https://zhoubb96.github.io/tags/find-findIndex/"}]},{"title":"移动端适配案例一","date":"2020-06-13T02:30:13.000Z","path":"2020/06/13/移动端适配案例一/","text":"位置获取 clientX：当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等），鼠标相对于浏览器（这里说的是浏览器的可视区域）x轴的位置； screenX：当鼠标事件发生时，鼠标相对于显示器屏幕x轴的位置； offsetX：当鼠标事件发生时，鼠标相对于事件源x轴的位置，注意判断正负 高度获取 clientHeight：只包括padding高度。 offsetHeight：包括padding、border、水平滚动条的高度、但不包括margin的元素的高度。 scrollHeight：当本元素的子元素比本元素高且overflow=scroll时，本元素会scroll，这时：scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"数据结构与算法-单向链表","date":"2020-06-12T12:37:31.000Z","path":"2020/06/12/数据结构与算法-单向链表/","text":"链表1，与链表相比数组的缺点： 必须申请连续的储存空间 在开头以及中间插入数据要进行大量的位移 链表可以很好的解决这两个问题。链表可以充分利用计算机储存空间，并且在插入和删除数据的时候要方便一些，不用移动元素（寻找插入位置时要费劲些，但是比移动元素开销少）时间复杂度可以达到o(1) 2，链表也有它的缺点: 访问查询时总得从头开始访问 无法通过下标直接访问元素，要遍历判断循环找。 链表有带头结点与不带头指针两种。今后自己统以用带头指针的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function LinkedList() &#123; function Node(data) &#123; this.data = data this.next = null &#125; //属性：头指针，当前指针，长度 this.header = null this.length = 0//注意实时更新 //1,append追加方法，在尾部添加元素 LinkedList.prototype.append = function (data) &#123; let newNode = new Node(data) //是第一个元素，直接修改头指针 if (this.length===0) &#123;//if (this.header===null) this.header = newNode &#125; else &#123; let current = this.header //不是第一个元素，循环找到最后一个节点 while (current.next)&#123;//直到他的next为空，就是最后一个 current = current.next &#125; current.next = newNode &#125; //更新长度 this.length++ &#125; //2,insert在指定位置添加元素 LinkedList.prototype.insert = function(position,data)&#123; //边界判断 if(position&lt;0||position&gt;this.length)&#123;//可以等于 return false &#125; let newNode = new Node(data) let current = this.header //在头部添加 if(position===0)&#123; newNode.next=this.header this.header=newNode &#125;else &#123; //不是在头部,所以i从1开始 for (let i=1;i&lt;position;i++)&#123; current = current.next &#125; newNode.next = current.next current.next = newNode &#125; this.length++//更新长度 return true &#125; //3，将链表转换为字符串返回 LinkedList.prototype.toString = function()&#123; let current = this.header let listString = \"\" //循环获取节点 while (current)&#123; listString+=current.data+\" \" current=current.next &#125; return listString &#125; //4，获取指定下标的元素 LinkedList.prototype.get = function(index)&#123; if(index&lt;0||index&gt;=this.length)&#123; return null &#125; let current = this.header for(let i=0;i&lt;index;i++)&#123; current=current.next &#125; return current.data &#125; //5，获取元素的索引 LinkedList.prototype.indexOf = function(data)&#123; let current = this.header for(let index=0;index&lt;this.length;index++)&#123; if(current.data===data)&#123; return index &#125; current=current.next &#125; return -1 &#125; //6，删除指定位置的元素 LinkedList.prototype.removeAt = function(position)&#123; //越界判断多次会用到，可以抽离出来成一个函数 if(position&lt;0||position&gt;=this.length)&#123; return false &#125; let current = this.header let previous = null if(position===0)&#123; this.header=current.next &#125;else&#123; for(let i=0;i&lt;position;i++)&#123; previous = current current=current.next &#125; previous.next=current.next &#125; this.length-- return current.data &#125; &#125; //测试let list=new LinkedList()list.append('abc')list.append('cba')list.append('nba')list.insert(3,'swk')console.log(list)console.log(list.toString())//abc cba nba swkconsole.log(list.get(3))//swkconsole.log(list.indexOf('swk'))//3list.removeAt(2)console.log(list.toString())//abc cba swk","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS日期相关","date":"2020-06-12T09:08:14.000Z","path":"2020/06/12/JS日期相关/","text":"1，时间与时间戳获取1234567891011121314151617let date = new Date()//可传参，不传参就是当前时间 console.log(date);//date为对象 console.log(date.getFullYearh()) console.log(date.getMonth()+1) console.log(date.getDate()) console.log(date.getHours()) console.log(date.getMinutes()) console.log(date.getSeconds()) console.log(date*1)//返回时间戳，可以用来计算运行时间//可以封装一个函数使用模板字符串输出格式化的日期let date2 = Date() console.log(date2);//date2为字符串 console.log(date2*1)//返回NaN//标签配合使用console.time(\"for\")console.timeEnd(\"for\") 2，时间与时间戳的相互转换123456789//时间-&gt;时间戳console.log(date.valueOf())console.log(date*1)console.log(Number(date))console.log(date.getTime())timestamp = date*1//时间戳-&gt;时间date3 = new Date(timestamp)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS基本类型的类型转换","date":"2020-06-12T08:16:23.000Z","path":"2020/06/12/JS基本类型的类型转换/","text":"1，数值类型基本转换 NaN指不是一个数字，NaN不能互相比较（NaN==NaN无结果） 使用Number.isNaN()判断 使用Object.is(2/&quot;1&quot;, NaN)判断 toString() Number()，一般从键盘获取的都是字符串要先转换。或者用parseInteresting() 2，布尔值隐式转换 数值类型除了0，都为真 字符串类型除了空串，都为真 引用类型永远为真（不管对象或者数组是不是空） 3, 数学方法Math.max/min/ceil/floor/round/random 最大，最小，向上取整，取整，四舍五入，随机数区间为（0，1）。 初见apply数组传参的优点 123grade &#x3D; [119,64,69,138]console.log(Math.max(grade))&#x2F;&#x2F;报错，因为Math.max()只支持多参数传参，不支持数组console.log(Math.max.apply(null,grade))&#x2F;&#x2F;apply可以以数组传参数","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"数据结构与算法-优先级队列","date":"2020-06-11T13:30:37.000Z","path":"2020/06/11/数据结构与算法-优先级队列/","text":"优先级队列 普通的队列插入一个元素，该元素位于最后端，在前面的数据都处理完后才会处理后插入的数据。 优先级队列在插入时会考虑该数据的优先级（在普通队列添加一个属性存储优先级） 在处理时根据优先级决定处理顺序，也就是根据优先级调整插入数据的位置 两个问题：1，元素多了一个优先级属性，这就需要用对象封装；2，入队时要比较插入位置 优先级队列数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 //优先级队列数组实现 function PriorityQueue()&#123; function QueueElement(element,priority)&#123; this.element=element this.priority=priority &#125; //封装属性（对象数组） this.items = [] //1,入队，根据优先级入队 PriorityQueue.prototype.enqueue = function(element,priority)&#123; //获取原先队列长度 length=this.items.length //创建队列元素 var queuelement=new QueueElement(element,priority) //原队列无元素就直接插入 if(length==0)&#123; this.items.push(queuelement) &#125;else&#123; //原队列有元素，1，在原队列间插入；2，在原队列后面追加 var insert = false //这里只能获取到已有位置，如果在最后插入获取不到位置,就不能解决在尾部插入的问题 for(let i=0;i&lt;length;i++)&#123; //比较各个元素的优先级，寻找插入位置(规定数字越小优先级越高)（比较对象的属性值） if(queuelement.priority&lt;this.items[i].priority)&#123; insert = true //1，在原队列间插入 this.items.splice(i,0,queuelement)//这一条是最简做法，直接插入移动全全完成 break &#125; &#125; //2，在原队列后面追加 if(!insert)&#123; this.items.push(queuelement) &#125; &#125; &#125; //2，出队，前面出队 PriorityQueue.prototype.dequeue = function()&#123; return this.items.shift() &#125; //其他操作和栈一样了 PriorityQueue.prototype.size = function()&#123; return this.items.length &#125; PriorityQueue.prototype.front = function () &#123; return this.items[0] &#125; &#125;//验证 let pq = new PriorityQueue() pq.enqueue('abc',111) pq.enqueue('cba',200) pq.enqueue('nba',50) pq.enqueue('nba',66) console.log(pq)","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS字符串与Number-高级操作","date":"2020-06-11T10:03:52.000Z","path":"2020/06/11/JS字符串与Number-高级操作/","text":"1,截取操作slice(), substring(), substr()。不会改变原字符串 12345let name = \"Zhoubinbin\" console.log(name.slice(1,3))//ho;起始与结束位置，输入负数则起始位置从后算。 console.log(name.slice(-3,-1))//bi console.log(name.substring(1,3))//ho；同上，只是不可以使用负数（输入负数当0看待） console.log(name.substr(1,3))//hou；起始位置可以用负数与截取长度 2,检索操作indexOf()，lastIndexOf() 123456let name &#x3D; &quot;Zhoubinbin&quot; console.log(name.indexOf(&quot;i&quot;))&#x2F;&#x2F;5；从头开始，返回字符“i”第一次出现的下标 console.log(name.indexOf(&quot;i&quot;,6))&#x2F;&#x2F;8；6表示从什么位置开始查找，忽略前面 console.log(name.includes(&quot;i&quot;))&#x2F;&#x2F;true；返回布尔值 console.log(name.includes(&quot;i&quot;,9))&#x2F;&#x2F;false console.log(name.lastIndexOf(&quot;i&quot;))&#x2F;&#x2F;8;从后开始查找 3,替换操作stringObject.replace(regexp/substr,replacement) 12let name = \"Zhoubinbin\" console.log(name.replace('i','o'))//Zhoubonbin只改了第一个i，如果要全部替换必须使用正则表达式 4,拆分和拼接操作","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS字符串与Number-基本操作.md","date":"2020-06-11T09:30:46.000Z","path":"2020/06/11/JS字符串与Number-基本操作/","text":"字符串的常见操作有 length，长度 toUpperCase(), toLowerCase(),大小写转换 trim()，去除所有空格 字符串拼串 可以直接用+号（如果不做类型转换+默认是拼串，所以要做数学运算的的话要转换类型1，乘一个1就自动转换；2，Number（str）方法） contact方法。（join是数组的方法）, 123456789 let name = \" Zhoubinbin \" console.log(name.length)//12 console.log(name.toUpperCase()) ZHOUBINBIN console.log(name.toLowerCase()) zhoubinbin console.log(name.trim().length)//10const string = \"99\" console.log(string+1)//991 console.log(string*1+1)//100 console.log(Number(string)+1)//100 字符串的拆分 split(&quot;str&quot;) 用字符串中的某个符号str拆分一个字符串，将拆分结果放入一个数组，返回这个数组。如果不传str，仅仅是split(&quot;&quot;)那就是逐个字符拆开。返回的是一个数组 123let name = \"Zhoubinbin,yangchengyu\"console.log(name.split(\"\"))// [\"Z\", \"h\", \"o\", \"u\", \"b\", \"i\", \"n\", \"b\", \"i\", \"n\", \",\", \"y\", \"a\", \"n\", \"g\", \"c\", \"h\", \"e\", \"n\", \"g\", \"y\", \"u\"]不传参全部单个拆分console.log(name.split(\",\"))//[\"Zhoubinbin\", \"yangchengyu\"]按逗号拆分为两个 Number相关的常用操作123456789var num=1.6 console.log(parseInt(num))//1；可以解析字符串，把字符串开头的整提取出来，舍弃掉其他字符，返回一个整数 console.log(Math.floor(num))//1；返回小于等于num的最大整数，向下取整console.log(Math.round(num))//2；四舍五入console.log(Math.ceil(num))//2;向上取整 console.log(parseFloat(num))//1.6；可以解析字符串，把字符串开头的浮点数取出来，舍弃掉其他字符，返回一个浮点数 console.log(Math.fround(num))//1.600000023841858单精度浮点数console.log(Number.isInteger(num))//flaseconsole.log(num.toFixed(2))//1.60","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS-for-in与for-of的使用","date":"2020-06-11T06:58:03.000Z","path":"2020/06/11/JS-for-in与for-of的使用/","text":"1，forEach自己定义两个形参接受键与值，同时遍历。注意，forEach第一个参数是值（value）在前！ 2，for-in（数组与对象都能用）数组遍历的是数组下标；对象遍历的是键 3，for-of（原生对象不能使用）遍历的是值；原生对象不能使用 123456789101112131415161718192021222324252627282930313233343536let arr = [ &#123;tittle:\"第一章\", lesson: 1&#125;, &#123;tittle:\"第二章\", lesson: 2&#125;, &#123;tittle:\"第三章\", lesson: 3&#125; ]//1，forEach arr.forEach((value,index)=&gt;&#123; console.log(index)//返回下标0，1，2 console.log(value)//返回对象 &#125;)//2，for-in与for-of //对数组使用 //arr[0],,arr[2] //for-in for(let i in arr)&#123; console.log(i)//返回结果是0,1,2 console.log(arr[i])//返回的是对象 &#125; //for-of for(let i of arr)&#123; console.log(i)//返回是对象 console.log(arr.indexOf(i))//0,1,2 &#125; // 对第一个对象arr[0]使用 //for-in for(let i in arr[0])&#123; console.log(i)//返回的是tittle和lesson，也就是键 console.log(arr[0][i])//返回的是第一章和1，也就是值 &#125; //for-of，会直接报错a[0]不可以迭代 for(let i of arr[0])&#123; console.log(i) console.log(arr[0][i]) &#125; 总结：就是数组的话for-in与for-of都可以用，对象不能使用for-of。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS控制结构","date":"2020-06-11T06:15:01.000Z","path":"2020/06/11/JS控制结构/","text":"控制结构本身很容易，难点在于灵活使用它们设计解决算法问题1.条件控制结构有1，if和else；2，三元表达式；3switch这三种。在js当中switch语句中的case后面是可以加判断语句的 2.循环控制结构1，while循环；2，dowhile循环；3，for循环 建议在不确定循环次数的时候使用while循环。 dowhile循环，见名知意do会直接先执行一次，然后才到while的判断里面。 使用循环的时候思考，1，要用几个循环以及每个循环用来干什么？；2，不同层数循环变量之间有没有关系？；3，循环的终止条件 break-continue与label标签的的使用 break会退出整个循环 continue只会跳过循环的本次执行（所以要注意continue的位置） label跳转（go to语句） 1234567891011//初始化计数器（很多时候都要使用到计数器，注意利用好计数器）let count = 0for(let i=1;i&lt;10;i++)&#123; //只取偶数 if(i%2)&#123; //只要前三个 if(count++==3) break continue &#125; console.log(i)&#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS数组一","date":"2020-06-11T04:18:11.000Z","path":"2020/06/11/JS数组一/","text":"1，typeof与instanceof小知识。typeof不能区分array数组和object对象，对二者操作都会输出object，但是函数是可以区分的。 typeof只会输出【基本类型，Object，函数】 基本类型只有String，Number，Boolean，Null，undefined这五种。 数组不是基本类型，是引用类型；数组是一种数据结构（对数组输出object是因为数据结构是由对象组织的）,而且数组可以直接调用自带API。（C语言中虽然没有类，但有struct结构体，可以模拟类的行为，所以c语言虽然不是面向对象的语言，但是c语言是可以有对象的，就是c语言理论上可以做到面向对象，只是没那么方便） 为此要区分数组（或其他数据结构）与普通对象的区别，可以使用 instanceof，原型链判断。 2，多维数组多维数组就是数组的嵌套，但是一般不这么做，这种情况会用对象来存储以避免嵌套。未赋值的数组元素是undefined（C语言是空） 3，数组操作常用操作 1，数组的创建 123let arr = [6]//字面量let arr = new Array(6)//返回一个长度为6的未赋值的数组let arr = Array.of(6)//创建一个长度为1，且这个元素的值为6 2，数组首尾元素的追加与删除push,pop,unshift,shift 1234567let arr=[1,2,3,\"abc\"]let arr2=[\"cba\",\"nba\"]arr[arr.length]=4arr.push(5)arr.push(...arr2)//可以简化数组的合并arr.pop(\"nba\")console.log(arr)//[1, 2, 3, \"abc\", 4, 5, \"cba\"] 3，单个数组内部元素的连接：join(“str”) 将数组内所有元素用指定字符str连接返回一个字符串，常用空格连接，方便使用trim() 123let arr = [\"zhoubinbin\",\"yangchenyu\"]console.log(arr.join(\"+\"))//zhoubinbin+yangchenyuconsole.log(arr.join(\"|\"))//zhoubinbin|yangchenyu 4，数组的截取，返回的是数组 slice(begin，end)，第二个参数是结束位置，不会修改原数组，不包括结束位置的元素 splice(begin，num，element)，第二个参数是截取的长度，会修改原数组，还可以给数组在截掉的位置添加元素,达到替换的效果。没有第三个参数，是删除；有第三个参数，如果num是0，那就是增加；有第三个参数，如果num不是是0，那就是替换；只有一个参数split(0)表示清空整个数组，只有个一个参数会截取到最后。 12345let arr=[1,2,3,4,5]console.log(arr.slice(1,2))//[2]console.log(arr)//[1,2,3,4,5]console.log(arr.splice(1,2,'cba'))//[2,3]console.log(arr)//[1,\"cba\", 4, 5] 5，两个数组的连接contact(),现在更加常用三点展开语法 1234let arr=[1,2,3,\"abc\"]let arr2=[\"cba\",\"nba\"]arr.contact(arr2)arr.push(...arr2) 4，其他类型转数组 如果想用数组的方法，就需要先转为数组；Array.from(obj)；还有常见的字符串的split(“”)也是转化为一个数组；还有map方法。一般对象的话要有长度属性才可以转换成功；三点展开语法也可以用来转数组。 5，三点展开语法 1234567891011121314151617181920212223 let arr = [\"zbb\",\"ycy\"] let arr2 = [\"ycy\",\"zbb\"] //1，合并数组 arr3=[...arr,...arr2] console.log(arr3)//\"zbb\",\"ycy\",\"ycy\",\"zbb\" //2，用于接受多个参数 function sum(...args)&#123; return args.reduce((s,v)=&gt;&#123; return s+=v &#125;,0) &#125;console.log(sum(1,2))//3console.log(sum(1,2,3))//6 //3，将字符串转化为数组 let str = \"zbb\" console.log(...str)//z b b //const [...arr]=\"str\";console.log(arr) //4，将dom节点变为数组const div = ducument.querySelect(\"div\")console.log([...div])//从Nodelist变成了Array，dom元素转到数组","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"移动端适配三","date":"2020-06-11T01:07:17.000Z","path":"2020/06/11/移动端适配三/","text":"1，三个触屏列表 changedTouches：触发当前事件的手指列表（变化的），用的最多 targetTouches：触发当前事件时元素上的手指列表 touches：触发事件时，屏幕上的手指列表 2，四个常见问题 禁止电话与邮件的默认行为，&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no email=no&quot;&gt;；如果要重新开启可以考虑加一个a标签。 链接高亮，解决方法时添加-webkit-tap-highlight-color:rgba(0,0,0,0),也就是将高亮背景变为透明色 解决按钮圆角默认为圆，解决方法设置-webkit-appearance:none font boosting，浏览器自动放大字体。解决方法是添加最大高度max-height:xxpx 3，关于querySelector与getElementBy…的性能与差异getElementBy…的性能好很多，而且返回的是动态列表的；querySelector性能差些，而且返回的是静态列表，但是querySelector用起来方便。最后推荐多用更优秀的getElementBy…养成习惯","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"数据结构与算法-队列","date":"2020-06-10T14:03:09.000Z","path":"2020/06/10/数据结构与算法-队列/","text":"1，队列的实现因为队列的特点是先进先出，在头front出队尾rear入队进行操作，所以利用数组实现队列就用shift与push，操作头部与尾部数据 12345678910111213141516171819 //数组构造队列function Queue()&#123; this.items = [] //1,入队，后面入队 Queue.prototype.enqueue = function(element)&#123; this.items.push(element) &#125; //2，出队，前面出队 Queue.prototype.dequeue = function()&#123; return this.items.shift() &#125; //其他操作和栈一样了 Queue.prototype.size = function()&#123; return this.items.length &#125; Queue.prototype.front = function () &#123; return this.items[0] &#125; &#125; 编程题，利用队列（链表）解决击鼓传花，报数出列或者叫约瑟夫环问题，利用队列的话，边界判断就容易很多。（三种解法，数组（易于理解），循环链表（要构造链表），递归（形式最为简洁）） 123456789101112131415161718192021222324252627//报数变量（1到5）、标记值（5）和累加变量（1—），报数变量在到达标记值的时候重新赋值，再用累加变量对标记值取余数得到队列的下标 function passgame(nameList,tag)&#123; //1,创建队列 var queue = new Queue() //2，初始入队 for(let i=0;i&lt;nameList.length;i++)&#123; queue.enqueue(nameList[i]) &#125; //3,报数开始 while(queue.size()&gt;1)&#123;//不知道具体循环次数时用while //此时不是tag，重新加入加入队列 for (let i = 1; i &lt; tag; i++) &#123;//报数从1开始，或者用0到tag-1也行。 queue.enqueue(queue.dequeue())//将取出的元素重新入列 &#125; //此时是tag时，将其从队列删除 queue.dequeue() &#125; var endName = queue.front() alert(endName) return nameList.indeOf(endName)//上面的操作没有操作namelist而是操作的queue，最后找到剩下的元素在原先列表的位置 &#125; names=['Lily','Lucy','Tom','Lilei','Tomi'] passgame(names,3)//测试用例//数组方法，如果是数组方法，不想修改原数组的话，要再建立一个数组来进行操作（因为这个操作的数组最后只有一个元素下标必然为0，要利用它的值在原数组里找下标，如果只要返回值那么一个数组就够了）//递归方法","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-栈","date":"2020-06-10T08:20:09.000Z","path":"2020/06/10/数据结构与算法-栈/","text":"1，JS的数组结构，可以直接调用API（编程题考察的一般都是数组，所以JS基础最重要，数组的操作需要进行十分熟练） 数组的插入和删除是比较麻烦，原因是需要不断的移动数据。但是，数组通过下标查询以及修改元素的时候，效率是很高的。 除了数组，其他的结构都是自己构造出来的，一般是利用对象加指针进行实现。（比如树就是递归出来的） 2，栈结构（是要自己实现的？） 因为栈的特点是先进后出，且进出都在一个位置操作，那么基于数组实现就是只操作数组尾部数据，也就是push与pop（那么队列就是unshift与pop或者shift与push） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//基于数组实现栈，外部是栈，内部是数组&lt;script&gt; //栈的封装实现,利用数组的push和pop，始终都在数组尾部进行操作（就符合了栈的特性） function Stack()&#123; //属性 this.items = [] //操作 //1，压栈，尾部添加 Stack.prototype.push = function(element)&#123;//需要传参，下面的不用 this.items.push(element) &#125; //2，弹栈，尾部删除 Stack.prototype.pop = function()&#123; return this.items.pop() &#125; //3，查看栈顶，用下标查询最后一个元素 Stack.prototype.peak = function()&#123; return this.items[this.items.length-1] &#125; //4,判断是否为空，利用数组长度进行判断 Stack.prototype.isEmpty = function()&#123; return this.items.length==0 &#125; //5，获取栈的长度，也就是数组的长度 Stack.prototype.size = function()&#123; return this.items.length &#125; //6，转换为字符串，遍历+拼串 Stack.prototype.toString = function()&#123; var resultString = ' '//设置一个初始空字符串 for(let i =0;i&lt;this.items.length;i++)&#123; resultString += this.items[i] + ' '//拼串1 2 3 4以空格分开了 &#125; return resultString &#125; &#125; var s = new Stack() s.push(1) s.push(2) s.push(3) s.push(4) s.pop() console.log(s) console.log(s.isEmpty()) console.log(s.peak()) console.log(s.toString()) &lt;/script&gt;//基于链表实现（二级考试题中出现过的） 利用栈可以进制的转换。(依次相除将所得结果依次压栈，最后出栈后就是结果)，当然利用数组也可以，只是输出的时候要手动调整顺序 1234567891011121314151617181920212223//利用栈的进制转换函数//设置两个变量用来存储商和余数，余数压栈，商继续做除法，一直到商为0 function dec2bin(decNumber)&#123; //1，创建栈对象用以存储 var stack = new Stack //2，循环操作 while(decNumber &gt; 0)&#123; element = decNumber % 2 stack.push(element)//可以直接优化为一句stack.push(decNumber%2) //decNumber = decNumber/2 ；重新赋值,这里如果这样写会出错，因为有小数点 //必须用数学方法Math.floor和parseInt都是返回小于等于x的最大整数: decNumber = Math.floor(decNumber/2) &#125; //3，取出栈中元素并以字符传形式返回 var binaryString = ''//空字符串 while(!stack.isEmpty())&#123; binaryString += stack.pop()//1010，没有和上面一样添加空格分隔 &#125; return binaryString &#125; alert(dec2bin(10))//当然可以做到任意进制互换，这时候就需要传入多个参数","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS-Object静态方法与逻辑运算符","date":"2020-06-10T06:30:33.000Z","path":"2020/06/10/JS-Object静态方法与逻辑运算符/","text":"1，Object静态方法一般情况下，常量对象的内部值也是可以改变的。 12345const HOST = &#123; url: \"https://zhoubb96.github.io/\" port: 443&#125;HOST.port = 80//此时可以修改，类似于指针常量指针不可变但是里面的内容可变。 如果同时要禁止对内容得修改，就用到了Object的静态方法 12Object.freeze(HOST)HOST.post = 80 //这条语句不生效，但是在非严格模式不会报错。 2，传值（基本量）与传地址（较大的空间）在JS中，一般变量都是传值。而对象则是传地址，原因是对象（引用类型）所占空间比较大，重新开辟空间资源消耗太大。如果想传值就需要深拷贝。 3，关于null与undefined一个变量在声明而又没有赋值的时候，就会出现null与undefined这两个概念。 如果变量是引用类型，显示null（空对象，null有值，且值为空） 如果变量是基本类型，显示undefined（无值） 4，使用严格模式提高代码质量严格模式是向下约束（自身作用域与子作用域） 1，在没有声明变量的时候提示 2，在同一作用域重复声明的时候提示（主要是var，let等不开严格模式也会提示） 3，在占用系统关键词的时候提示 5，有特色的逻辑运算符(或和与在非布尔值运算时会返回原值)非！ 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 或|| 可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则： 见true返原值, 巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为true，则返回第一个***原值*** ​ 2.如果第一个值为false，则返回第二个***原值*** 12let a = 0||5;//a最后的值为5let b = -5||0;//b的值-5 与&amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则：见flase返原值，巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为false，则返回第一个***原值*** ​ 2.如果第一个值为true，则返回第二个***原值*** 12let a = 0&amp;&amp;5;//a最后的值为0let b = -5&amp;&amp;0;//b的值-0","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS变量回顾","date":"2020-06-10T01:30:33.000Z","path":"2020/06/10/JS变量回顾/","text":"编程语言的工作1，合适的数据结构存储数据 2，合适的算法管理数据 也就是经典的等式：程序=数据结构+算法 变量的声明与赋值1，声明开辟空间（一般会有个初始值），同一作用域一般只声明一次（var例外，会覆盖）；不同的作用域可以声明同名变量，不受影响 2，赋值放入指定内容（支持连续等号赋值） Js弱类型，变量的类型由值决定 变量提升（用let！）使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值（undefined）。所以我们可以在变量声明前使用变量（作用）。但是不使用var关键字声明的变量（成为全局变量）不会被声明提前。 1，变量提升不影响内部变量与外部变量的私有特性。 2，但是如果不写var，变量又会变成全局变量，污染全局。 3，var有函数作用域，但是没有块作用域（for循环里的i会影响到外面的i），在此之前一般都是使用立即执行函数来解决无块作用域产生的作用域污染问题；后面出现了let。 4，同一作用域下var重复声明变量不会提醒（会直接覆盖），而let会报错（只能声明一次）。 全局变量保存在window对象里（全局上下文对象） 函数提升使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数（作用），但是使用函数表达式(var fun = function(){})创建的函数没有该特性，变量提升优先级高于函数提升。 函数作用域内的变量保存对应的函数上下文对象里 尽量避免变量提升，尽量利用函数提升。 注意！！！如果在预解析阶段出错，那么整体是不会开始执行的，直接报错","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"移动端适配二","date":"2020-06-09T01:19:33.000Z","path":"2020/06/09/移动端适配二/","text":"1，一物理像素问题问题描述让1个px单位始终只占据1个物理像素。（通过尺缩比抵消像素比的放大，做到始终1比1） 实现一，整体的rem适配（适合项目比较大情况，一劳永逸）就是在rem适配（只管rem单位）下，依然保持px单位的显示效果；（主体）响应式布局rem（放大再缩小）+（px）变换缩放（缩小） 1234567891011121314151617#test&#123; width: 16rem; height: 1px; margin-top: 1rem; background: black;&#125;(function()&#123; var dpr &#x3D; window.devicePixelRatio||1; var styleNode &#x3D; document.createElement(&quot;style&quot;); var w &#x3D; document.documentElement.clientWidth*dpr&#x2F;16;&#x2F;&#x2F;rem放大dpr倍 styleNode.innerHTML&#x3D;&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;; document.head.appendChild(styleNode); var scale &#x3D; 1&#x2F;dpr;&#x2F;&#x2F;缩回dpr倍（抵消所有以rem为单位的，但是px会被缩小dpr倍，因为一开始px未参与放大） var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;&quot;+scale;&#125;)() 实现二，局部的CSS3方法（再指定的地方适配）配合伪元素123456789101112@media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125;&#125;#test:before&#123; position:absolute;//子绝父相 content:''; display:block; width:100%; height:1px;&#125; 2，移动端事件基础12var item = document.querySelectorAll(\".item\")：专门利用css选择器选择dom，返回静态列表。css也是domvar item = document.getElementByClassName(\"item\");可以用任何选择器，返回动态列表 2.1 触屏事件touchstart–&gt; mousedown touchmove –&gt;mousemove touchend–&gt; mouseup 绑定事件（有3种方法，1，直接在HTML标签里绑定；2，利用Dom绑定；3，利用事件监听器） 123item.addEventListener(\"touchstart\",function()&#123; console.log(\"touchstart\")&#125;)//利用事件监听器来绑定事件。 阻止事件默认行为（调试的时候最终看真机，模拟器和真机的可阻止性不一样） 12345item.addEventListener(\"touchstart\",function(ev)&#123; ev = ev||event console.log(ev.cancelable)//查看事件的默认行为是否可以阻止 ev.preventDefault()//加括号调用&#125;)//利用事件监听器阻止事件默认行为,这里只是阻止了item的默认行为，如果要阻止全体的那么item换成document 在指定区域阻止鼠标右键行为，其他区域不阻止 12345678910111213window.onload = function()&#123; document.oncontextmenu = function()&#123; return false &#125;//禁止了全局，全局无右键菜单 var warp = document.querySelectorAll(\"#warp\") warp.oncontextmenu = function(ev)&#123; ev = ev||event ev.stopPropagation()//ev.cancleBubble，阻止了冒泡，此处无法冒泡到全局的禁止。所以此处wrap的右键菜单依然生效 &#125; //阻止一个元素的默认行为与冒泡有关系。先全禁止，在想开放的地方阻止冒泡。&#125; 移动端模板 1，meta标签 1&lt;meta name=\"viewport\" content=\"width=device-width,inital-scale=1.0,minmum-scale=1.0,maximum-scale=1.0\" /&gt; 2，全面阻止事件默认行为 隐患：页面的所有滚动条失效 需要自定义滚动条。 3，适配方案 123456;(function(flag)&#123;var styleNode = document.creatElement(\"style\")var w = document.documentElement.clientWidth/flagstyleNode.innerHtml = \"html&#123;font-size: \"+w+\" px!important&#125;\"document.head.iappendChild(estyleNode)&#125;)(16)//每个iife之前要用;隔开 2.2 移动端事件的点透1，pc端事件可以在移动端触发 2，pc端事件没有延迟 3，移动端事件有300ms延迟 并列元素重叠，会阻挡你事件的触发（父子元素因为存在冒泡所以不影响）。如果取消阻挡层，就可以重新触发事件。但是一次操作会触发两个动作（取消阻挡层并且触发被阻挡层的默认行为）。因为事件延迟的存在。 2.3 事件的误触因为滑动操作也是要先触发点击touchstart才行，所以滑动操作会误触点击操作。解决方法是在触摸操作结束时对操作的类型进行判断，决定是否调用点击操作。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;a href=\"http://www.bing.com\"&gt;必应&lt;/a&gt;&lt;/body&gt; &lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; //阻止事件默认行为 document.addEventListener(\"touchstart\",function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(\"a\");//定义变量储存列表 for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(\"touchstart\",function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(\"touchmove\",function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(\"touchend\",function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125; &#125; &lt;/script&gt;","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端适配一","date":"2020-06-09T01:09:01.000Z","path":"2020/06/09/移动端适配一/","text":"适配的意义在不同设备上实现等比例显示 相对单位em是相对字体大小来计算的，谷歌下1fontsize一般是16像素，所以此时1em=16pxrem相对于根元素的字体大小来计算的，根元素是html，计算方法同上vw 相对于视口宽度进行计算的，100vw=一个视口宽度。 1vw=视口宽度/100Vh 相对于视口高度进行计算，计算方法同上 适配方法 rem适配—原理 改变一个元素在不同设备上的css像素的个数 ，元素所占的css像素个数是变的，每个css像素面积不变 —实现 12345#test&#123; width: 8rem; height: 1rem; background: pink;&#125; 第一步 创建style标签第二三步 将根标签的font-size置为布局视口的宽/16第四步 将style标签添加到head中 123456(function()&#123; var styleNode &#x3D; document.createElement(&quot;style&quot;);&#x2F;&#x2F;创建style标签节点 var w &#x3D; document.documentElement.clientWidth&#x2F;16;&#x2F;&#x2F;计算fontsize，这里获取了布局视口宽度 styleNode.innerHTML &#x3D; &quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;;&#x2F;&#x2F;在style里设置html中的fontsize ocument.head.appendChild(styleNode);&#x2F;&#x2F;把标签节点插入到head标签里 &#125;)() —优缺点优点：可以使用完美视口（没有改变缩放系数）缺点：px到rem的转化特别麻烦（每次都要自己算） viewport适配将所有设备布局视口宽度设置为设计图宽度,方法是调整系统缩放倍数 12345#test&#123; width: 320px; height: 100px; background: pink;&#125; 将所有设备的布局视口的宽置为设计图的宽度第一步 定义设计图的宽度第二步 确定系统缩放比例第三步 选中viewport标签，改变其content值 123456(function()&#123; var targetW &#x3D; 640; var scale &#x3D; document.documentElement.clientWidth&#x2F;targetW; var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;initial-scale&#x3D;&quot;+scale+&quot;,minimum-scale&#x3D;&quot;+scale+&quot;,maximum-scale&#x3D;&quot;+scale+&quot;,user-scalable&#x3D;no&quot;; &#125;)() –原理： 改变一个css像素与物理像素的比例。viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的，但是css像素和物理像素的比例是不一样的，也就是css的面积是变得。 –优缺点： 优点:所量即所得（只算一次） 缺点:没有使用完美视口（改变了缩放系数，不为1了）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端基础概念","date":"2020-06-08T08:32:47.000Z","path":"2020/06/08/移动端基础概念/","text":"APP的三种类型 web app，使用html5，需要向服务器请求资源，性能较慢但是现在有了提升，开发快，成本低，更新迭代快，会是将来的主流。 native app，原生应用，资源在本地，性能高。安卓使用java语言，ios使用objectC 混合app，结合性能与开发速度 关于适配的相关概念1. 屏幕 屏幕尺寸：屏幕对角线的长度，单位为英寸，1英寸=2.54厘米。 屏幕分辨率：屏幕的两个方向物理像素点数，单位px，1px=1像素点。1080*1920 屏幕密度：每英寸物理像素的个数 2. 像素 位图像素：图像的最小单位。一个位图像素对应一个物理像素就能完美清晰的展示（失真，锐化） 物理像素（设备像素）：设备呈现的最小单位，固定的。但是不同设备的一个物理像占据屏幕尺寸可能不一样，这就引出了等比的适配问题，现在屏幕分辨率高，所以物理像素多就导致了物理像素小。iphone6的物理像素为750px 设备独立像素（屏幕设备）：可以由程序员使用的虚拟像素，设备对接css像素的接口，只有css像素与设备独立像素挂钩width=device-width,（没有这句话，像素比是无效的）像素比才有其真正的作用。一般会让css像素等于这个设备独立像素。iphone6的物理像素为375px css像素：一个抽象单位，最终转换为物理像素（通过让css像素等于设备独立像素,然后利用像素比转换）。用来度量web页面的内容，web开发的最小单位 。一个css像素最终占据多少个物理像素由屏幕特性以及用户的缩放行为决定决定，在像素比为2的屏幕一个css像素占据四个物理像素， 像素比：物理像素/设备独立像素 （是设备固有的特性） iPhone6的像素比为750/375=2，像素比是单个方向的，这里是切图要注意的以一个3018的图片为例子，在像素比为1屏幕的就是30x18下，在像素比为2的屏幕就是60x36，这样就能完美显示。像素比获取命令： 1var dpr = window.devicePixelRatio||2 //如果不能自动获取，那其实我们知道为2 3. 视口（视口宽度用的都是css像素，所以逻辑上是可变的）3.1布局视口（决定网页布局）在PC端上，布局视口的宽度就等于浏览器窗口的宽度。而在移动端上，如果要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，那么布局视口需要大于移动设备的屏幕。Js获取布局视口尺寸的命令： 1document.documentElement.clientWidth | document.body.clientWidth 布局视口的出现，在极大程度上帮助了桌面网站到移动设备上的转移。iphone6的布局视口是980css像素 3.2 视觉视口（决定用户可视内容）滚动条由视觉窗口决定。Js获取视觉视口的命令： 1window.innerWidth； 一个css像素占据的物理像素的数量和视觉视口有很大关系，因为一个视觉视口包含的物理像素是固定的，但是包含的css像素个数会被缩放操作所影响，这个css像素个数就是视口宽度。视觉视口的初始值一般等于屏幕设备（设备独立像素）。iphone6的视觉视口初始值为375css像素。 3.3 理想视口（布局视口的一个状态）理想视口：布局视口的一个理想尺寸，只有当布局视口和屏幕设备一样宽（也就是和初始视觉视口一样大），才是理想视口。Js获取理想视口（屏幕宽度）的命令： 1window.screen.width 加入name为viewport的meta标签后理想视口才会出现（因为只有这个标签才能设置布局视口） 1&lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; 语句width=device-widthi（布局视口（css像素）=屏幕设备（设备独立像素））使得css像素与设备独立像素联系起来（开启像素比，因为像素比的定义和css像素没关系，加上这句话就联系上了css像素）这句话让布局视口的宽度等于了独立设备像素的宽度。不写这句话默认布局视口宽度就为980，写了变375。此时布局视口与视觉视口保持一致，布局视口成为理想视口。但是在理想视口下，如果元素过大，视觉视口会自动地尽量地包住你的内容（此时缩放比例不再为1），就会出现虽然元素超出了视觉视口但是不出现滚动条的现象，这个问题需要用完美视口解决。 3.4 完美视口（布局视口的一个状态）缩放比例为1的理想视口就成为完美视口 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"/&gt; 用来解决太大的元素超过出视觉窗口不出现滚动条的问题，width=device-width,initial-scale=1.0,如果这两者冲突的话，布局视口取两者间的较大值，只有这两个操作才能改变布局视口。注意，缩放比（系统缩放）是基于理想视口（分子）计算的var scale = document.documentElement.clientWidth/targetW;目标大那么尺缩比小于1，缩小目标；目标小那么尺缩比大于1，放大目标（所以width=device-width写在前面，先创造出理想视口，再计算）改变的是布局视口和视觉视口 4. 缩放操作（操作css像素）操作的类型 放大，放大css像素的面积，css像素占据更多的物理像素，能放下的css像素变少，视口尺寸变小 缩小，缩小css像素的面积，css像素占据更小的物理像素，能放下的css像素变多，视口尺寸变大 操作的对象 用户的操作PC端 影响布局视口移动端 影响视觉视口 系统操作（meta标签里的缩放）同时影响布局视口和视觉视口 5. 等比问题 没有加name为viewport的meta标签（一般布局视口）一个相同css像素大小的区域在不同的设备是等比例缩放的，能完整显示网页，在不同的设备上占据的实际物理大小（英寸）不一样 加name为viewport的meta标签 （理想布局视口）一个相同css像素大小的区域在不同的设备是不等比的，不能完整显示网页，在不同的设备上占据的实际物理大小（英寸）是一样的 等比是不是一个必须的需要？要求：在文字要完美清晰的展示的同时，还要做到百分百还原设计图（也是就是要等比）。 虽然不加mtae标签就已经等比了，但是这种会使得网页在移动端的字体变得很小 （做不到文字要完美清晰的展示） 要两者都做到那就得分两步。 1，展示清晰文字—-&gt; 必须加meta标签（不等比）2，恢复其他元素的等比—&gt; 适配！！！！（加上meta标签后也得等比）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"windows下在node环境利用hexo搭载个人博客","date":"2020-06-08T04:44:40.000Z","path":"2020/06/08/windows下在node环境利用hexo搭载个人博客/","text":"一，Git的下载与身份配置 安装Git，下载地址是：https://git-scm.com/ ,可以找速度快的淘宝镜像，下载后安装 使用命令 1git config --global user.name&quot;xxx&quot; 配置用户名 使用命令 1git config --global user.email &quot;xxx@xxx.com&quot; 配置邮箱 二，node的下载 安装Nodejs，下载地址是：https://nodejs.org/ 通过命令1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org 设置淘宝源，通过命令npm config get registry来检查是否配置成功 通过命令1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 安装cnpm，安装后就可以通过 cnpm install xxx来使用cnpm了。 三，hexo框架的下载与使用 全局安装hexo框架，1npm install hexo-cli –g 在任意一个位置创建一个文件夹来存放你的blog项目，在此文件夹下打开终端，输入 hexo init 初始化博客项目 创建文章，hexo n &quot;我的第一篇博客&quot; 安装部署插件，1cnpm install --save hexo-deployer-git 四，博客的预览与部署 下载主题，1git clone git:&#x2F;&#x2F;github.com&#x2F;tommy351&#x2F;hexo-theme-light.git themes&#x2F;light 下载后在_config.yml切换主题1theme: light 本地预览运行，hexo server（可用简写hexo s） 生成静态网页，hexo generate（可用简写hexo g） 新建一个仓库用来部署网页，仓库命名要求为你的昵称如：zhoubb96.github.io复制这个仓库的地址填到deploy的设置repo中修改_config.yml 1234deploy: type: &#39;git&#39; repo: https:&#x2F;&#x2F;github.com&#x2F;zhoubb96&#x2F;zhoubb96.github.io.git branch: masterd 部署到远端，hexo deploy（可用简写hexo d） 每次更新都要重新生成与上传。 许多个性化的设置需要在主题目录或者主目录下的_config.yml进行修改。","comments":true,"tags":[{"name":"博客搭载","slug":"博客搭载","permalink":"https://zhoubb96.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E8%BD%BD/"}]}]