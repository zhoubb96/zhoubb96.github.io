[{"title":"数据结构与算法1","date":"2020-06-10T08:20:09.000Z","path":"2020/06/10/数据结构与算法1/","text":"","comments":true,"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"JS查漏补缺一Object静态方法与逻辑运算符","date":"2020-06-10T06:30:33.000Z","path":"2020/06/10/Object静态方法与逻辑运算符/","text":"1，Object静态方法一般情况下，常量对象的内部值也是可以改变的。 12345const HOST = &#123; url: \"https://zhoubb96.github.io/\" port: 443&#125;HOST.port = 80//此时可以修改，类似于指针常量指针不可变但是里面的内容可变。 如果同时要禁止对内容得修改，就用到了Object的静态方法 12Object.freeze(HOST)HOST.post = 80 //这条语句不生效，但是在非严格模式不会报错。 2，传值（基本量）与传地址（较大的空间）在JS中，一般变量都是传值。而对象则是传地址，原因是对象（引用类型）所占空间比较大，重新开辟空间资源消耗太大。如果想传值就需要深拷贝。 3，关于null与undefined一个变量在声明而又没有赋值的时候，就会出现null与undefined这两个概念。 如果变量是引用类型，显示null（空对象，null有值，且值为空） 如果变量是基本类型，显示undefined（无值） 4，使用严格模式提高代码质量严格模式是向下约束（自身作用域与子作用域） 1，在没有声明变量的时候提示 2，在同一作用域重复声明的时候提示（主要是var，let等不开严格模式也会提示） 3，在占用系统关键词的时候提示 5，有特色的逻辑运算符(或和与在非布尔值运算时会返回原值)非！ 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 或|| 可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则： 见true返原值, 巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为true，则返回第一个***原值*** ​ 2.如果第一个值为false，则返回第二个***原值*** 12let a = 0||5;//a最后的值为5let b = -5||0;//b的值-5 与&amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则：见flase返原值，巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为false，则返回第一个***原值*** ​ 2.如果第一个值为true，则返回第二个***原值*** 12let a = 0&amp;&amp;5;//a最后的值为0let b = -5&amp;&amp;0;//b的值-0","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS查漏补缺一变量回顾","date":"2020-06-10T01:30:33.000Z","path":"2020/06/10/变量回顾/","text":"编程语言的工作1，合适的数据结构存储数据 2，合适的算法管理数据 也就是经典的等式：程序=数据结构+算法 变量的声明与赋值1，声明开辟空间（一般会有个初始值），同一作用域一般只声明一次（var例外，会覆盖）；不同的作用域可以声明同名变量，不受影响 2，赋值放入指定内容（支持连续等号赋值） Js弱类型，变量的类型由值决定 变量提升（用let！）使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值（undefined）。所以我们可以在变量声明前使用变量（作用）。但是不使用var关键字声明的变量（成为全局变量）不会被声明提前。 1，变量提升不影响内部变量与外部变量的私有特性。 2，但是如果不写var，变量又会变成全局变量，污染全局。 3，var有函数作用域，但是没有块作用域（for循环里的i会影响到外面的i），在此之前一般都是使用立即执行函数来解决无块作用域产生的作用域污染问题；后面出现了let。 4，同一作用域下var重复声明变量不会提醒（会直接覆盖），而let会报错（只能声明一次）。 全局变量保存在window对象里（全局上下文对象） 函数提升使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数（作用），但是使用函数表达式(var fun = function(){})创建的函数没有该特性，变量提升优先级高于函数提升。 函数作用域内的变量保存对应的函数上下文对象里 尽量避免变量提升，尽量利用函数提升。 注意！！！如果在预解析阶段出错，那么整体是不会开始执行的，直接报错","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"移动端适配二","date":"2020-06-09T01:19:33.000Z","path":"2020/06/09/移动端适配二/","text":"1，一物理像素问题问题描述让1个px单位始终只占据1个物理像素。 实现一，整体的rem适配（适合项目比较大情况，一劳永逸）就是在rem适配（只管rem单位）下，依然保持px单位的显示效果 1234567891011121314151617#test&#123; width: 16rem; height: 1px; margin-top: 1rem; background: black;&#125;(function()&#123; var dpr &#x3D; window.devicePixelRatio||1; var styleNode &#x3D; document.createElement(&quot;style&quot;); var w &#x3D; document.documentElement.clientWidth*dpr&#x2F;16;&#x2F;&#x2F;设置真实大小 styleNode.innerHTML&#x3D;&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;; document.head.appendChild(styleNode); var scale &#x3D; 1&#x2F;dpr;&#x2F;&#x2F;这里设置缩放比是显示效果 var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;&quot;+scale;&#125;)() 实现二，局部的CSS3方法（要指定要适配的地方）1234567891011@media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test&#123; transform: scaleY(.5); &#125;&#125;#test&#123; width: 100%; height:1px ; margin-top: 50px; background: black;&#125; 2，移动端事件基础12var item = document.querySelectorAll(\".item\")：专门利用css选择器选择dom，返回静态列表var item = document.getElementByClassName(\"item\");可以用任何选择器，返回动态列表 2.1 触屏事件touchstart–&gt; mousedown touchmove –&gt;mousemove touchend–&gt; mouseup 绑定事件（有3种方法，1，直接在HTML标签里绑定；2，利用Dom绑定；3，利用事件监听器） 123item.addEventListener(\"touchstart\",function()&#123; console.log(\"touchstart\")&#125;)//利用事件监听器来绑定事件。 阻止事件默认行为（调试的时候最终看真机，模拟器和真机的可阻止性不一样） 12345item.addEventListener(\"touchstart\",function(ev)&#123; ev = ev||event console.log(ev.cancelable)//查看事件的默认行为是否可以阻止 ev.preventDefault()//加括号调用&#125;)//利用事件监听器阻止事件默认行为,这里只是阻止了item的默认行为，如果要阻止全体的那么item换成document 在指定区域阻止鼠标右键行为，其他区域不阻止 12345678910111213window.onload = function()&#123; document.oncontextmenu = function()&#123; return false &#125;//禁止了全局，全局无右键菜单 var warp = document.querySelectorAll(\"#warp\") warp.oncontextmenu = function(ev)&#123; ev = ev||event ev.stopPropagation()//ev.cancleBubble，阻止了冒泡，全局的禁止无法冒泡到这里。所以wrap的右键菜单依然生效 &#125; //阻止一个元素的默认行为与冒泡有关系。先全禁止，在想开放的地方阻止冒泡。&#125; 移动端模板 1，meta标签 1&lt;meta name=\"viewport\" content=\"width=device-width,inital-scale=1.0,minmum-scale=1.0,maximum-scale=1.0\" /&gt; 2，全面阻止事件默认行为 隐患：页面的所有滚动条失效 需要自定义滚动条。 3，适配方案 123456;(function(flag)&#123;var styleNode = document.creatElement(\"style\")var w = document.documentElement.clientWidth/flagstyleNode.innerHtml = \"html&#123;font-size: \"+w+\" px!important&#125;\"document.head.iappendChild(estyleNode)&#125;)(16)//每个iife之前要用;隔开 2.2 移动端事件的点透1，pc端事件可以在移动端触发 2，pc端事件没有延迟 3，移动端事件有300ms延迟 并列元素重叠，会阻挡你事件的触发（父子元素因为存在冒泡所以不影响）。如果取消阻挡层，就可以重新触发事件。但是一次操作会触发两个动作（取消阻挡层并且触发被阻挡层的默认行为）。因为事件延迟的存在。 2.3 事件的误触因为滑动操作也是要先触发点击touchstart才行，所以滑动操作会误触点击操作。解决方法是在触摸操作结束时对操作的类型进行判断，决定是否调用点击操作。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.bing.com&quot;&gt;必应&lt;&#x2F;a&gt;&lt;&#x2F;body&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.onload&#x3D;function()&#123; &#x2F;&#x2F;阻止事件默认行为 document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev&#x3D;ev||event; ev.preventDefault(); &#125;) &#x2F;&#x2F;移动端a标签的跳转方案 解决误触 var aNodes &#x3D; document.querySelectorAll(&quot;a&quot;); for(var i&#x3D;0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(&quot;touchstart&quot;,function()&#123; this.isMoved&#x3D;false; &#125;) aNodes[i].addEventListener(&quot;touchmove&quot;,function()&#123; this.isMoved&#x3D;true; &#125;) aNodes[i].addEventListener(&quot;touchend&quot;,function()&#123; if(!this.isMoved)&#123; location.href&#x3D;this.href; &#125; &#125;) &#125; &#125; &lt;&#x2F;script&gt;","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端适配一","date":"2020-06-09T01:09:01.000Z","path":"2020/06/09/移动端适配一/","text":"适配的意义在不同设备上实现等比例显示 相对单位em是相对字体大小来计算的，谷歌下1fontsize一般是16像素，所以此时1em=16pxrem相对于根元素的字体大小来计算的，根元素是html，计算方法同上vw 相对于视口宽度进行计算的，100vw=一个视口宽度。 1vw=视口宽度/100Vh 相对于视口高度进行计算，计算方法同上 适配方法 rem适配—原理 一个元素在不同设备上的css像素的个数不一样 —实现 12345#test&#123; width: 8rem; height: 1rem; background: pink;&#125; 123456(function()&#123; var styleNode &#x3D; document.createElement(&quot;style&quot;);&#x2F;&#x2F;创建style标签节点 var w &#x3D; document.documentElement.clientWidth&#x2F;16;&#x2F;&#x2F;计算fontsize，这里获取了布局视口宽度 styleNode.innerHTML &#x3D; &quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;;&#x2F;&#x2F;在style里设置html中的fontsize ocument.head.appendChild(styleNode);&#x2F;&#x2F;把标签节点插入到head标签里 &#125;)() —优缺点优点：可以使用完美视口（没有改变缩放系数）缺点：px到rem的转化特别麻烦（每次都要自己算） viewport适配将所有设备布局视口宽度设置为设计图宽度,方法是调整系统缩放倍数 12345#test&#123; width: 320px; height: 100px; background: pink;&#125; 123456(function()&#123; var targetW &#x3D; 640; var scale &#x3D; document.documentElement.clientWidth&#x2F;targetW; var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;initial-scale&#x3D;&quot;+scale+&quot;,minimum-scale&#x3D;&quot;+scale+&quot;,maximum-scale&#x3D;&quot;+scale+&quot;,user-scalable&#x3D;no&quot;; &#125;)() –原理： viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的 –优缺点： 优点:所量即所得（只算一次） 缺点:没有使用完美视口（改变了缩放系数，不为1了）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端基础概念","date":"2020-06-08T08:32:47.000Z","path":"2020/06/08/移动端基础概念/","text":"APP的三种类型 web app，使用html5，需要向服务器请求资源，性能较慢但是现在有了提升，开发快，成本低，更新迭代快，会是将来的主流。 native app，原生应用，资源在本地，性能高。安卓使用java语言，ios使用objectC 混合app，结合性能与开发速度 关于适配的相关概念1. 屏幕 屏幕尺寸：屏幕对角线的长度，单位为英寸，1英寸=2.54厘米。 屏幕分辨率：屏幕的两个方向物理像素点数，单位px，1px=1像素点。1080*1920 屏幕密度：每英寸物理像素的个数 2. 像素 位图像素：图像的最小单位。一个位图像素对应一个物理像素就能完美清晰的展示（失真，锐化） 物理像素（设备像素）：设备呈现的最小单位，固定的。但是不同设备的一个物理像占据屏幕尺寸可能不一样，这就引出了等比的适配问题，现在屏幕分辨率高，所以物理像素多就导致了物理像素小。iphone6的物理像素为750px 设备独立像素（屏幕设备）：可以由程序员使用的虚拟像素，设备对接css像素的接口，只有css像素与设备独立像素挂钩width=device-width,（没有这句话，像素比是无效的）像素比才有其真正的作用。一般会让css像素等于这个设备独立像素。iphone6的物理像素为375px css像素：一个抽象单位，最终转换为物理像素（通过让css像素等于设备独立像素,然后利用像素比转换）。用来度量web页面的内容，web开发的最小单位 。一个css像素最终占据多少个物理像素由屏幕特性以及用户的缩放行为决定决定，在像素比为2的屏幕一个css像素占据四个物理像素， 像素比：物理像素/设备独立像素 （是设备固有的特性） iPhone6的像素比为750/375=2，像素比是单个方向的，这里是切图要注意的以一个3018的图片为例子，在像素比为1屏幕的就是30x18下，在像素比为2的屏幕就是60x36，这样就能完美显示。像素比获取命令： 1var dpr = window.devicePixelRatio||2 //如果不能自动获取，那其实我们知道为2 3. 视口（视口宽度用的都是css像素，所以逻辑上是可变的）3.1布局视口（决定网页布局）在PC端上，布局视口的宽度就等于浏览器窗口的宽度。而在移动端上，如果要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，那么布局视口需要大于移动设备的屏幕。Js获取布局视口尺寸的命令： 1document.documentElement.clientWidth | document.body.clientWidth 布局视口的出现，在极大程度上帮助了桌面网站到移动设备上的转移。iphone6的布局视口是980css像素 3.2 视觉视口（决定用户可视内容）滚动条由视觉窗口决定。Js获取视觉视口的命令： 1window.innerWidth； 一个css像素占据的物理像素的数量和视觉视口有很大关系，因为一个视觉视口包含的物理像素是固定的，但是包含的css像素个数会被缩放操作所影响，这个css像素个数就是视口宽度。视觉视口的初始值一般等于屏幕设备（设备独立像素）。iphone6的视觉视口初始值为375css像素。 3.3 理想视口（布局视口的一个状态）理想视口：布局视口的一个理想尺寸，只有当布局视口和屏幕设备一样宽（也就是和初始视觉视口一样大），才是理想视口。Js获取理想视口（屏幕宽度）的命令： 1window.screen.width 加入name为viewport的meta标签后理想视口才会出现（因为只有这个标签才能设置布局视口） 1&lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; 语句width=device-widthi（布局视口（css像素）=屏幕设备（设备独立像素））使得css像素与设备独立像素联系起来（开启像素比，因为像素比的定义和css像素没关系，加上这句话就联系上了css像素）这句话让布局视口的宽度等于了独立设备像素的宽度。不写这句话默认布局视口宽度就为980，写了变375。此时布局视口与视觉视口保持一致，布局视口成为理想视口。但是在理想视口下，如果元素过大，视觉视口会自动地尽量地包住你的内容（此时缩放比例不再为1），就会出现虽然元素超出了视觉视口但是不出现滚动条的现象，这个问题需要用完美视口解决。 3.4 完美视口（布局视口的一个状态）缩放比例为1的理想视口就成为完美视口 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"/&gt; 用来解决太大的元素超过出视觉窗口不出现滚动条的问题，width=device-width,initial-scale=1.0,如果这两者冲突的话，布局视口取两者间的较大值，只有这两个操作才能改变布局视口。注意，缩放比（系统缩放）是基于理想视口（分子）计算的var scale = document.documentElement.clientWidth/targetW;目标大那么尺缩比小于1，缩小目标；目标小那么尺缩比大于1，放大目标（所以width=device-width写在前面，先创造出理想视口，再计算）改变的是布局视口和视觉视口 4. 缩放操作（操作css像素）操作的类型 放大，放大css像素的面积，css像素占据更多的物理像素，能放下的css像素变少，视口尺寸变小 缩小，缩小css像素的面积，css像素占据更小的物理像素，能放下的css像素变多，视口尺寸变大 操作的对象 用户的操作PC端 影响布局视口移动端 影响视觉视口 系统操作（meta标签里的缩放）同时影响布局视口和视觉视口 5. 等比问题 没有加name为viewport的meta标签（一般布局视口）一个相同css像素大小的区域在不同的设备是等比例缩放的，能完整显示网页，在不同的设备上占据的实际物理大小（英寸）不一样 加name为viewport的meta标签 （理想布局视口）一个相同css像素大小的区域在不同的设备是不等比的，不能完整显示网页，在不同的设备上占据的实际物理大小（英寸）是一样的 等比是不是一个必须的需要？要求：在文字要完美清晰的展示的同时，还要做到百分百还原设计图（也是就是要等比）。 虽然不加mtae标签就已经等比了，但是这种会使得网页在移动端的字体变得很小 （做不到文字要完美清晰的展示） 要两者都做到那就得分两步。 1，展示清晰文字—-&gt; 必须加meta标签（不等比）2，恢复其他元素的等比—&gt; 适配！！！！（加上meta标签后也得等比）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"windows下在node环境利用hexo搭载个人博客","date":"2020-06-08T04:44:40.000Z","path":"2020/06/08/windows下在node环境利用hexo搭载个人博客/","text":"一，Git的下载与身份配置 安装Git，下载地址是：https://git-scm.com/ ,可以找速度快的淘宝镜像，下载后安装 使用命令 1git config --global user.name&quot;xxx&quot; 配置用户名 使用命令 1git config --global user.email &quot;xxx@xxx.com&quot; 配置邮箱 二，node的下载 安装Nodejs，下载地址是：https://nodejs.org/ 通过命令1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org 设置淘宝源，通过命令npm config get registry来检查是否配置成功 通过命令1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 安装cnpm，安装后就可以通过 cnpm install xxx来使用cnpm了。 三，hexo框架的下载与使用 全局安装hexo框架，1npm install hexo-cli –g 在任意一个位置创建一个文件夹来存放你的blog项目，在此文件夹下打开终端，输入 hexo init 初始化博客项目 创建文章，hexo n &quot;我的第一篇博客&quot; 安装部署插件，1cnpm install --save hexo-deployer-git 四，博客的预览与部署 下载主题，1git clone git:&#x2F;&#x2F;github.com&#x2F;tommy351&#x2F;hexo-theme-light.git themes&#x2F;light 下载后在_config.yml切换主题1theme: light 本地预览运行，hexo server（可用简写hexo s） 生成静态网页，hexo generate（可用简写hexo g） 新建一个仓库用来部署网页，仓库命名要求为你的昵称如：zhoubb96.github.io复制这个仓库的地址填到deploy的设置repo中修改_config.yml 1234deploy: type: &#39;git&#39; repo: https:&#x2F;&#x2F;github.com&#x2F;zhoubb96&#x2F;zhoubb96.github.io.git branch: masterd 部署到远端，hexo deploy（可用简写hexo d） 每次更新都要重新生成与上传。 许多个性化的设置需要在主题目录或者主目录下的_config.yml进行修改。","comments":true,"tags":[{"name":"博客搭载","slug":"博客搭载","permalink":"https://zhoubb96.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E8%BD%BD/"}]}]