[{"title":"数据结构与算法-树一","date":"2020-06-19T03:12:37.000Z","path":"2020/06/19/数据结构与算法-树一/","text":"树","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-哈希表二","date":"2020-06-19T01:18:33.000Z","path":"2020/06/19/数据结构与算法-哈希表二/","text":"哈希表的扩容思想为什么要扩容？ 随着数据量的增多，填充因子=数据量长度/数组长度，填充因子变大，就会使得哈希表的效率降低。所以需要在合适的时候进行扩容。 什么时候扩容？ 常见情况是：loadFactor&gt;0.75的时候进行扩容。loadFactor&lt;0.25就缩小容量 怎样扩容？ 保证扩容后的长度也为质数，并且扩容后其他数据项同时修改。所以扩容比较消耗性能，但是是必须的。 封装哈希表(链地址法实现)，二维数组，有扩容版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155function HashTable() &#123; //数组里放桶，桶里放数据，数组也以数组描述，0放key，1放value //this.storage-bucket-data //属性 this.storage = []//数组存放数据 this.count = 0//已存数据量 this.limit = 7//当前数组长度，设置初始长度为7 //工具函数，下标获取，扩容和缩容的时候的长度的取定为质数 //1，哈希函数 HashTable.prototype.hashFunc = function (str, size) &#123; //1,定义hashcode变量 let hashcode = 0 //2，秦九韶算法计算hashcode //cats-unicodeb编码 for (let i = 0; i &lt; str.length; i++) &#123; hashcode = hashcode * 37 + str.charCodeAt(i) &#125; //3,取余操作 let index = hashcode % size return index &#125; //2，判断质数 HashTable.prototype.isPrime = function (num) &#123; for (let i = 2; i &lt;= Math.sqrt(num); i++) &#123;//小于等于这里是，可以取到sqrt if (num % i == 0) &#123;//有因数 return false &#125; &#125;//无因数 return true &#125; //3，获取质数，根据原来的容量向上查找最接近的质数作为最接近的新容量 HashTable.prototype.getPrime = function (num) &#123; while (!this.isPrime(num)) &#123; num++ &#125; return num &#125; //方法 //1，插入与修改操作;第一步：根据key获取index；第二步：根据index获取位置里的数组(链表),如果该数组不存在就创建该数组。第三步：判断是新增还是修改，如果key存在就进行修改；key不存在就进行添加。 HashTable.prototype.put = function (key, value) &#123; //获取index let index = this.hashFunc(key, this.limit) //取出bucket let bucket = this.storage[index] //判断bucket是否存在 if (!bucket) &#123;//类型之间的判断用双等号if(bucket==null),用三等号这里报错 bucket = []//创建数组 this.storage[index] = bucket//将创建的空数组放入原数组 &#125; //判断添加还是修改 for (let i = 0; i &lt; bucket.length; i++) &#123;//遍历数组里的元素进行比较，进行修改 let data = bucket[i] if (data[0] === key) &#123;//每个元素又有两个部分 data[1] = value return true &#125; &#125; //循环结束无符合条件，进行添加,修改的话数据量不变，添加数据量加1 bucket.push([key, value])//存放格式 this.count++ //count++了判断是否需要扩容 if (this.count &gt; this.limit * 0.75) &#123; //判断质数 let newLimit = this.limit * 2//初始扩容 newLimit = this.getPrime(newLimit) this.resize(newLimit) &#125; &#125; //2，获取方法 HashTable.prototype.get = function (key) &#123; let index = this.hashFunc(key, this.limit) let bucket = this.storage[index]//获取bucket if (!bucket) return null//bucket为空，值不存在 for (let i = 0; i &lt; bucket.length; i++) &#123; let data = bucket[i] if (data[0] === key) return data[1]//返回值 &#125; &#125; //3，删除操作，调用数组删除操作splice() HashTable.prototype.remove = function (key) &#123; let index = this.hashFunc(key, this.limit) let bucket = this.storage[index]//获取bucket if (!bucket) return null//bucket为空，值不存在 //判断删除 for (let i = 0; i &lt; bucket.length; i++) &#123; let data = bucket[i] if (data[0] === key) &#123; bucket.splice(i, 1)//从i开始删除1个 this.count-- //count--了，判断是否需要缩小容量 if (this.count &lt; this.limit * 0.25 &amp;&amp; this.count &gt; 7) &#123; //判断质数 let newLimit = Math.floor(this.limit / 2) newLimit = this.getPrime(newLimit) this.resize(newLimit) &#125; return data[1] &#125; &#125; //遍历结束没有找到 return null &#125; //4，判断是否为空 HashTable.prototype.isEmpty = function () &#123; return this.count === 0 &#125; //5，获取个数 HashTable.prototype.size = function () &#123; return this.count &#125; //6，哈希扩容 HashTable.prototype.resize = function (newLimit) &#123; //获取旧数据 let oldstorage = this.storage //重置数据 this.storage = [] this.count = 0 this.limit = newLimit //遍历所有oldstorage中的bucket放入新storage for (let i = 0; i &lt; oldstorage.length; i++) &#123; //取出 bucket = oldstorage[i] //判断，中间的bucket可能是空的，因为在storage里放bucket的时候不是连续的。 if (!bucket) &#123; continue &#125; //bucket有数据 for (let j = 0; j &lt; bucket.length; j++) &#123; let data = bucket[j]//获取数据 this.put(data[0], data[1])//添加数据,定义的时候就是传入两个参数 &#125; &#125; &#125; &#125; //测试 let hash1 = new HashTable() //添加 hash1.put(\"abc\", 1) hash1.put(\"cba\", 2) hash1.put(\"nba\", 3) //获取 console.log(hash1.get(\"abc\"))//1 //修改 hash1.put(\"abc\", 111) console.log(hash1.get(\"abc\"))//111 //删除 hash1.remove(\"abc\") console.log(hash1.get(\"abc\"))//undefined console.log(hash1.size())//2","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS对象Proxy代理实现双向绑定","date":"2020-06-18T12:11:27.000Z","path":"2020/06/18/JS对象Proxy代理实现双向绑定/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" v-model=\"title\" /&gt; &lt;input type=\"text\" v-model=\"title\" /&gt; &lt;h4 v-bind=\"title\"&gt;这里也会发生更新&lt;/h4&gt;&lt;/body&gt;&lt;script&gt; function View() &#123; let proxy = new Proxy( &#123;&#125;, &#123; set(obj, key, value) &#123; console.log(value)//此时value已经传入 &#125;, get(obj, key) &#123; &#125; &#125; );//代理了一个空对象 //绑定事件 this.init = function () &#123; //获取触发事件的对象 const els = document.querySelectorAll(\"[v-model]\")//属性选择器 //添加事件 els.forEach((item, index) =&gt; &#123; item.addEventListener('keyup', function () &#123; //触发代理的set proxy[this.getAttribute('v-model')] = this.value//往空对象里压入属性 &#125;) &#125;) &#125; &#125; new View().init()","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS对象Proxy代理拦截","date":"2020-06-18T10:26:49.000Z","path":"2020/06/18/JS对象Proxy代理拦截/","text":"所谓代理（proxy），就是一个表示接口的对象，对它的操作不一定作用在代理对象本身。举个例子，设置代理对象的一个属性，实际上可能会在另一个对象上调用一个函数。代理是一种非常有用的抽象机制，能够通过 API只公开部分信息，同时还能对数据源进 行全面控制。 简单来说，Proxy就像一个代理商，拦截就是在中间添加判断与操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//对象代理拦截const obj = &#123; name: \"zbb\", age: 24 &#125;const proxy = new Proxy(obj, &#123; get(obj, property) &#123;//obj接受obj return obj[property] &#125;, set(obj, property, value) &#123; obj[property] = value return true &#125; &#125;) console.log(proxy.name) //zbb proxy.name=\"zhou\" console.log(proxy.name) //zhou//函数代理拦截function jiechen(num)&#123; if(num===0) return 1 if(num===1) return 1 return num*jiechen(--num)&#125;console.log(jiechen(4))//24let proxy = new Proxy(jiechen,&#123; apply(func,obj,args)&#123;//func接受jiechen，obj接受对象，args接受参数 console.time('run') func.apply(this,args) console.timeEnd('run') &#125;&#125;)proxy.apply(this,[4])//一个时间，其实这里obj随便传什么。//对数组代理拦截const lessons = [ &#123;title: \"媒体查询响应式布局\",category: \"css\"&#125;, &#123;title: \"FLEX模型\", category: \"css\"&#125;, &#123; title: \"MYSQL多表查询随意操作\",category: \"mysql\"&#125; ];let proxy=new Proxy(lessons,&#123; get(array,key)&#123;//array就是proxy中的，自动接收。 const title=array[key].title const len=5 return title.length&gt;5?title.substr(0,len)+'.'.repeat(3):title &#125;&#125;)console.log(proxy[0])//媒体查询响...console.log(proxy[1])//FLEX模...console.log(proxy[2])//MYSQL... 上面几个例子，第一个参数不用手动传递。也就是obj，func，array，就是接受自身代理的那个东西。后面几个参数必须手动传入。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS-Token的读写处理","date":"2020-06-18T09:21:48.000Z","path":"2020/06/18/JS-Token的读写处理/","text":"Token的访问控制器设置 12345678910111213141516//设置token令牌对象let Request=&#123; //没有在对象中，因为数据存在了本地 set token(content)&#123; localStorage.setItem('token',content)//在本地缓存设置一个token &#125;, get token()&#123; let token=localStorage.getItem('token')//获取 if(!token)&#123; alertr('请登录')//没有token &#125; return token &#125;,&#125;Request.token='123'console.log(Request.token)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS对象访问控制器","date":"2020-06-18T08:51:50.000Z","path":"2020/06/18/JS对象访问控制器/","text":"访问器属性的优先级高于普通的属性操作方式！ 使用访问控制器保护对象数据123456789101112131415const user=&#123; data:&#123;name: \"zbb\",age: 24&#125;,//对象中的对象；封装起来保护数据 set age(value)&#123; if(typeof value!='number'||value&lt;0||value&gt;100)&#123; throw new Error('年龄格式错误') &#125; this.data.age=value &#125;,//函数成员，没有键？只有通过访问器才能修改数据 get age()&#123; return this.data.age//如果是this.age就会循环找访问器属性，死循环，应该是data中的age &#125;&#125;user.age=77//调用方法保持一致console.log(user.age)//77//用set与get两个关键字修饰两个age同名了，但是不冲突，因为一个要传参数，一个不穿参数，根据参数的有无自动调用，可以用对象点方法的形式直接调用，保证了调用形式的一致性 使用访问控制器伪造对象属性1234567891011121314const lessons = &#123; lists: [ &#123; name: \"js\", price: 100 &#125;, &#123; name: \"mysql\", price: 212 &#125;, &#123; name: \"vue.js\", price: 98 &#125; ], get total()&#123; return this.lists.reduce((pre,cur)=&gt;&#123; return pre+cur.price &#125;,0) &#125;, &#125; console.log(lessons.total)//410，伪造了total这个属性 lessons.total=8388//报错，无此属性无法设置。因为我们没有定义set 构造函数与访问控制器的联合使用123456789101112131415161718192021222324252627282930function User(name, age) &#123; let data = &#123; name, age &#125; //封装数据 Object.defineProperties(this, &#123; name: &#123; get() &#123; return data.name &#125;, set(value) &#123; if (value.trim() === \"\" || value.length &gt; 20) &#123; throw new Error('用户名不合法') &#125; data.name = value &#125; &#125;, age: &#123; get() &#123; return data.age &#125;, set(value) &#123; data.age = value &#125; &#125;, &#125;) //访问控制器设置数据&#125;let user = new User(\"zbb\", 24)console.log(user)//User&#123;&#125;user.name=\"zhou\"console.log(user.name)//zhou 类与访问控制器的联合使用1234567891011121314151617181920212223242526class User &#123; constructor(name, age) &#123; this.data = [name, age] &#125; //name的访问控制器 get name() &#123; return this.data.name &#125; set name(value) &#123; if (value.trim() === \"\" || value.length &gt; 20) &#123; throw new Error('用户名不合法') &#125; this.data.name = value &#125; //age的访问控制器 get age() &#123; return this.data.age &#125; set age(value) &#123; this.data.age = value &#125;&#125;let user = new User(\"zbb\", 24)console.log(user)//User&#123;&#125;user.name=\"zhou\"console.log(user.name)//zhou","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"访问控制器set，get","slug":"访问控制器set，get","permalink":"https://zhoubb96.github.io/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%99%A8set%EF%BC%8Cget/"}]},{"title":"对象的创建方式","date":"2020-06-18T07:15:33.000Z","path":"2020/06/18/JS对象的创建方式/","text":"对象的创建方式1，字面量模式1let obj=&#123;name:\"zbb\",show:function()&#123;console.log(this.name)&#125;&#125; 2，工厂函数(没有用关键字new)1234function user(name)&#123; return &#123;name,show:function()&#123;console.log(this.name)&#125;&#125;//返回对象&#125;let obj = user(\"zbb\") 3，构造函数(使用关键字new) 1234567891011function User (name)&#123; this.name=name this.show=function()&#123;//键值对给个匿名函数只在对象里才行 console.log(this.name) &#125; return this//this是设置完的对象&#125;let zbb=new User(\"zbb\")zbb.show()//zbblet fun=zbb.show//将方法赋值给变量后，fun变成普通函数fun()//undefined；因为此时就不再是方法调用，而是普通函数，this变成了window new共经过了4几个阶段 1、创建一个空对象 2、设置原型链 3、让构造函数的this指向obj，并执行构造函数的函数体。 4、判断的构造函数返回值类型，并返回对象：（为值得话，返回对象；如果是引用就是返回引用类型对象） 注意：这种方法的创建对象，那么方法在每个对象里都有一份，有点浪费空间。 4，构造函数+原型","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS对象","date":"2020-06-18T03:04:04.000Z","path":"2020/06/18/JS对象/","text":"面向对象三大特性：封装、继承、多态属性 属性的检测 对象属性检测obj.hasOwnProperty(&quot;key&quot;),仅查看自身属性 原型链属性检测&quot;key&quot; in obj，自身与原型的属性都进行检测 属性的计算 动态计算属性名，reduce方法 1234567891011let lessons = [ &#123;title: \"媒体查询响应式布局\",click: 89,price: 12&#125;, &#123;title: \"FLEX 弹性盒模型\",click: 45,price: 120&#125;, &#123;title: \"GRID 栅格系统\",click: 19,price: 67&#125;, &#123;title: \"盒子模型详解\",click: 29, price: 300&#125; ]; obj=lessons.reduce((pre,cur,index)=&gt;&#123; pre[`$&#123;cur['title']&#125;-$&#123;index&#125;`]=cur//每次都添加新的键值对 return pre &#125;,&#123;&#125;) console.log(obj)//&#123;媒体查询响应式布局-0: &#123;…&#125;, FLEX 弹性盒模型-1: &#123;…&#125;, GRID 栅格系统-2: &#123;…&#125;, 盒子模型详解-3: &#123;…&#125;&#125; 属性的获取Object.keys(obj)，获取对象obj的所有属性名，以数组返回，或者使用for-in 属性的复制Object.assign(obj1,obj2)，将obj2的属性复制给obj1；也可以用循环与展开语法。 属性的定制 属性的可读写性等Object.defineProperty(obj,key,{key,writable:true,enumerable:true,configurable:true}) 禁止外部添加属性Object.preventExtensions(obj) 对象的封闭Object.seal(obj)不能对对象的属性进行操作 对象的冻结Object.freeze(obj)不能对对象进行修改，可以使用。 方法将普通函数封装为对象方法的好处在于可以避免函数冲突，而且封装过后调用简单。对象是引用变量，所以通常情况下是传地址，而且是浅拷贝。注意对象中的对象的传递。 深拷贝，一层一层的处理处理对象中的对象的赋值，判断递归 12345678910111213141516//浅拷贝，object[key]可能也为一个对象function copy(object)&#123; let res=&#123;&#125; for(const key in object)&#123; res[key]=object[key] &#125; return res&#125;//深拷贝，递归函数function deepcopy(obj)&#123; let res=obj istacneof Array?[]:&#123;&#125;//因为递归进行下去时，最里面的数据可能是数组，因此是数组的情况下应该返回数组 for(const[key,value] in Object.entries(obj))&#123;//考虑数组的情况，统一键值对，统一数组与对象的处理方法 res[key]=typeof value==='object'?deepcopy(value):value//是对象就继续递归，不是对象直接赋值 &#125; return res&#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"深浅拷贝","slug":"深浅拷贝","permalink":"https://zhoubb96.github.io/tags/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"JS抖动与加速","date":"2020-06-18T01:23:57.000Z","path":"2020/06/18/JS抖动与加速/","text":"动画抖动与加速1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;后盾人&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; button &#123; position: absolute;/*必须加上这个style标签，不然动不了*/ &#125; &lt;/style&gt; &lt;button message=\"按钮\"&gt;按钮&lt;/button&gt; &lt;/body&gt; &lt;script&gt; let btns = document.querySelectorAll(\"button\") btns.forEach((items) =&gt; &#123; //let left=1//位置2 items.addEventlistener(\"click\", function () &#123; //let left=1//位置1 setInterval(function()&#123; items.style.left=left++ +\"px\" &#125;,100) &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; 函数的本意是点击按钮使得按钮移动 1，如果left=1放在位置1，会在第二次点击后产生动画抖动，因为每点击一次，left都会回到1，重新计算。 2，如果left=1放在位置2，那么因为因为left被修改了（this方式），外部环境没有消亡会保存left信息，因此不会抖动，但是会出现动画加速问题，因为会多个定时器叠加，解决方法是在外部先对定时器进行判断，如果无定时器才开启定时器，有的话就不开启了，就保证只有一个定时器。 12345678910111213let btns = document.querySelectorAll(\"button\") btns.forEach((items) =&gt; &#123; let left=1 let interval=false items.addEventlistener(\"click\", function () &#123; if(interval===false)&#123; interval=true setInterval(function()&#123; items.style.left=left++ +\"px\" &#125;,100) &#125; &#125;) &#125;) 注意内外部环境与定时器的累加问题 123456789101112131415//但是把变量放在外部可能污染变量let btns = document.querySelectorAll(\"button\") btns.forEach((items) =&gt; &#123; let bind=false items.addEventListener(\"click\", function () &#123; if(!bind)&#123; bind=true let left=1 setInterval(function()&#123; items.style.left=left++ +\"px\" &#125;,100) &#125; &#125;) &#125;)//原理是只产生一个定时器，即解决抖动又解决加速。空环境中没有数据。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS环境、作用域与闭包","date":"2020-06-17T06:38:27.000Z","path":"2020/06/17/JS环境、作用域与闭包/","text":"作用域定义：一块静态的代码区域，在编码时确定，并不会再改变 类型：全局作用域，函数作用域，块作用域（for循环括号里变量，在此之前使用立即执行函数的函数作用域模拟块作用域，）。 环境上下文对象定义：一个管理相应作用域中数据的对象；有全局上下文对象，函数上下文对象 全局上下文对象是window，不会被回收，除非关闭标签 函数上下文对象是运行时动态创立的，运行结束时回收；执行几次创建几次，每次创建数据都是新的，产生多个内存地址，每个内存地址里都有一份数据。 作用域涵盖了上下文对象，上下文对象在作用域里活动。 闭包声明：嵌套函数，内部函数引用外部函数变量（内部更新数据后返回给外部）。 原理：每次外部函数执行的时，外部函数都会创建一个新的环境，这个环境的引用地址是不同，都会重新创建一个新的地址，里面的数据也是全新的。但是如果当前外部环境中有被内部函数引用的数据，那么这个时候，外部环境不会被回收；这个数据不删除，会被保留一根指针给内部活动对象。 ​ 简单说内部改变数据并返回给外部函数，让外部函数保存这个数据，并且外部环境不被回收。(利用了垃圾回收的引用规则) 1234567891011function f1()&#123; let n=1 function sum()&#123; console.log(++n)//因为外面没有更新这个++n &#125; sum()&#125;f1()//2f1()//2f1()//2//每次调用f1，创建一个性的上下文对象数据都是新的，n总是1. 那么如何延长函数上下文的生存周期呢？ 1234567891011121314151617function f2()&#123; let n=1 return function sum()&#123;//1，这个return就把里面的数据传递了出去，更新了外部的++n，引用类型会更新数据。2，除此之外也可以用this来建立这个引用关系。this.sum=function()&#123;console.log(++n)&#125;,也行，这称为构造函数的闭包 console.log(++n) &#125; sum()//这句这里有没有都不影响&#125;f2()//无输出，因为还没到sum()调用，sum就被返回了f2()()//2f2()()//2f2()()//2//相当于每次都开了一个新环境，这种方法没有利用到闭包let a=f2()//不让外部函数每次都重新建立，这部是关键a()//2a()//3a()//4//因为a这个环境是一开始创好的不会每次都创建新的，利用到了闭包 关键就是外部环境中的变量被引用（更新），从而使得让外部环境保留 1，这个return就把里面的数据传递了出去，更新了外部的++n，引用类型会更新数据。返回了这个函数，而这个函数还在使用这个外部变量，所以外部环境不会被删除。常驻内存了。 2，除此之外也可以用this来建立这个引用关系。this.sum=function(){console.log(++n)},也行，这是构造函数的闭包 闭包的小应用 12345678910111213141516let arr=[1,3,5,7,9,10,25,56]let arr2=arr.filter((value)=&gt;&#123; return value&gt;3&amp;&amp;value&lt;56//那我们每次如果要修改区间还要改这个数字，抽离函数封装起来&#125;)console.log(arr2)//[5, 7, 9, 10, 25]//封装函数function between(a,b)&#123; return function(v)&#123; return v&gt;a&amp;&amp;v&lt;b &#125; //return (v)=&gt; v&gt;a&amp;&amp;v&lt;b这是简写，不方便理解闭包 &#125;//filter调用，filter会自动把value传给参数vlet arr3=arr.filter(between(3,25))console.log(arr3)////[5, 7, 9, 10, 25] 123456789101112131415let lessons = [ &#123;title: \"媒体查询响应式布局\",click: 89,price: 12&#125;, &#123;title: \"FLEX 弹性盒模型\",click: 45,price: 120&#125;, &#123;title: \"GRID 栅格系统\",click: 19,price: 67&#125;, &#123;title: \"盒子模型详解\",click: 29, price: 300&#125; ]; function order(field)&#123; return function(a,b)&#123; return a[field]&gt;b[field]?1:-1 &#125; &#125; console.table(lessons.sort(order(\"click\")))//属性名是字符串。 console.table(lessons.sort(order(\"price\")))//自定义函数抽离与sort，filter等函数联合使用。//抽离，然后sort调用 函数利用到其他函数的数据。 闭包的问题：内存泄露，优化手段就是定义新的变量来只保留想要信息，获取完后及时去掉不需要的变量内存。在闭包里要非常关注this的指向，因为闭包可以向上获取信息，但是一般this是不会向上寻找的。所以闭包里最好用箭头函数。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS递归与循环","date":"2020-06-17T04:03:48.000Z","path":"2020/06/17/JS递归与循环/","text":"递归重复做一件事，在合适的时候返回即可。递归的关键在于终止条件的判断 123456789101112131415161718192021//递归实现阶乘，形式和判断很简单但是运行效率慢function jiechen1(num)&#123; if(num===0) return 1 if(num===1) return 1 //return num*jiechen(num--)//此处num--会导致报错，因为num--的话取得还是num，没有进入下一步 return num*jiechen1(num-1)//必须是n-1，或者--n&#125;//循环实现阶乘,形式和判断要复杂些但是运行效率快function jiechen2(num)&#123; if(num===0) return 1 if(num===1) return 1 let result=1 for(let i=2;i&lt;=num;i++)&#123; result=result*i &#125; return result&#125;console.log(jiechen1(4))//24console.log(jiechen2(5))//120 递归函数内顺序 1，停止条件 2，执行体代码 3，递归调用 12345678910//以打印倒三角为例子function star(num)&#123; //1，停止条件 if(num===0) return \" \" //2，执行体代码 document.write(\"*\".repeat(num)+\"&lt;br/&gt;\")//html换行标签&lt;br/&gt; //3，递归调用 star(--num) &#125;star(5)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"数据结构与算法-哈希表一","date":"2020-06-16T12:06:12.000Z","path":"2020/06/16/数据结构与算法-哈希表一/","text":"哈希表搞懂哈希表到底如何实现的。理论知识较多，实现并不难。哈希表是基于数组实现的，但是相对与数组有以下优势 优势 可以提供快速的插入，删除，查找操作。 无论数据量为多少，插入与删除的时间复杂度都接近o(1) 速度比树还要快，可以很快的查找。 编码难度比树简单 不足之处 由于内部是无序数据，所以无法以一种固定方式遍历元素。 哈希表的key值不允许重复 哈希函数哈希表对下标值会做一种变换，这个变换规则称之为哈希函数，通过哈希函数获取到哈希码，HashCode，一一对应。 第一次看hash表的时候没有深入了解这个东西。 目标：1，将字符串转为大的数字hashcode；2，将大的数字hashcode压缩到数组范围内index 直接相加，不能保证数字的唯一性。 幂的连乘，基本可以保证数字的唯一性，但是产生的下标会过大，导致数组过大，元素分布不均匀。 优秀的哈希函数应当由以下优点 计算简单（尽量避免乘除法，提高计算速度） 输出均匀（减小探测步长与次数） 多项式计算，再利用秦九韶算法。使用质数当作底数， 哈希化：是把任意长度的输入通过散列算法（哈希函数）变换成固定长度的输出，该输出就是散列值（哈希值）。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 哈希化后的下标依然可能重复，所以要处理冲突。 实现一个hash函数 123456789101112131415//哈希函数1，将字符串转为较大的数字；2，将大的数字压缩到数组范围内 function hashFunc(str,size)&#123; //1,定义hashcode变量 let hashcode=0 //2，秦九韶算法计算hashcode //cats-unicodeb编码 for(let i=0;i&lt;str.length;i++)&#123; hashcode=hashcode*37+str.charCodeAt(i) &#125; //3,取余操作 let index=hashcode%size return index &#125; console.log(hashFunc('abc',7))//4 冲突的处理方法 1，链地址法 在数组的下标位置放一个链表，每个数组单元不再放单个数据，而是一个链条（或者数组）。先通过下标取到位置，再通过位置遍历链表。 2，开放地址法 寻找空白的单元格添加重复数据，寻找方法又有线性探测、二次探测法和再哈希法。如何确定探测步长。 线性探测法步长为1，线性探测法存在的问题是在表里还没有任何数据的时候，插入连续的元素会造成聚集，这会影响性能。 二次探测法可以解决聚集的问题，优化探测步长，一次性探测较长的步长就避开了聚集问题。 再哈希法，产生依赖于关键字的探测方法，多次使用哈希函数，第二次的哈希数作为步长。第二次哈希函数不能与第一次哈希函数相同，且输出结果不能为零。stepsize=const-(key%const),const是一个小于数组容量的质数。 哈希化的效率1，没有冲突的时候，效率是最高的 2，如果发生冲突，那么与效率依赖于探测长度 3，探测长度和平均存储事件又取决于填充因子。 填充因子的概念：已有数据量/哈希表长度 开发地址法的填充因子最大为1；而链地址法的填充因子可以远超过1。 填充因子越大、空间利用率越高、查询效率越低。 链地址法的时间复杂度与填充因子是线性的，而开放地址法的时间复杂度与填充因子是指数关系的。所以使用链地址法多一些。 封装哈希表(链地址法实现)，二维数组，无扩容版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function HashTable()&#123; //数组里放桶，桶里放数据，数组也以数组描述，0放key，1放value //this.storage-bucket-data //1,属性 this.storage=[]//数组存放数据 this.count=0//已存数据量 this.limit=7//当前数组长度，设置初始长度为7 //2，哈希函数 HashTable.prototype.hashFunc=function (str,size)&#123; //1,定义hashcode变量 let hashcode=0 //2，秦九韶算法计算hashcode //cats-unicodeb编码 for(let i=0;i&lt;str.length;i++)&#123; hashcode=hashcode*37+str.charCodeAt(i) &#125; //3,取余操作 let index=hashcode%size return index &#125; //方法 //1，插入与修改操作;第一步：根据key获取index；第二步：根据index获取位置里的数组(链表),如果该数组不存在就创建该数组。第三步：判断是新增还是修改，如果key存在就进行修改；key不存在就进行添加。 HashTable.prototype.put=function(key,value)&#123; //获取index let index = this.hashFunc(key,this.limit) //取出bucket let bucket=this.storage[index] //判断bucket是否存在 if(!bucket)&#123;//类型之间的判断用双等号if(bucket==null),用三等号这里报错 bucket=[]//创建数组 this.storage[index]=bucket//将创建的空数组放入原数组 &#125; //判断添加还是修改 for(let i=0;i&lt;bucket.length;i++)&#123;//遍历数组里的元素进行比较，进行修改 let data=bucket[i] if(data[0]===key)&#123;//每个元素又有两个部分 data[1]=value return true &#125; &#125; //循环结束无符合条件，进行添加,修改的话数据量不变，添加数据量加1 bucket.push([key,value])//存放格式 this.count++ &#125; //2，获取方法 HashTable.prototype.get=function(key)&#123; let index=this.hashFunc(key,this.limit) let bucket=this.storage[index]//获取bucket if(!bucket) return null//bucket为空，值不存在 for(let i=0;i&lt;bucket.length;i++)&#123; let data=bucket[i] if(data[0]===key) return data[1]//返回值 &#125; &#125; //3，删除操作，调用数组删除操作splice() HashTable.prototype.remove=function(key)&#123; let index=this.hashFunc(key,this.limit) let bucket=this.storage[index]//获取bucket if(!bucket) return null//bucket为空，值不存在 //判断删除 for(let i=0;i&lt;bucket.length;i++)&#123; let data=bucket[i] if(data[0]===key) &#123; bucket.splice(i,1)//从i开始删除1个 this.count-- return data[1] &#125; &#125; //遍历结束没有找到 return null &#125; //4，判断是否为空 HashTable.prototype.isEmpty=function()&#123; return this.count===0 &#125; //5,获取个数 HashTable.prototype.size=function()&#123; return this.count &#125;&#125;//测试let hash1=new HashTable()//添加hash1.put(\"abc\",1)hash1.put(\"cba\",2)hash1.put(\"nba\",3)//获取console.log(hash1.get(\"abc\"))//1//修改hash1.put(\"abc\",111)console.log(hash1.get(\"abc\"))//111//删除hash1.remove(\"abc\")console.log(hash1.get(\"abc\"))//undefinedconsole.log(hash1.size())//2","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-集合","date":"2020-06-16T07:09:18.000Z","path":"2020/06/16/数据结构与算法-集合/","text":"集合Set一般常用哈希表实现，但是这里先自己使用object类封装一个集合类。Set类在ES6中已经原生支持了。 集合Set的元素是无序的（不能用下标的方法访问），且值不能重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//集合function Set()&#123; //属性 this.items=&#123;&#125;//用对象存储封装，对象值的覆盖 //方法 //1,添加 Set.prototype.add=function(value)&#123; if(this.has(value))&#123;//如果有值返回失败，其实如果不判断，不影响唯一性。 return false &#125; this.items[value]=value//键值合一，也保证了元素的唯一性。因为一样的值会进行覆盖 return true &#125; //2，判断 Set.prototype.has=function(value)&#123; return this.items.hasOwnProperty(value)//这是对象判断属性的方法，hasOwnProperty() &#125; //3，remove Set.prototype.remove=function(value)&#123; if(!this.has(value)) return false delete this.items[value]//这是对象删除属性的方法，delete return true &#125; //4，clear Set.prototype.clear=function()&#123; this.items=&#123;&#125;//重新赋值，原对象因为失去引用而被回收 &#125; //5，size Set.prototype.size=function()&#123; return Object.keys(this.items).length//这是对象获取属性数量的语句，keys() &#125; //6，values Set.prototype.values=function()&#123; return Object.values(this.items)//或者Object.keys(this.items)，因为键值合一 &#125; &#125;let set = new Set()console.log(set.add(\"abc\"))//trueconsole.log(set.add(\"abc\"))//falseset.add(\"cba\")set.add(\"nba\")set.add(\"swk\")console.log(set.size())//4console.log(set.remove(\"nba\"))//trueconsole.log(set.remove(\"nba\"))//falseconsole.log(set.values())//(3) [\"abc\", \"cba\", \"swk\"],数组形式返回set.clear()console.log(set.values())//[]let set1 = new","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS函数与箭头函数","date":"2020-06-16T06:56:17.000Z","path":"2020/06/16/JS函数与箭头函数/","text":"1，函数声明的几种形式1,使用对象的方式来定义函数 123let func=new Function('title','console.log(title)')//func是函数名，title是参数，console.log(title)是函数体func(\"zbb\") 2,字面量方式定义函数 1234function func1(title) &#123; console.log(title)&#125;;func1(\"zbb\") 2，匿名函数与函数提升一般函数会被压入window对象中，成为全局函数，如果定义的函数与window的原有函数重名，那么就会覆盖window自带函数，污染全局。 可以将匿名函数赋值给let声明的变量（var不行，var有提升，还是会压入全局） 12345let fun=function()&#123; console.log(\"function\")&#125;fun()//调用成功window.fun()//调用失败，如果用的是var声明，那么会调用成功 建议函数不独立存放，以模块，类的方式管理函数。 直接定义的函数（全局）会有函数提升，但是赋值给变量的匿名函数不会有提升，不管这个变量是用var声明的还是let声明的。 3，立即执行函数与块作用域 立即执行函数 (function(){})(),可以解决命名冲突污染全局作用域的问题。原理是用函数作用域达到隔离的效果。立即执行函数加对象管理，并选择性暴露。这是早期方式。 let的块级作用域 块级作用域加对象管理，并选择性暴露。原理和上面类似，这里是用块级作用域隔离。 123456&#123; let a=\"zbb\" var b=\"ycy\"&#125;console.log(a)//失败，let，const有块级作用域console.log(b)//成功，var没有，可以访问到 4，关于参数1，参数列表 实参数量一般是对应形参数量的，但是实参数量可以大于形参，多的参数会被忽略。 如果实参数量小于形参数量，那么多的形参就为undefined。 可以给形参设置默认值。 2，函数参数与arguments 函数作为参数的时候就是回调函数。 在不确定参数列表长度的时候，arguments会把所有参数收集起来。arguments是有长度属性的，但是它是一个伪数组，不具备数组的方法，当然，可以把它转换为数组。[…arguments] 123function sum(...args)&#123;//在不确定参数列表长度的时候，接受所有变量 console,log(args)&#125; 5，箭头函数 可以很好的简化匿名函数的实现。而且摆脱原有this对象带来的麻烦。.箭头函数的this与其定义时所处的对象有关，与调用者无关；如果外层有函数，则其与外层函数的this对象一致，如果外无函数，直接指向window 很好的解决了闭包里this的问题 参数传递 没有参数: () =&gt; console.log(&#39;xxxx&#39;) 一个参数: i =&gt; i+2，()小括号可以省略；i就是参数 大于一个参数: (i,j) =&gt; i+j，()小括号不可以省略； 返回值 函数体只有一条语句的话，函数体不用大括号; 默认自动返回执行的结果；（自己return了） 函数体如果有多个语句, 需要用{}包围；有大括号的话，必须使用return返回想返回的结果（因为没有return的话默认返回undefined） 因为箭头函数没有函数名，所以不能解决递归函数，构造函数，事件处理的时候不方便使用。 6，This的不同的情况：除了箭头函数，this是不会向上查找的，如果不是方法，那this就是window。 1.以普通函数的形式调用时，this是window 2.以工厂函数调用，this是undefind 3.以构造函数的形式调用时，this就是新创建的对象 这个方法必须通过new调用（构造函数必须以new调用），因为构造函数也是函数，如果普通调用，this还是会指向window 4.以方法的形式调用时，this就是调用方法的对象 5.使用call和apply调用时，this是指定的那个对象 6.在全局作用域中this代表window 7.react组件中自定义方法函数的this为null 8.箭头函数的this与其定义时所处的对象有关，与调用者无关；如果外层有函数，则其与外层函数的this对象一致，如果外无函数，直接指向window 7，使用call，apply与bind改变this1，call与apply都会立即调用函数 call(obj,a,b,c) apply(obj,[a,b,c]) 如果不想改变对象，那么第一个参数传入null 不传参数时候二者是一样的，传参数时区别在于call是一个一个的传入，而apply是用数组来传入参数。 2，bind，不会立刻调用函数。 bind(obj,a,b,c) 1，参数可以在绑定时传递；2，也可以在调用时传递，一般在调用时传递；因为不立即执行，bind绑定只是为了修改this对象。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS-Map与Weakmap类型","date":"2020-06-16T01:15:51.000Z","path":"2020/06/16/JS-Map与Weakmap类型/","text":"Map类型以往的对象类型是以字符串作为键名；而Map类型的键名可以为任意类型的变量。 12345678910111213141516171819 //传统对象 let obj = &#123; name: \"name\" &#125;; let hd = &#123; [obj]: \"姓名\"//如过不加中括号，那么这个obj是个字符串该字符串就为“obj”与上面的对象类型的obj没有任何关系，加了中括号，就会把上面的对象类型的obj转化为字符串。[object Object] &#125;; console.log(hd[obj.toString()]);//中括号取值 //Map类型 let map = new Map(); map.set(\"name\", \"姓名\");//&#123;\"name\" =&gt; \"姓名\"&#125; map.set(function() &#123;&#125;, \"cms\");//&#123;function() &#123;&#125; =&gt; \"cms\"&#125; map.set(&#123;&#125;, \"houdunren\");//&#123;Object =&gt; \"houdunren\"&#125; map.set(1, \"sina.com.cn\");//&#123;1 =&gt; \"sina.com.cn\"&#125; console.log(map); let map = new Map([[\"cms\", \"开源系统\"], [\"JS, \"在线教程\"]]);//&#123;\"cms\" =&gt; \"开源系统\"&#125;&#123;\"JS\" =&gt; \"在线教程\"&#125; 增删改查，set，delete，has 1234567891011121314151617 let obj = &#123; name: \"姓名\" &#125;; let map = new Map(); map.set(obj, \"sina.com\"); console.log(map.get(obj))//sina.com console.log(map.delete(obj))//true // map.clear();清空 // console.log(map.has(\"site\"));false，查询的是键名。 // console.log(map.keys())//复数，获取所有键，以对象形式返回。 // console.log(map.values())//复数，获取所有值。以对象形式返回。 // console.log(map.entries())//复数，所有键值对，以对象形式返回。用forEach也行//Map转换为数组，这里外层的中括号表示把展开的元素放入数组里// console.log([...map.keys()])// console.log([...map.values()])// console.log([...map.entries()]) WeakMap类型WeakMap类型中的键只能为对象。 屏蔽了循环迭代，size，keys与values等方法。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Map类型","slug":"Map类型","permalink":"https://zhoubb96.github.io/tags/Map%E7%B1%BB%E5%9E%8B/"}]},{"title":"JS-Set类型","date":"2020-06-15T09:21:27.000Z","path":"2020/06/15/JS-Set与WeakSet类型/","text":"1，Set类型：值不能重复的容器。数组传参，没有键，只有值，或者说键与值是一样的。 1234567891011121314let set = new Set([1, 1, 2, 3, 4, 5]);console.log(set)//Set(5)&#123;1,2,3,4,5&#125;,一个对象，自动把第二个1去掉。 let set = new Set([\"hdcms\", \"houdunren\"]); // console.log(set.clear()); // console.log(set.delete(\"hdcms.com\")); console.log(set.size); // console.log(set.delete(\"hdcms\")); // console.log(set.size); // console.log(set.values()); //add has // console.log(set.size); // console.log(set.has(\"hdcms.com\")); // let set = new Set([...\"hdcms\"]); // console.log(set); 对象中的属性名都会被转换成字符串。 常见的语法 add()，添加元素 clear()，清空容器 size()，获取元素个数 keys(),entries,values()，返回的都是容器里的各个值；因为set容器没有键，只有值，或者说键与值是一样的 has()，判断是否有元素。数组中用的是includes() 与数组类型之间的相互转换！！！ 12345678910let set = new Set([\"hdcms\", \"houdunren\"]); console.log(Array.from(set));//from方法转换数组 console.log([...set]);//三点展开式转换数组 let hd = new Set(\"123456789\"); console.log(hd);//set hd = new Set([...hd].filter(item =&gt; item &lt; 5));//转换为数组，使用数组的filter方法，并返回一个数组，并将这数组又转换为set类型 console.log(hd);//set类型 let array = [1, 2, 3, 4, 5, 2, 3, 1]; array = [...new Set(array)];//去重了 console.log(array);//去重后的数组 多多利用类型之间的转换。 常用例子！！并集，交集，差集的实现！ 核心三点展开式，以及filter过滤函数与includes函数的联合使用 123456789101112let a=new Set([1,2,3,4,5]) let b=new Set([9,5,2,7]) //并集 console.log(new Set([...a,...b]))//将a与b先装为数组合并，在将合并后的数组转为set（自动去重） //交集 console.log([...a].filter((value =&gt; &#123; return [...b].includes(value)//返回b.has(value)，[2, 5]，返回共有的。 &#125;))) //差集，过滤掉b有的元素 console.log([...a].filter((value =&gt; &#123; return ![...b].includes(value)//返回!b.has(value)，[1, 3, 4]，返回不是公有的 &#125;))) 2，WeakSet类型与Set类型一样，里面的值是不重复的；但是WeakSet容器中只能放引用类型，以数组传参！方法和Set类型一致。 WeakSet的弱引用特性是，WeakSet不会使得应用类型的次数增加。 1234567 let hd = &#123; name: \"后盾人\" &#125;;//引用次数1 let edu = hd;//引用次数2 let set = new WeakSet();//依然是2,如果是arr=[hd],会使得引用次数增加为3 set.add(hd); hd = null;//1 edu = null;//0console.log(set)//No properties Weakset无法使用for-in与for-of循环遍历方法，也没有获取数量方法keys()方法。被屏蔽掉了。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Set类型","slug":"Set类型","permalink":"https://zhoubb96.github.io/tags/Set%E7%B1%BB%E5%9E%8B/"}]},{"title":"JS-Symbol特性","date":"2020-06-15T08:12:24.000Z","path":"2020/06/15/JS-Symbol特性/","text":"Symbol前缀标识可以唯一标识一个数据，可以理解为永不重复的字符串 两种声明方式 123456789101112131415//方式一，字面量方法，symbol不需要new关键字let a=symbol(\"woshia\")let b=symbol(\"woshib\")console.log(typeof a)//symble//方式二，for方法let c = Symbol.for(\"zbb\");//for方法，系统会记录下这个Symbollet d = Symbol.for(\"zbb\");//第二次会查之前是否已经声明过，如果声明过就直接拿过来。反复使用同一个Symbol的情况console.log(c==d)//trueconsole.log(a==b)//falseconsole.log(Symbol.keyFor(c))//zbbconsole.log(Symbol.keyFor(a))//undefined,只有for方法定义的才能使用keyFor方法console.log(a)//symbol(woshia)console.log(a.toString())//symbol(woshia),toString依然是返回symbol本身console.log(a.description)//woshia，只有description才是返回内部的描述。注意，是a.description而不是a.description，也就是说description是一个数据属性，不是方法属性 使用实例 1234567891011121314 let user1 = &#123; name: \"李四\", key: Symbol()//1 &#125;; let user2 = &#123; name: \"李四\", key: Symbol()//2,就算没有传入参数，1和2也是不相等的 &#125;; let grade = &#123; [user1.key]: &#123; js: 100, css: 89 &#125;,//由于键也是一个变量所以要用[]先取值 [user2.key]: &#123; js: 35, css: 55 &#125; &#125;;//如果不使用symbol，那么同名情况，会被最后一个覆盖 console.log(grade[user2.key]);//&#123; js: 35, css: 55 &#125; Symbol属性是私有属性，无法被for-in或者for-of遍历到S遍历所有属性的方法；for-in与for-of遍历普通属性；getOwnPropertySymbols()遍历Symbol属性；Reflect.ownKeys()遍历所有属性。 12345678910111213let hd = &#123; name: \"李四\", [symbol]: \"lisi\" &#125;; for (const key in hd) &#123; console.log(key);//只有name &#125; for (const key of Object.getOwnPropertySymbols(hd)) &#123; console.log(key);//只有symbol &#125; for (const key of Reflect.ownKeys(hd)) &#123; console.log(key);//所有属性，name与Symbol &#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Symbol类型","slug":"Symbol类型","permalink":"https://zhoubb96.github.io/tags/Symbol%E7%B1%BB%E5%9E%8B/"}]},{"title":"JS数组六","date":"2020-06-14T08:02:45.000Z","path":"2020/06/14/JS数组六/","text":"map映射数组与应用类型处理map(callbacks(value,index,arr))，return的是value。前面那些函数是返回的布尔值，这个函数直接返回值value。返回的也是一个新数组。原数组不会改变，需要定义一个变量接受新数组。引用类型因为传的是地址，如果不写return语句会直接改变原值；普通类型由于是传值的形式，不写return语句也不会改变原值 1234567let arr = [\"zbb\", \"ycy\"]let arr2 = arr.map((value, index) =&gt; &#123; value = value + \"gkd\" return value //这一句在引用类型与非引用类型会产生不同的结果&#125;)console.log(arr)// [\"zbb\", \"ycy\"]console.log(arr2)//[\"zbbgkd\", \"ycygkd\"]","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"map()","slug":"map","permalink":"https://zhoubb96.github.io/tags/map/"}]},{"title":"JS数组五","date":"2020-06-14T07:39:11.000Z","path":"2020/06/14/JS数组五/","text":"过滤函数filter()filter(callbacks(value,index,arr)) 不难发现这些方法都接受一个回调函数，回调函数返回一个布尔值（判断条件），并且，参数列表都是值value在前面。 1234567891011let arr=[\"zbb\",\"ycy\"]// 不定义过滤条件，全返回arr.filter((value,index)=&gt;&#123; console.log(index,value)//0 \"zbb\" 1 \"ycy\"&#125;)let arr1=arr.filter((value,index)=&gt;&#123; return value==\"ycy\"//条为值为ycy才取出&#125;)console.log(arr1)//只返会[\"ycy\"]，注意返回的是数组//上面两个其实只是只用到了value，所以index其实可以不用传入 1234567891011121314 //自定义filter function filter(arr, expect) &#123;//expect是一个数组，两个数组的互相比较 //定义新数组返回过滤后的结果 let newArray = [] for (const value of arr) &#123; if (expect.includes(value) === false) &#123;//如果expect不包含这个元素 newArray.push(value) &#125; &#125; return newArray//返回新数组 &#125;arr=[1,2,3,4,5] arr2=[2,3]console.log(filter(arr,arr2))//[1, 4, 5]","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"filter()","slug":"filter","permalink":"https://zhoubb96.github.io/tags/filter/"}]},{"title":"JS数组四","date":"2020-06-14T07:03:45.000Z","path":"2020/06/14/JS数组四/","text":"利用every()与some()进行数组判断every(callbacks(value,index,arr))，回调函数返回一个布尔值。全部为真才为真 123456let arr=[\"zbb\",\"ycy\"]arr.every((value,index)=&gt;&#123; console.log(index,value)//0 \"zbb\" 1 \"ycy\"，是个数组 return true//如果不return true就会只执行一次 //有一个为假就为假，可以用来进行同一判断，也就是return后面放一个表达式&#125;) some(callbacks(value,index,arr))，回调函数函数返回一个布尔值。任何一个为真就为真 1234arr.some((value,index)=&gt;&#123; console.log(index,value)//如果不加return true就会输出，0 \"zbb\" 1 \"ycy\" return true//加上return true就只执行一次，和上面反过来的&#125;) 因为不加return语句，默认返回undefined，被转化为false，所以every()第一次执行后便停止，false不再执行； 而some()遇到false不会停止。 every遇false停止 some遇到true停止 1234567891011let keywords = [\"php\", \"js\"]; let title = document.querySelector('[name=\"title\"]'); title.addEventListener(\"keyup\", function() &#123;//绑定事件 const res = keywords.some(keyword =&gt; &#123;//遍历取出keyword进行比较 return this.value.indexOf(keyword) != -1; //检查keyup事件输入的值value中是否有关键字数组keywords中的任何一个关键字keyword &#125;); document.querySelector(\"span\").innerHTML = res ? \"\" : \"必须包含\" + keywords.join(\",\") + \"关键词\"; &#125;);","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"every(),some()","slug":"every-some","permalink":"https://zhoubb96.github.io/tags/every-some/"}]},{"title":"数据结构与算法-双向链表","date":"2020-06-13T13:47:14.000Z","path":"2020/06/13/数据结构与算法-双向链表/","text":"单向链表存在一个明显的缺点：返回前一个节点是非常困难的。 引入双向链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175 function DoublyLinkedList() &#123; //链表属性 this.length = 0 this.header = null this.tail = null function Node(data) &#123; //节点属性 this.data = data this.prev = null this.next = null &#125; //1，在尾部添加元素 DoublyLinkedList.prototype.append = function (data) &#123; let node = new Node(data) //链表为空 if (this.length === 0) &#123; this.header = node//成为第一个节点 this.tail = node//同时也是最后一个节点，最后一个节点不用找 &#125; else &#123; this.tail.next = node node.prev = this.tail this.tail = node &#125; this.length++ &#125; //2,toString,从前向后 DoublyLinkedList.prototype.toString = function () &#123; //this直接调用向后方法 return this.backwardString() &#125; //3，backwardString从前向后 DoublyLinkedList.prototype.backwardString = function () &#123; let current = this.header let resultString = \"\" while (current) &#123; resultString += current.data + \" \" current = current.next &#125; return resultString &#125; //4，forwardString从后向前 DoublyLinkedList.prototype.forwardString = function () &#123; let current = this.tail let resultString = \"\" while (current) &#123; resultString += current.data + \" \" current = current.prev &#125; return resultString &#125; //5,insert在指定位置插入元素 DoublyLinkedList.prototype.insert = function (position, data) &#123; let node = new Node(data) let current = this.header if (position &lt; 0 || position &gt; this.length) &#123; return false &#125; if (this.length === 0)//先判断链表是否为空，再判断位置 &#123; this.header = node this.toString = node &#125; else &#123; if (position === 0) &#123;//头部添加 node.next = this.header this.header.prev = node this.header = node &#125; else if (position === this.length) &#123;//尾部添加 node.prev = this.tail this.tail.next = node this.tail = node &#125; else &#123;//中间添加,位置到下标，要减去一 for (let index = 1; index &lt; position; index++) &#123; current = current.next &#125; current.next.prev = node node.next = current.next node.prev = current current.next = node &#125; &#125; this.length++ &#125; //6.get，查找，可以用二分查找法改进。 DoublyLinkedList.prototype.get = function (position) &#123; if (position &lt;= 0 || position &gt; this.length) return null let current = this.header for (let index = 1; index &lt; position; index++) &#123; current = current.next &#125; return current.data &#125; //7，indexOf获取指定元素的位置 DoublyLinkedList.prototype.indexOf = function(data)&#123; current=this.header let index=1 while(current!=null&amp;&amp;current.data!=data)&#123; current=current.next index++ &#125; if(current!=null) return index return -1 &#125; //7，update方法，更新指定位置的元素 DoublyLinkedList.prototype.update = function (position,data) &#123; if (position &lt;= 0 || position &gt; this.length) return false let current = this.header for (let index = 1; index &lt; position; index++) &#123; current = current.next &#125; current.data=data &#125; //8,removeAt移除指定位置元素 DoublyLinkedList.prototype.removAt = function (position) &#123; if (position &lt;= 0 || position &gt; this.length) return null let current=this.header if(this.length===0) return false//空链表 if(this.length===1)&#123;//只有一个元素 this.header = null this.tail = null &#125; //长度大于1 if(position===1)&#123;//移除第一个 this.header.next.prev=null //this.header.next=null这句可以不写，因为上面那句会是的被删除节点失去引用被自动回收 this.header=this.header.next &#125;else if(position===this.length)&#123;//移除最后一个 current=this.tail this.tail.prev.next=null this.tail=this.tail.prev &#125;else&#123; for (let index=1;index&lt;position;index++)&#123;//移除中间的 current=current.next &#125; current.prev.next=current.next current.next.prev=current.prev &#125; this.length-- return current.data &#125; //9,remove移除定位置的元素，两个方法相互调用 DoublyLinkedList.prototype.remove = function(data)&#123; //先获取位置 let position=this.indexOf(data) //删除指定位置 this.removAt(position) &#125; &#125; //测试 let list = new DoublyLinkedList() list.append(\"abc\") list.append(\"cba\") list.append(\"nba\") list.append(\"swk\") list.insert(0, \"开头\") list.insert(5, \"结尾\") list.insert(3, \"中间\") console.log(list)//DoublyLinkedList &#123;length: 7, header: Node, tail: Node&#125; console.log(list.toString())//开头 abc cba 中间 nba swk 结尾 console.log(list.forwardString())//结尾 swk nba 中间 cba abc 开头 console.log(list.get(1)) //开头 console.log(list.get(7)) //结尾 list.update(1,\"这是开头\") list.update(7,\"这是结尾\") console.log(list.removAt(7))//这是结尾 console.log(list.toString())//这是开头 abc cba 中间 nba swk console.log(list)//DoublyLinkedList &#123;length: 6, header: Node, tail: Node&#125; console.log(list.indexOf(\"这是开头\"))//1 list.remove(\"中间\") console.log(list.toString())//这是开头 abc cba nba swk//用position表示读取位置从1到this.length//用position表示插入位置从0到this.length","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS数组三","date":"2020-06-13T09:43:17.000Z","path":"2020/06/13/JS数组三/","text":"关于sort()方法 接受的是一个函数，返回排序后的数组 123456let arr=[9,5,2,7]let result = arr.sort(function (a,b) &#123;//return a-b//返回负数从小到大，[2, 5, 7, 9]//return b-a//返回正数从大到小，[9, 7, 5, 2]&#125;)console.log(result) 1234567891011121314151617181920let arr=[9,5,2,7]//定义sort，冒泡实现，动态的（反复调用callback）function sort(arr,callback) &#123; for (const n in arr) &#123; for (const m in arr) &#123; //一个很奇怪的排序，单纯看返回值，每次都会调用 if (callback(arr[n], arr[m]) &lt; 0) &#123;//接受实参，返回一个数（正或者负）,这个callback会被反复调用，每次都判断 let temp = arr[n] arr[n] = arr[m] arr[m] = temp &#125; &#125; &#125; return arr&#125;//调用sortlet result = sort(arr,function (a,b) &#123;//两个形参要在调用时接受实参 return b-a &#125;)console.log(result) 关于reduce()方法reduce(callbacks(pre,cur,index,arr),init)，它会存储上一次运行的结果作为下一次运行的第一个参数。pre一开始是第一个值，后面就是上次函数运行的结果，cur从第二个值开始。最终返回所有元素运行后的结果。可用作统计用途（统计器，累加器，最大值等等，利用其保存上一次运行结果的特点） 12345678910111213141516171819202122232425262728293031 let arr = [1, 2, 3, 4, 5, 6] let res = arr.reduce((pre, cur) =&gt; &#123; console.log(pre)//1,3,6,10,15,21 console.log(cur)//2,3,4,5,6 return pre + cur &#125;) console.log(res)//21 let res2=arr.reduce((pre, cur) =&gt; &#123; console.log(pre)//0,1,3,6,10,15,21，pre有初始值后，pre和cur的位置都会前移 console.log(cur)//1,2,3,4,5,6 return pre + cur &#125;,0)//0是prev的初始值，如果这里是1，那么最后结果会变成22 console.log(res2)//21 //获取价格超过1万元商品的名称，当然filter更加方便。let cart = [ &#123; name: \"iphone\", price: 12000 &#125;, &#123; name: \"imac\", price: 25000 &#125;, &#123; name: \"ipad\", price: 3600 &#125; ]; function getNameByPrice(goods, price) &#123; return goods .reduce(function(arr, cur) &#123; if (cur.price &gt; price) arr.push(cur); return arr; &#125;, [])//令arr的初值为一个数组，初值的类型可以有很多种。 .map(function(item) &#123; return item.name; &#125;);//链式调用 &#125; console.table(getNameByPrice(cart, 10000)); reduce非常好用，要多用!!!!!!!!!!! includes与reduce联合使用在去重的时候很常用。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"sort(),reduce()","slug":"sort-reduce","permalink":"https://zhoubb96.github.io/tags/sort-reduce/"}]},{"title":"JS数组二","date":"2020-06-13T09:00:45.000Z","path":"2020/06/13/JS数组二/","text":"旧的查找方法indexOf()，lastIndexof()，includes()，这几个方法数组和字符串都有查找操作且接口一样，但是查找的内容是要严格输入的！ 1234let arr=[1,2,3,4,5,\"6\"]console.log(arr.indexOf(2))//1console.log(arr.indexOf(6))//-1，没有数字6，查找失败console.log(arr.indexOf(\"6\"))//5，字符串\"6”的下标为5 新的查找方法find()与findIndex() find(callback(value)),find()内部参数是个回调函数，需要你自定义，而且返回的是值，解决引用类型查找，因为引用类型查找的是地址。 findIndex(callback(value)),findIndex()同样也是接受一个函数，和find()一致，不同的是它返回的是位置 1234567arr.find(function (item) &#123;//console.log(item)//所有值全1 2 3 4 5 6//return true//1返回第一个// return item==2//返回值2// return item==200//undefined，没有200这个值 &#125;) 123456789101112131415//自己实现一个find，接受一个数组和一个回调函数function find(array,callback)&#123; for(let value of array)&#123; if(callback(value))&#123;//接受实参，回调函数返回true，查找成功 return value &#125; &#125; return undefined&#125;//调用result=find(arr,function(item)&#123;return item===2&#125;)//打印console.log(result)//2","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"find(),findIndex()","slug":"find-findIndex","permalink":"https://zhoubb96.github.io/tags/find-findIndex/"}]},{"title":"移动端适配四","date":"2020-06-13T02:30:13.000Z","path":"2020/06/13/移动端适配四/","text":"位置获取 clientX：当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等），鼠标相对于浏览器（这里说的是浏览器的可视区域）x轴的位置； screenX：当鼠标事件发生时，鼠标相对于显示器屏幕x轴的位置； offsetX：当鼠标事件发生时，鼠标相对于事件源x轴的位置，注意判断正负 高度获取 clientHeight：只包括padding高度。 offsetHeight：包括padding、border、水平滚动条的高度、但不包括margin的元素的高度。 scrollHeight：当本元素的子元素比本元素高且overflow=scroll时，本元素会scroll，这时：scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。 关于移动端的定位 移动端要少用固定定位，因为固定定位是相对于是扣的，而移动端有三个视口，较为复杂。使用绝对定位模拟固定定位。 1，禁止系统滚动条s 2，让应用的滚动条出现在顶层元素，顶层不会影响初始滑块的位置 C:\\Users\\zhoub\\AppData\\Roaming\\npm\\lessc $FileParentDir(less)$\\less$FileDirPathFromParent(less)$$FileName$ C:\\Atguigu\\尚硅谷无视频版本\\8.前端学科–项目实战\\尚硅谷前端项目【谷粒音乐】教程\\code\\QQ音乐\\css\\lesss","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"数据结构与算法-单向链表","date":"2020-06-12T12:37:31.000Z","path":"2020/06/12/数据结构与算法-单向链表/","text":"链表1，与链表相比数组的缺点： 必须申请连续的储存空间 在开头以及中间插入数据要进行大量的位移 链表可以很好的解决这两个问题。链表可以充分利用计算机储存空间，并且在插入和删除数据的时候要方便一些，不用移动元素（寻找插入位置时要费劲些，但是比移动元素开销少）时间复杂度可以达到o(1) 2，链表也有它的缺点: 访问查询时总得从头开始访问 无法通过下标直接访问元素，要遍历判断循环找。 链表有带头结点与不带头指针两种。今后自己统以用带头指针的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function LinkedList() &#123; function Node(data) &#123; this.data = data this.next = null &#125; //属性：头指针，当前指针，长度 this.header = null this.length = 0//注意实时更新 //1,append追加方法，在尾部添加元素 LinkedList.prototype.append = function (data) &#123; let newNode = new Node(data) //是第一个元素，直接修改头指针 if (this.length===0) &#123;//if (this.header===null) this.header = newNode &#125; else &#123; let current = this.header //不是第一个元素，循环找到最后一个节点 while (current.next)&#123;//直到他的next为空，就是最后一个 current = current.next &#125; current.next = newNode &#125; //更新长度 this.length++ &#125; //2,insert在指定位置添加元素 LinkedList.prototype.insert = function(position,data)&#123; //边界判断 if(position&lt;0||position&gt;this.length)&#123;//可以等于 return false &#125; let newNode = new Node(data) let current = this.header //在头部添加 if(position===0)&#123; newNode.next=this.header this.header=newNode &#125;else &#123; //不是在头部,所以i从1开始 for (let i=1;i&lt;position;i++)&#123; current = current.next &#125; newNode.next = current.next current.next = newNode &#125; this.length++//更新长度 return true &#125; //3，将链表转换为字符串返回 LinkedList.prototype.toString = function()&#123; let current = this.header let listString = \"\" //循环获取节点 while (current)&#123; listString+=current.data+\" \" current=current.next &#125; return listString &#125; //4，获取指定下标的元素 LinkedList.prototype.get = function(index)&#123; if(index&lt;0||index&gt;=this.length)&#123; return null &#125; let current = this.header for(let i=0;i&lt;index;i++)&#123; current=current.next &#125; return current.data &#125; //5，获取元素的索引 LinkedList.prototype.indexOf = function(data)&#123; let current = this.header for(let index=0;index&lt;this.length;index++)&#123; if(current.data===data)&#123; return index &#125; current=current.next &#125; return -1 &#125; //6，删除指定位置的元素 LinkedList.prototype.removeAt = function(position)&#123; //越界判断多次会用到，可以抽离出来成一个函数 if(position&lt;0||position&gt;=this.length)&#123; return false &#125; let current = this.header let previous = null if(position===0)&#123; this.header=current.next &#125;else&#123; for(let i=0;i&lt;position;i++)&#123; previous = current current=current.next &#125; previous.next=current.next &#125; this.length-- return current.data &#125; &#125; //测试let list=new LinkedList()list.append('abc')list.append('cba')list.append('nba')list.insert(3,'swk')console.log(list)console.log(list.toString())//abc cba nba swkconsole.log(list.get(3))//swkconsole.log(list.indexOf('swk'))//3list.removeAt(2)console.log(list.toString())//abc cba swk","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS日期相关","date":"2020-06-12T09:08:14.000Z","path":"2020/06/12/JS日期相关/","text":"1，时间与时间戳获取1234567891011121314151617let date = new Date()//可传参，不传参就是当前时间 console.log(date);//date为对象 console.log(date.getFullYearh()) console.log(date.getMonth()+1) console.log(date.getDate()) console.log(date.getHours()) console.log(date.getMinutes()) console.log(date.getSeconds()) console.log(date*1)//返回时间戳，可以用来计算运行时间//可以封装一个函数使用模板字符串输出格式化的日期let date2 = Date() console.log(date2);//date2为字符串 console.log(date2*1)//返回NaN//标签配合使用console.time(\"for\")console.timeEnd(\"for\") 2，时间与时间戳的相互转换123456789//时间-&gt;时间戳console.log(date.valueOf())console.log(date*1)console.log(Number(date))console.log(date.getTime())timestamp = date*1//时间戳-&gt;时间date3 = new Date(timestamp)","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS基本类型的类型转换","date":"2020-06-12T08:16:23.000Z","path":"2020/06/12/JS基本类型的类型转换/","text":"1，数值类型基本转换 NaN指不是一个数字，NaN不能互相比较（NaN==NaN无结果） 使用Number.isNaN()判断 使用Object.is(2/&quot;1&quot;, NaN)判断 toString() Number()，一般从键盘获取的都是字符串要先转换。或者用parseInteresting() 2，布尔值隐式转换 数值类型除了0，都为真 字符串类型除了空串，都为真 引用类型永远为真（不管对象或者数组是不是空） 3, 数学方法Math.max/min/ceil/floor/round/random 最大，最小，向上取整，取整，四舍五入，随机数区间为（0，1）。 初见apply数组传参的优点 123grade &#x3D; [119,64,69,138]console.log(Math.max(grade))&#x2F;&#x2F;报错，因为Math.max()只支持多参数传参，不支持数组console.log(Math.max.apply(null,grade))&#x2F;&#x2F;apply可以以数组传参数","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"数据结构与算法-优先级队列","date":"2020-06-11T13:30:37.000Z","path":"2020/06/11/数据结构与算法-优先级队列/","text":"优先级队列 普通的队列插入一个元素，该元素位于最后端，在前面的数据都处理完后才会处理后插入的数据。 优先级队列在插入时会考虑该数据的优先级（在普通队列添加一个属性存储优先级） 在处理时根据优先级决定处理顺序，也就是根据优先级调整插入数据的位置 两个问题：1，元素多了一个优先级属性，这就需要用对象封装；2，入队时要比较插入位置 优先级队列数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 //优先级队列数组实现 function PriorityQueue()&#123; function QueueElement(element,priority)&#123; this.element=element this.priority=priority &#125; //封装属性（对象数组） this.items = [] //1,入队，根据优先级入队 PriorityQueue.prototype.enqueue = function(element,priority)&#123; //获取原先队列长度 length=this.items.length //创建队列元素 var queuelement=new QueueElement(element,priority) //原队列无元素就直接插入 if(length==0)&#123; this.items.push(queuelement) &#125;else&#123; //原队列有元素，1，在原队列间插入；2，在原队列后面追加 var insert = false //这里只能获取到已有位置，如果在最后插入获取不到位置,就不能解决在尾部插入的问题 for(let i=0;i&lt;length;i++)&#123; //比较各个元素的优先级，寻找插入位置(规定数字越小优先级越高)（比较对象的属性值） if(queuelement.priority&lt;this.items[i].priority)&#123; insert = true //1，在原队列间插入 this.items.splice(i,0,queuelement)//这一条是最简做法，直接插入移动全全完成 break &#125; &#125; //2，在原队列后面追加 if(!insert)&#123; this.items.push(queuelement) &#125; &#125; &#125; //2，出队，前面出队 PriorityQueue.prototype.dequeue = function()&#123; return this.items.shift() &#125; //其他操作和栈一样了 PriorityQueue.prototype.size = function()&#123; return this.items.length &#125; PriorityQueue.prototype.front = function () &#123; return this.items[0] &#125; &#125;//验证 let pq = new PriorityQueue() pq.enqueue('abc',111) pq.enqueue('cba',200) pq.enqueue('nba',50) pq.enqueue('nba',66) console.log(pq)","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS字符串与Number-高级操作","date":"2020-06-11T10:03:52.000Z","path":"2020/06/11/JS字符串与Number-高级操作/","text":"1,截取操作substring(beg,end), 起始位置与结束位置，不支持负数 slice(beg,end),起始位置与结束位置，支持负数 substr(beg,len),起始位置与截取长度。 这三个都不会改变原字符串 12345let name = \"Zhoubinbin\" console.log(name.slice(1,3))//ho;起始与结束位置，输入负数则起始位置从后算。 console.log(name.slice(-3,-1))//bi console.log(name.substring(1,3))//ho；同上，只是不可以使用负数（输入负数当0看待） console.log(name.substr(1,3))//hou；起始位置可以用负数与截取长度 2,检索操作indexOf()，lastIndexOf() 123456let name &#x3D; &quot;Zhoubinbin&quot; console.log(name.indexOf(&quot;i&quot;))&#x2F;&#x2F;5；从头开始，返回字符“i”第一次出现的下标 console.log(name.indexOf(&quot;i&quot;,6))&#x2F;&#x2F;8；6表示从什么位置开始查找，忽略前面 console.log(name.includes(&quot;i&quot;))&#x2F;&#x2F;true；返回布尔值 console.log(name.includes(&quot;i&quot;,9))&#x2F;&#x2F;false console.log(name.lastIndexOf(&quot;i&quot;))&#x2F;&#x2F;8;从后开始查找 3,替换操作stringObject.replace(regexp/substr,replacement) 12let name = \"Zhoubinbin\" console.log(name.replace('i','o'))//Zhoubonbin只改了第一个i，如果要全部替换必须使用正则表达式 4,拆分和拼接操作","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"substring(),slice(),substr()","slug":"substring-slice-substr","permalink":"https://zhoubb96.github.io/tags/substring-slice-substr/"}]},{"title":"JS字符串与Number-基本操作.md","date":"2020-06-11T09:30:46.000Z","path":"2020/06/11/JS字符串与Number-基本操作/","text":"字符串的常见操作有 length，长度 toUpperCase(), toLowerCase(),大小写转换 trim()，去除所有空格 字符串拼串 可以直接用+号（如果不做类型转换+默认是拼串，所以要做数学运算的的话要转换类型1，乘一个1就自动转换；2，Number（str）方法） contact方法。（join是数组的方法）, 123456789 let name = \" Zhoubinbin \" console.log(name.length)//12 console.log(name.toUpperCase()) ZHOUBINBIN console.log(name.toLowerCase()) zhoubinbin console.log(name.trim().length)//10const string = \"99\" console.log(string+1)//991 console.log(string*1+1)//100 console.log(Number(string)+1)//100 字符串的拆分 split(&quot;str&quot;) 用字符串中的某个符号str拆分一个字符串，将拆分结果放入一个数组，返回这个数组。如果不传str，仅仅是split(&quot;&quot;)那就是逐个字符拆开。返回的是一个数组 123 let name = \"Zhoubinbin,yangchengyu\" console.log(name.split(\"\"))// [\"Z\", \"h\", \"o\", \"u\", \"b\", \"i\", \"n\", \"b\", \"i\", \"n\", \",\", \"y\", \"a\", \"n\", \"g\", \"c\", \"h\", \"e\", \"n\", \"g\", \"y\", \"u\"]不传参全部单个拆分console.log(name.split(\",\"))//[\"Zhoubinbin\", \"yangchengyu\"]按逗号拆分为两个 Number相关的常用操作123456789var num=1.6 console.log(parseInt(num))//1；可以解析字符串，把字符串开头的整提取出来，舍弃掉其他字符，返回一个整数 console.log(Math.floor(num))//1；返回小于等于num的最大整数，向下取整console.log(Math.round(num))//2；四舍五入console.log(Math.ceil(num))//2;向上取整 console.log(parseFloat(num))//1.6；可以解析字符串，把字符串开头的浮点数取出来，舍弃掉其他字符，返回一个浮点数 console.log(Math.fround(num))//1.600000023841858单精度浮点数console.log(Number.isInteger(num))//flaseconsole.log(num.toFixed(2))//1.60","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS-for-in与for-of的使用","date":"2020-06-11T06:58:03.000Z","path":"2020/06/11/JS-for-in与for-of的使用/","text":"1，forEach定义两个形参接受值与键，同时遍历。注意，forEach第一个参数是值（value）在前！ forEach((value,index)=&gt;{}) 2，for-in（数组与对象都能用）数组遍历的是数组下标；对象遍历的是键 for(let index in arr) for(let key in arr) 3，for-of（原生对象不能使用）for(let value of arr) for(let iterator of obj) 也就是值必须是可迭代的才能正确使用。 遍历的是值，且这个值是重新开辟出来的形参（基本类型和引用类型会有不同结果）；原生对象不能使用 123456789101112131415161718192021222324252627282930313233343536let arr = [ &#123;tittle:\"第一章\", lesson: 1&#125;, &#123;tittle:\"第二章\", lesson: 2&#125;, &#123;tittle:\"第三章\", lesson: 3&#125; ]//1，forEach arr.forEach((value,index)=&gt;&#123; console.log(index)//返回下标0，1，2 console.log(value)//返回对象 &#125;)//2，for-in与for-of //对数组使用 //arr[0],,arr[2] //for-in for(let i in arr)&#123; console.log(i)//返回结果是0,1,2 console.log(arr[i])//返回的是对象 &#125; //for-of for(let i of arr)&#123; console.log(i)//返回是对象 console.log(arr.indexOf(i))//0,1,2 &#125; // 对第一个对象arr[0]使用 //for-in for(let i in arr[0])&#123; console.log(i)//返回的是tittle和lesson，也就是键 console.log(arr[0][i])//返回的是第一章和1，也就是值 &#125; //for-of，会直接报错a[0]不可以迭代 for(let i of arr[0])&#123; console.log(i) console.log(arr[0][i]) &#125; 总结：就是数组的话for-in与for-of都可以用，对象不能使用for-of。","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS控制结构","date":"2020-06-11T06:15:01.000Z","path":"2020/06/11/JS控制结构/","text":"控制结构本身很容易，难点在于灵活使用它们设计解决算法问题1.条件控制结构有1，if和else；2，三元表达式；3switch这三种。在js当中switch语句中的case后面是可以加判断语句的 2.循环控制结构1，while循环；2，dowhile循环；3，for循环 建议在不确定循环次数的时候使用while循环。 dowhile循环，见名知意do会直接先执行一次，然后才到while的判断里面。 使用循环的时候思考，1，要用几个循环以及每个循环用来干什么？；2，不同层数循环变量之间有没有关系？；3，循环的终止条件 break-continue与label标签的的使用 break会退出整个循环 continue只会跳过循环的本次执行（所以要注意continue的位置） label跳转（go to语句） 1234567891011//初始化计数器（很多时候都要使用到计数器，注意利用好计数器）let count = 0for(let i=1;i&lt;10;i++)&#123; //只取偶数 if(i%2)&#123; //只要前三个 if(count++==3) break continue &#125; console.log(i)&#125;","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"移动端适配三","date":"2020-06-11T01:07:17.000Z","path":"2020/06/11/移动端适配三/","text":"1，三个触屏列表 changedTouches：触发当前事件的手指列表（变化的），用的最多 targetTouches：触发当前事件时元素上的手指列表 touches：触发事件时，屏幕上的手指列表 2，四个常见问题 禁止电话与邮件的默认行为，&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no email=no&quot;&gt;；如果要重新开启可以考虑加一个a标签。 链接高亮，解决方法时添加-webkit-tap-highlight-color:rgba(0,0,0,0),也就是将高亮背景变为透明色 解决按钮圆角默认为圆，解决方法设置-webkit-appearance:none font boosting，浏览器自动放大字体。解决方法是添加最大高度max-height:xxpx 3，关于querySelector与getElementBy…的性能与差异getElementBy…的性能好很多，而且返回的是动态列表的；querySelector性能差些，而且返回的是静态列表，但是querySelector用起来方便。最后推荐多用更优秀的getElementBy…养成习惯","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"数据结构与算法-队列","date":"2020-06-10T14:03:09.000Z","path":"2020/06/10/数据结构与算法-队列/","text":"1，队列的实现因为队列的特点是先进先出，在头front出队尾rear入队进行操作，所以利用数组实现队列就用shift与push，操作头部与尾部数据 12345678910111213141516171819//数组构造队列 function Queue() &#123; this.items = [] //1,入队，后面入队 Queue.prototype.enqueue = function (element) &#123; this.items.push(element) &#125; //2，出队，前面出队 Queue.prototype.dequeue = function () &#123; return this.items.shift() &#125; //其他操作和栈一样了 Queue.prototype.size = function () &#123; return this.items.length &#125; Queue.prototype.front = function () &#123; return this.items[0] &#125; &#125; 编程题，利用队列（链表）解决击鼓传花，报数出列或者叫约瑟夫环问题，利用队列的话，边界判断就容易很多。（三种解法，数组（易于理解），循环链表（要构造链表），递归（形式最为简洁）） 123456789101112131415161718192021222324252627//报数变量（1到5）、标记值（5）和累加变量（1—），报数变量在到达标记值的时候重新赋值，再用累加变量对标记值取余数得到队列的下标 function passgame(nameList,tag)&#123; //1,创建队列 var queue = new Queue() //2，初始入队 for(let i=0;i&lt;nameList.length;i++)&#123; queue.enqueue(nameList[i]) &#125; //3,报数开始 while(queue.size()&gt;1)&#123;//不知道具体循环次数时用while //此时不是tag，重新加入加入队列 for (let i = 1; i &lt; tag; i++) &#123;//报数从1开始，或者用0到tag-1也行。 queue.enqueue(queue.dequeue())//将取出的元素重新入列 &#125; //此时是tag时，将其从队列删除 queue.dequeue() &#125; var endName = queue.front() alert(endName) return nameList.indeOf(endName)//上面的操作没有操作namelist而是操作的queue，最后找到剩下的元素在原先列表的位置 &#125; names=['Lily','Lucy','Tom','Lilei','Tomi'] passgame(names,3)//测试用例//数组方法，如果是数组方法，不想修改原数组的话，要再建立一个数组来进行操作（因为这个操作的数组最后只有一个元素下标必然为0，要利用它的值在原数组里找下标，如果只要返回值那么一个数组就够了）//递归方法","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法-栈","date":"2020-06-10T08:20:09.000Z","path":"2020/06/10/数据结构与算法-栈/","text":"1，JS的数组结构，可以直接调用API（编程题考察的一般都是数组，所以JS基础最重要，数组的操作需要进行十分熟练） 数组的插入和删除是比较麻烦，原因是需要不断的移动数据。但是，数组通过下标查询以及修改元素的时候，效率是很高的。 除了数组，其他的结构都是自己构造出来的，一般是利用对象加指针进行实现。（比如树就是递归出来的） 2，栈结构（是要自己实现的？） 因为栈的特点是先进后出，且进出都在一个位置操作，那么基于数组实现就是只操作数组尾部数据，也就是push与pop（那么队列就是unshift与pop或者shift与push） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//基于数组实现栈，外部是栈，内部是数组&lt;script&gt; //栈的封装实现,利用数组的push和pop，始终都在数组尾部进行操作（就符合了栈的特性） function Stack()&#123; //属性 this.items = [] //操作 //1，压栈，尾部添加 Stack.prototype.push = function(element)&#123;//需要传参，下面的不用 this.items.push(element) &#125; //2，弹栈，尾部删除 Stack.prototype.pop = function()&#123; return this.items.pop() &#125; //3，查看栈顶，用下标查询最后一个元素 Stack.prototype.peak = function()&#123; return this.items[this.items.length-1] &#125; //4,判断是否为空，利用数组长度进行判断 Stack.prototype.isEmpty = function()&#123; return this.items.length==0 &#125; //5，获取栈的长度，也就是数组的长度 Stack.prototype.size = function()&#123; return this.items.length &#125; //6，转换为字符串，遍历+拼串 Stack.prototype.toString = function()&#123; var resultString = ' '//设置一个初始空字符串 for(let i =0;i&lt;this.items.length;i++)&#123; resultString += this.items[i] + ' '//拼串1 2 3 4以空格分开了 &#125; return resultString &#125; &#125; var s = new Stack() s.push(1) s.push(2) s.push(3) s.push(4) s.pop() console.log(s) console.log(s.isEmpty()) console.log(s.peak()) console.log(s.toString()) &lt;/script&gt;//基于链表实现（二级考试题中出现过的） 利用栈可以进制的转换。(依次相除将所得结果依次压栈，最后出栈后就是结果)，当然利用数组也可以，只是输出的时候要手动调整顺序 1234567891011121314151617181920212223//利用栈的进制转换函数//设置两个变量用来存储商和余数，余数压栈，商继续做除法，一直到商为0 function dec2bin(decNumber)&#123; //1，创建栈对象用以存储 var stack = new Stack //2，循环操作 while(decNumber &gt; 0)&#123; element = decNumber % 2 stack.push(element)//可以直接优化为一句stack.push(decNumber%2) //decNumber = decNumber/2 ；重新赋值,这里如果这样写会出错，因为有小数点 //必须用数学方法Math.floor和parseInt都是返回小于等于x的最大整数: decNumber = Math.floor(decNumber/2) &#125; //3，取出栈中元素并以字符传形式返回 var binaryString = ''//空字符串 while(!stack.isEmpty())&#123; binaryString += stack.pop()//1010，没有和上面一样添加空格分隔 &#125; return binaryString &#125; alert(dec2bin(10))//当然可以做到任意进制互换，这时候就需要传入多个参数","comments":true,"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhoubb96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"JS-Object静态方法与逻辑运算符","date":"2020-06-10T06:30:33.000Z","path":"2020/06/10/JS-Object静态方法与逻辑运算符/","text":"1，Object静态方法一般情况下，常量对象的内部值也是可以改变的。 12345const HOST = &#123; url: \"https://zhoubb96.github.io/\" port: 443&#125;HOST.port = 80//此时可以修改，类似于指针常量指针不可变但是里面的内容可变。 如果同时要禁止对内容得修改，就用到了Object的静态方法 12Object.freeze(HOST)HOST.post = 80 //这条语句不生效，但是在非严格模式不会报错。 2，传值（基本量）与传地址（较大的空间）在JS中，一般变量都是传值。而对象则是传地址，原因是对象（引用类型）所占空间比较大，重新开辟空间资源消耗太大。如果想传值就需要深拷贝。 3，关于null与undefined一个变量在声明而又没有赋值的时候，就会出现null与undefined这两个概念。 如果变量是引用类型，显示null（空对象，null有值，且值为空） 如果变量是基本类型，显示undefined（无值） 4，使用严格模式提高代码质量严格模式是向下约束（自身作用域与子作用域） 1，在没有声明变量的时候提示 2，在同一作用域重复声明的时候提示（主要是var，let等不开严格模式也会提示） 3，在占用系统关键词的时候提示 5，有特色的逻辑运算符(或和与在非布尔值运算时会返回原值)非！ 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 或|| 可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则： 见true返原值, 巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为true，则返回第一个***原值*** ​ 2.如果第一个值为false，则返回第二个***原值*** 12let a = 0||5;//a最后的值为5let b = -5||0;//b的值-5 与&amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，***并返回原值*** 规则：见flase返原值，巧妙利用该短路特性进行赋值。 ​ 1.如果第一个值为false，则返回第一个***原值*** ​ 2.如果第一个值为true，则返回第二个***原值*** 12let a = 0&amp;&amp;5;//a最后的值为0let b = -5&amp;&amp;0;//b的值-0","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"JS变量回顾","date":"2020-06-10T01:30:33.000Z","path":"2020/06/10/JS变量回顾/","text":"编程语言的工作1，合适的数据结构存储数据 2，合适的算法管理数据 也就是经典的等式：程序=数据结构+算法 变量的声明与赋值1，声明开辟空间（一般会有个初始值），同一作用域一般只声明一次（var例外，会覆盖）；不同的作用域可以声明同名变量，不受影响 2，赋值放入指定内容（支持连续等号赋值） Js弱类型，变量的类型由值决定 变量提升（用let！）使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值（undefined）。所以我们可以在变量声明前使用变量（作用）。但是不使用var关键字声明的变量（成为全局变量）不会被声明提前。 1，变量提升不影响内部变量与外部变量的私有特性。 2，但是如果不写var，变量又会变成全局变量，污染全局。 3，var有函数作用域，但是没有块作用域（for循环里的i会影响到外面的i），在此之前一般都是使用立即执行函数来解决无块作用域产生的作用域污染问题；后面出现了let。 4，同一作用域下var重复声明变量不会提醒（会直接覆盖），而let会报错（只能声明一次）。 全局变量保存在window对象里（全局上下文对象） 函数提升使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数（作用），但是使用函数表达式(var fun = function(){})创建的函数没有该特性，变量提升优先级高于函数提升。 函数作用域内的变量保存对应的函数上下文对象里 尽量避免变量提升，尽量利用函数提升。 注意！！！如果在预解析阶段出错，那么整体是不会开始执行的，直接报错","comments":true,"tags":[{"name":"JavaScripe查漏补缺","slug":"JavaScripe查漏补缺","permalink":"https://zhoubb96.github.io/tags/JavaScripe%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"移动端适配二","date":"2020-06-09T01:19:33.000Z","path":"2020/06/09/移动端适配二/","text":"1，一物理像素问题问题描述让1个px单位始终只占据1个物理像素。（通过尺缩比抵消像素比的放大，做到始终1比1） 实现一，整体的rem适配（适合项目比较大情况，一劳永逸）就是在rem适配（只管rem单位）下，依然保持px单位的显示效果；（主体）响应式布局rem（放大再缩小）+（px）变换缩放（缩小） 1234567891011121314151617#test&#123; width: 16rem; height: 1px; margin-top: 1rem; background: black;&#125;(function()&#123; var dpr &#x3D; window.devicePixelRatio||1; var styleNode &#x3D; document.createElement(&quot;style&quot;); var w &#x3D; document.documentElement.clientWidth*dpr&#x2F;16;&#x2F;&#x2F;rem放大dpr倍 styleNode.innerHTML&#x3D;&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;; document.head.appendChild(styleNode); var scale &#x3D; 1&#x2F;dpr;&#x2F;&#x2F;缩回dpr倍（抵消所有以rem为单位的，但是px会被缩小dpr倍，因为一开始px未参与放大） var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;&quot;+scale;&#125;)() 实现二，局部的CSS3方法（再指定的地方适配）配合伪元素123456789101112@media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125;&#125;#test:before&#123; position:absolute;//子绝父相 content:''; display:block; width:100%; height:1px;&#125; 2，移动端事件基础12var item = document.querySelectorAll(\".item\")：专门利用css选择器选择dom，返回静态列表。css也是domvar item = document.getElementByClassName(\"item\");可以用任何选择器，返回动态列表 2.1 触屏事件touchstart–&gt; mousedown touchmove –&gt;mousemove touchend–&gt; mouseup 绑定事件（有3种方法，1，直接在HTML标签里绑定；2，利用Dom绑定；3，利用事件监听器） 123item.addEventListener(\"touchstart\",function()&#123; console.log(\"touchstart\")&#125;)//利用事件监听器来绑定事件。 阻止事件默认行为（调试的时候最终看真机，模拟器和真机的可阻止性不一样） 12345item.addEventListener(\"touchstart\",function(ev)&#123; ev = ev||event console.log(ev.cancelable)//查看事件的默认行为是否可以阻止 ev.preventDefault()//加括号调用&#125;)//利用事件监听器阻止事件默认行为,这里只是阻止了item的默认行为，如果要阻止全体的那么item换成document 在指定区域阻止鼠标右键行为，其他区域不阻止 12345678910111213window.onload = function()&#123; document.oncontextmenu = function()&#123; return false &#125;//禁止了全局，全局无右键菜单 var warp = document.querySelectorAll(\"#warp\") warp.oncontextmenu = function(ev)&#123; ev = ev||event ev.stopPropagation()//ev.cancleBubble，阻止了冒泡，此处无法冒泡到全局的禁止。所以此处wrap的右键菜单依然生效 &#125; //阻止一个元素的默认行为与冒泡有关系。先全禁止，在想开放的地方阻止冒泡。&#125; 移动端模板 1，meta标签 1&lt;meta name=\"viewport\" content=\"width=device-width,inital-scale=1.0,minmum-scale=1.0,maximum-scale=1.0\" /&gt; 2，全面阻止事件默认行为 隐患：页面的所有滚动条失效 需要自定义滚动条。 3，适配方案 123456;(function(flag)&#123;var styleNode = document.creatElement(\"style\")var w = document.documentElement.clientWidth/flagstyleNode.innerHtml = \"html&#123;font-size: \"+w+\" px!important&#125;\"document.head.iappendChild(estyleNode)&#125;)(16)//每个iife之前要用;隔开 2.2 移动端事件的点透1，pc端事件可以在移动端触发 2，pc端事件没有延迟 3，移动端事件有300ms延迟 并列元素重叠，会阻挡你事件的触发（父子元素因为存在冒泡所以不影响）。如果取消阻挡层，就可以重新触发事件。但是一次操作会触发两个动作（取消阻挡层并且触发被阻挡层的默认行为）。因为事件延迟的存在。 2.3 事件的误触因为滑动操作也是要先触发点击touchstart才行，所以滑动操作会误触点击操作。解决方法是在触摸操作结束时对操作的类型进行判断，决定是否调用点击操作。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt; &lt;a href=\"http://www.bing.com\"&gt;必应&lt;/a&gt;&lt;/body&gt; &lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; //阻止事件默认行为 document.addEventListener(\"touchstart\",function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(\"a\");//定义变量储存列表 for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(\"touchstart\",function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(\"touchmove\",function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(\"touchend\",function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125; &#125; &lt;/script&gt;","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端适配一","date":"2020-06-09T01:09:01.000Z","path":"2020/06/09/移动端适配一/","text":"适配的意义在不同设备上实现等比例显示 相对单位em是相对字体大小来计算的，谷歌下1fontsize一般是16像素，所以此时1em=16pxrem相对于根元素的字体大小来计算的，根元素是html，计算方法同上vw 相对于视口宽度进行计算的，100vw=一个视口宽度。 1vw=视口宽度/100Vh 相对于视口高度进行计算，计算方法同上 适配方法 rem适配—原理 改变一个元素在不同设备上的css像素的个数 ，元素所占的css像素个数是变的，每个css像素面积不变 —实现 12345#test&#123; width: 8rem; height: 1rem; background: pink;&#125; 第一步 创建style标签第二三步 将根标签的font-size置为布局视口的宽/16第四步 将style标签添加到head中 123456(function()&#123; var styleNode &#x3D; document.createElement(&quot;style&quot;);&#x2F;&#x2F;创建style标签节点 var w &#x3D; document.documentElement.clientWidth&#x2F;16;&#x2F;&#x2F;计算fontsize，这里获取了布局视口宽度 styleNode.innerHTML &#x3D; &quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;;&#x2F;&#x2F;在style里设置html中的fontsize ocument.head.appendChild(styleNode);&#x2F;&#x2F;把标签节点插入到head标签里 &#125;)() —优缺点优点：可以使用完美视口（没有改变缩放系数）缺点：px到rem的转化特别麻烦（每次都要自己算） viewport适配将所有设备布局视口宽度设置为设计图宽度,方法是调整系统缩放倍数 12345#test&#123; width: 320px; height: 100px; background: pink;&#125; 将所有设备的布局视口的宽置为设计图的宽度第一步 定义设计图的宽度第二步 确定系统缩放比例第三步 选中viewport标签，改变其content值 123456(function()&#123; var targetW &#x3D; 640; var scale &#x3D; document.documentElement.clientWidth&#x2F;targetW; var meta &#x3D; document.querySelector(&quot;meta[name&#x3D;&#39;viewport&#39;]&quot;); meta.content&#x3D;&quot;initial-scale&#x3D;&quot;+scale+&quot;,minimum-scale&#x3D;&quot;+scale+&quot;,maximum-scale&#x3D;&quot;+scale+&quot;,user-scalable&#x3D;no&quot;; &#125;)() –原理： 改变一个css像素与物理像素的比例。viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的，但是css像素和物理像素的比例是不一样的，也就是css的面积是变得。 –优缺点： 优点:所量即所得（只算一次） 缺点:没有使用完美视口（改变了缩放系数，不为1了）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端基础概念","date":"2020-06-08T08:32:47.000Z","path":"2020/06/08/移动端基础概念/","text":"APP的三种类型 web app，使用html5，需要向服务器请求资源，性能较慢但是现在有了提升，开发快，成本低，更新迭代快，会是将来的主流。 native app，原生应用，资源在本地，性能高。安卓使用java语言，ios使用objectC 混合app，结合性能与开发速度 关于适配的相关概念1. 屏幕 屏幕尺寸：屏幕对角线的长度，单位为英寸，1英寸=2.54厘米。 屏幕分辨率：屏幕的两个方向物理像素点数，单位px，1px=1像素点。1080*1920 屏幕密度：每英寸物理像素的个数 2. 像素 位图像素：图像的最小单位。一个位图像素对应一个物理像素就能完美清晰的展示（失真，锐化） 物理像素（设备像素）：设备呈现的最小单位，固定的。但是不同设备的一个物理像占据屏幕尺寸可能不一样，这就引出了等比的适配问题，现在屏幕分辨率高，所以物理像素多就导致了物理像素小。iphone6的物理像素为750px 设备独立像素（屏幕设备）：可以由程序员使用的虚拟像素，设备对接css像素的接口，只有css像素与设备独立像素挂钩width=device-width,（没有这句话，像素比是无效的）像素比才有其真正的作用。一般会让css像素等于这个设备独立像素。iphone6的物理像素为375px css像素：一个抽象单位，最终转换为物理像素（通过让css像素等于设备独立像素,然后利用像素比转换）。用来度量web页面的内容，web开发的最小单位 。一个css像素最终占据多少个物理像素由屏幕特性以及用户的缩放行为决定决定，在像素比为2的屏幕一个css像素占据四个物理像素， 像素比：物理像素/设备独立像素 （是设备固有的特性） iPhone6的像素比为750/375=2，像素比是单个方向的，这里是切图要注意的以一个3018的图片为例子，在像素比为1屏幕的就是30x18下，在像素比为2的屏幕就是60x36，这样就能完美显示。像素比获取命令： 1var dpr = window.devicePixelRatio||2 //如果不能自动获取，那其实我们知道为2 3. 视口（视口宽度用的都是css像素，所以逻辑上是可变的）3.1布局视口（决定网页布局）在PC端上，布局视口的宽度就等于浏览器窗口的宽度。而在移动端上，如果要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，那么布局视口需要大于移动设备的屏幕。Js获取布局视口尺寸的命令： 1document.documentElement.clientWidth | document.body.clientWidth 布局视口的出现，在极大程度上帮助了桌面网站到移动设备上的转移。iphone6的布局视口是980css像素 3.2 视觉视口（决定用户可视内容）滚动条由视觉窗口决定。Js获取视觉视口的命令： 1window.innerWidth； 一个css像素占据的物理像素的数量和视觉视口有很大关系，因为一个视觉视口包含的物理像素是固定的，但是包含的css像素个数会被缩放操作所影响，这个css像素个数就是视口宽度。视觉视口的初始值一般等于屏幕设备（设备独立像素）。iphone6的视觉视口初始值为375css像素。 3.3 理想视口（布局视口的一个状态）理想视口：布局视口的一个理想尺寸，只有当布局视口和屏幕设备一样宽（也就是和初始视觉视口一样大），才是理想视口。Js获取理想视口（屏幕宽度）的命令： 1window.screen.width 加入name为viewport的meta标签后理想视口才会出现（因为只有这个标签才能设置布局视口） 1&lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; 语句width=device-widthi（布局视口（css像素）=屏幕设备（设备独立像素））使得css像素与设备独立像素联系起来（开启像素比，因为像素比的定义和css像素没关系，加上这句话就联系上了css像素）这句话让布局视口的宽度等于了独立设备像素的宽度。不写这句话默认布局视口宽度就为980，写了变375。此时布局视口与视觉视口保持一致，布局视口成为理想视口。但是在理想视口下，如果元素过大，视觉视口会自动地尽量地包住你的内容（此时缩放比例不再为1），就会出现虽然元素超出了视觉视口但是不出现滚动条的现象，这个问题需要用完美视口解决。 3.4 完美视口（布局视口的一个状态）缩放比例为1的理想视口就成为完美视口 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"/&gt; 用来解决太大的元素超过出视觉窗口不出现滚动条的问题，width=device-width,initial-scale=1.0,如果这两者冲突的话，布局视口取两者间的较大值，只有这两个操作才能改变布局视口。注意，缩放比（系统缩放）是基于理想视口（分子）计算的var scale = document.documentElement.clientWidth/targetW;目标大那么尺缩比小于1，缩小目标；目标小那么尺缩比大于1，放大目标（所以width=device-width写在前面，先创造出理想视口，再计算）改变的是布局视口和视觉视口 4. 缩放操作（操作css像素）操作的类型 放大，放大css像素的面积，css像素占据更多的物理像素，能放下的css像素变少，视口尺寸变小 缩小，缩小css像素的面积，css像素占据更小的物理像素，能放下的css像素变多，视口尺寸变大 操作的对象 用户的操作PC端 影响布局视口移动端 影响视觉视口 系统操作（meta标签里的缩放）同时影响布局视口和视觉视口 5. 等比问题 没有加name为viewport的meta标签（一般布局视口）一个相同css像素大小的区域在不同的设备是等比例缩放的，能完整显示网页，在不同的设备上占据的实际物理大小（英寸）不一样 加name为viewport的meta标签 （理想布局视口）一个相同css像素大小的区域在不同的设备是不等比的，不能完整显示网页，在不同的设备上占据的实际物理大小（英寸）是一样的 等比是不是一个必须的需要？要求：在文字要完美清晰的展示的同时，还要做到百分百还原设计图（也是就是要等比）。 虽然不加mtae标签就已经等比了，但是这种会使得网页在移动端的字体变得很小 （做不到文字要完美清晰的展示） 要两者都做到那就得分两步。 1，展示清晰文字—-&gt; 必须加meta标签（不等比）2，恢复其他元素的等比—&gt; 适配！！！！（加上meta标签后也得等比）","comments":true,"tags":[{"name":"移动端适配","slug":"移动端适配","permalink":"https://zhoubb96.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"windows下在node环境利用hexo搭载个人博客","date":"2020-06-08T04:44:40.000Z","path":"2020/06/08/windows下在node环境利用hexo搭载个人博客/","text":"一，Git的下载与身份配置 安装Git，下载地址是：https://git-scm.com/ ,可以找速度快的淘宝镜像，下载后安装 使用命令 1git config --global user.name&quot;xxx&quot; 配置用户名 使用命令 1git config --global user.email &quot;xxx@xxx.com&quot; 配置邮箱 二，node的下载 安装Nodejs，下载地址是：https://nodejs.org/ 通过命令1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org 设置淘宝源，通过命令npm config get registry来检查是否配置成功 通过命令1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 安装cnpm，安装后就可以通过 cnpm install xxx来使用cnpm了。 三，hexo框架的下载与使用 全局安装hexo框架，1npm install hexo-cli –g 在任意一个位置创建一个文件夹来存放你的blog项目，在此文件夹下打开终端，输入 hexo init 初始化博客项目 创建文章，hexo n &quot;我的第一篇博客&quot; 安装部署插件，1cnpm install --save hexo-deployer-git 四，博客的预览与部署 下载主题，1git clone git:&#x2F;&#x2F;github.com&#x2F;tommy351&#x2F;hexo-theme-light.git themes&#x2F;light 下载后在_config.yml切换主题1theme: light 本地预览运行，hexo server（可用简写hexo s） 生成静态网页，hexo generate（可用简写hexo g） 新建一个仓库用来部署网页，仓库命名要求为你的昵称如：zhoubb96.github.io复制这个仓库的地址填到deploy的设置repo中修改_config.yml 1234deploy: type: &#39;git&#39; repo: https:&#x2F;&#x2F;github.com&#x2F;zhoubb96&#x2F;zhoubb96.github.io.git branch: masterd 部署到远端，hexo deploy（可用简写hexo d） 每次更新都要重新生成与上传。 许多个性化的设置需要在主题目录或者主目录下的_config.yml进行修改。","comments":true,"tags":[{"name":"博客搭载","slug":"博客搭载","permalink":"https://zhoubb96.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E8%BD%BD/"}]}]